Groovy
	完全兼容Java语法
	分号是可选的
	类、方法默认是public的
	编译器给属性自动添加getter/setter方法
	属性可以直接用点号获取
	最后一个表达式的值会被作为返回值，如果该方法是需要返回值的，最后一个return可以不写
	==等同于equals()，不会有NullPointExceptions

	assert语法	可以在任何地方进行断言操作
	可选类型定义	弱类型定义		def 变量名，类似js var
	可选的括号	调用方法时，如果有参数，括号是可以不写的
	字符串		有三种表达形式，''	""	'''
	集合API		List、Map有更简单的写法
	闭包			


//groovy高效特性
//1.可选的类型定义
def version =1

//2.assert
//assert version == 2

//3.括号是可选的
//println(version)
println version

//4.字符串
def s1 = 'imooc'  //仅为字符串
def s2 = "gradle version is ${version}" //可通过${}插入变量
def s3 = '''my
name is
imooc'''    //可换行

println s1
println s2
println s3

//5.集合API
//list
def buildTools = ['ant','maven']
buildTools << 'gradle'
assert buildTools.getClass() == ArrayList
assert buildTools.size() ==3
//map
def buildYears = ['ant':2000,'maven':2004]
buildYears.gradle = 2009

println buildYears.ant
println buildYears['gradle']
println buildYears.getClass() //class java.util.LinkedHashMap

//6. 闭包 gradle
def c1 = {
    v ->
        print v
}

def c2 = {
    print 'hello'
}

def method1(Closure closure){
    closure('param')
}

def method2(Closure closure){
    closure()
}

method1 (c1)
method2 (c2)


//构建脚本中默认都是有个Project实例的  apply()
//group 'ml.yzhe.test.gradle'
project.group = 'ml.yzhe.test.gradle'
apply plugin: 'java'
apply plugin: 'war'   //如需要打包成war包

version = '0.1'

//repositories 闭包作为参数，调用方法
repositories {
	mavenCentral()
}

dependencies{
	compile 'commons-codec:commons-codec:1.6'
}

java -classpath groovy-1.0-SNAPSHOT.jar ml.yzhe.test.gradle.todo.App

project  task1 (taks2 ...)

project
当构建启动后，Gradle会基于build.gradle实例化一个 org.gradle.api.Project 类，并且能够通过project变量使其隐式可用
	group 、 name 、version
	apply 、 dependencies 、 repositories 、 task
	属性的其他配置方式：ext 、 gradle.properies

task  org.gradle.api.Task 主要包括任务动作和任务依赖。	任务动作 定义了一个最小的工作单元	可以定义依赖于其他任务、动作序列和执行条件
	dependsOn			//依赖于
	doFirst 、 doLast <<   //doFirst在任务列表最前添加动作	  << 是 doLast 的缩写，是动作列表的末尾添加动作

	Gradle并不保证依赖的任务能够按顺序执行，dependsOn方法只是定义这些任务应该在这个任务之前执行

自定义任务000000000000000000000000000000000000000000
def createDir = {
    path ->
        File dir = new File(path)
        if(!dir.exists()){
            dir.mkdirs()
        }
}
task makeJavaDir(){
    def paths = ['src/main/java','src/main/resources','src/test/java','src/test/resources']
    doFirst{
        paths.forEach(createDir)
    }
}

task makeWebDir(){
    dependsOn 'makeJavaDir'
    def paths = ['src/main/webapp','src/test/webapp']
    doLast{
        paths.forEach(createDir)
    }
}	

运行的时候排除一个任务
比如运行的时候你要排除yayGradle0,你可以使用-x命令来完成
gradle groupTherapy -x yayGradle0

从JAR文件中启动应用，你需要在manifest文件MANIFEST.MF中包含首部Main-Class。
jar {
	manifest {
		attributes 'Main-Class': 'com.manning.gia.todo.ToDoApp'
	}
}

War插件引入了两个新的依赖配置，用于Servlet依赖的配置是providedCompile，
这个用于那些编译器需要但是由运行时环境提供的依赖，你现在的运行时环境是Jetty，因此用provided标记的依赖不会打包到WAR文件里面，运
行时依赖比如JSTL这些在编译器不需要，但是运行时需要，他们将成为WAR文件的一部分。
dependencies {
	providedCompile 'javax.servlet:servlet-api:2.5'
	runtime 'javax.servlet:jstl:1.1.2'
}
自定义WAR插件
假设你把所有的静态文件放在static目录，所有的web组件放在webfiles
//Changes web application source directory
webAppDirName = 'webfiles'
//Adds directories css and jsp to root of WAR file archive
war {
from 'static'
}

apply plugin: 'jetty'
启动Jetty容器并且无需创建WAR文件
gradle jettyRun
jettyRun {
	httpPort = 9090
	contextPath = 'todo'
}


构建生命周期 按序
	初始化	初始化项目	有哪些项目参与到构建中
	配置		配置代码	dependsOn def
	执行		动作代码	doFirst doLast

依赖管理
	工件坐标
		group 、 name 、version
	常用仓库
		mavenLocal	/ mavenCentral / jcenter
		自定义maven仓库	maven私服
		文件仓库	不推荐
			复制从Maven中央仓库解析的依赖到libs/cargo目录
			task copyDependenciesToLocalDir(type: Copy) {
				//Gradle提供的语法糖
				from configurations.cargo.asFileTree
				into "${System.properties['user.home']}/libs/cargo"
			}
			//怎么给cargo配置添加JAR文件依赖
			dependencies {
				cargo fileTree(dir: "${System.properties['user.home']}/libs/cargo",include: '*.jar')
			}
		按序
		repositories {
		    mavenLocal()
		    mavenCentral()
		    //私服地址
		    maven {
		    	url ''
		    }
		}
	依赖的传递性
		B依赖A ，如果C依赖B，那么C依赖A 。 会造成版本冲突
	自动化依赖管理
		多次使用同个jar包，构建工具会进行缓存
	依赖阶段配置
		compile 、 runtime
		testCompile 、 testRuntime
		运行时阶段扩展于编译阶段，大部分使用编译时依赖
			两种写法都行
		    dependencies {
			    compile 'ch.qos.logback:logback-classic:1.3.0-alpha4'
			    testCompile group: 'junit', name: 'junit', version: '4.12'
			}												
	解决版本冲突
		查看依赖报告
			help
				dependencies
		排除传递性依赖
			compile (''){
				exclude group:"org.slf4j" , module: "slf4j-api"
				//transitive = false
			}		
			Gradle允许你使用transitive属性来排除所有的传递依赖	

		强制指定一个版本
			configurations.all{
				resolutionStrategy{
					force 'org.slf4j:slf4j-api:1.7.24'
				}
			}
		修改默认解决策略，当版本冲突时报错构建失败，默认使用版本最高
		configurations.all{
			resolutionStrategy{
				failOnVersionConflict()
			}
		}
		动态版本声明
			可以使用latest.integration
			也可以用一个+号来动态的声明
			org.codehaus .cargo:cargo-ant:latest-integration
			//依赖最新的1.x版本
			cargo 'org.codehaus.cargo:cargo-ant:1.+'


下载后的文件被存储在USER_HOME/.gradle/cache/

多项目构建
	项目模块化
	配置子项目
		所有项目应用Java插件
		Web子项目打包成war
		所有项目添加logback日志功能
		统一配置公共属性	group version
	
	compile project(":model")

	settings.gradle
		rootProject.name = ''
		include ''
		include 'model'

	在root中的build.gradle中，其他子模块中删除
	allprojects {
		apply plugin: 'java'
		sourceCompatibility = 1.8
	}

	subprojects {
		repositories {
		    mavenLocal()
		    mavenCentral()
		}
		dependencies {
		    compile 'ch.qos.logback:logback-classic:1.3.0-alpha4'
		    testCompile group: 'junit', name: 'junit', version: '4.12'
		}
	}

	统一配置公共属性	group version,root项目下增加
	gradle.properties
		 group='ml.yzhe.test.gradle'
		 version='1.0-SNAPSHOT'
		 exampleProp = myValue
		 someOtherProp = 455

	你可以在项目中访问这两个变量：
	assert project.exampleProp == 'myValue'
	task printGradleProperty << {
		println "Second property: $someOtherProp"
	}	

gradle projects	 

gradle自动测试
	测试框架 JUnit , TestNG
	项目布局
		src main
			test
		build
			classes
				test
			reports     //html
				test
			test-results	//xml		

			使用Groovy自定义项目布局更加的方便：
			sourceSets {
				main {
					java {
						srcDir 'src/java'
					}
				resources {
						srcDir 'src/resources'
					}
				}
			}

	测试配置
		dependencies {
		    testCompile 'junit:junit:4.12'
		}	

	测试任务
		测试将在  check build 之前执行，测试失败将check失败
	测试发现
		任何继承自 junit.framework.TestCase 或 groovy.util.GroovyTestCase 的类
		任何被 @RunWith 注解的类
		任何至少包含一个被 @Test 注解的类

发布
	发布到本地和远程仓库
		apply plugin: 'maven-publish'
		publishing {
			publications {
				myPublish(MavenPublication){
					from components.java
				}
			}
			repositories {
				maven {
					name "myRepo"
					url ""
				}
			}
		}	

	执行 publish 任务	

Gradle包装器
	它允许你的机器不需要安装运行时就能运行Gradle脚本，而且她还能确保build脚本运行在指定版本的Gradle。	
	它会从中央仓库中自动下载Gradle运行时，解压到你的文件系统，然后用来build。
	终极目标就是创建可靠的、可复用的、与操作系统、系统配置或Gradle版本无关的构建。

	配置Gradle包装器
	task wrapper(type: Wrapper) {
		gradleVersion = '1.7'
	}

	自定义
	task wrapper(type: Wrapper) {
		//Requested Gradle version
		gradleVersion = '1.2'
		//Target URL to retrieve Gradle wrapper distribution
		distributionUrl = 'http://myenterprise.com/gradle/dists'
		//Path where wrapper will be unzipped relative to Gradle home directory
		distributionPath = 'gradle-dists'
	}

	gradle wrapper

	如果你的系统中已经安装了Gradle运行时，你就不需要再添加一个gradle wrapper任务
	你可以直接运行gradle wrapper任务，这个任务会使用你的Gradle当前版本来生成包装文件。

	gradlew

	gradlew.bat jettyRun

Gradle提供一个基于SLF4J库的日志实现。除了实现了基本的日志级别（DEBUG, ERROR, INFO, TRACE, WARN)）外，还添加了额外的级别quiet

终结者任务
Gradle提供了一个finalizer任务

task first << { println "first" }
task second << { println "second" }
//声明first结束后执行second任务
first.finalizedBy second

gradle -q first
你会发现任务first结束后自动触发任务second

ext.versionFile = file('version.properties')

Gradle自带的任务类型
	Zip和copy用在发布项目中
	//eg.使用任务类型来备份发布版本
	task createDistribution(type: Zip, dependsOn: makeReleaseVersion) {
	//引用war任务的输出
	    from war.outputs.files
	//把所有文件放进ZIP文件的src目录
	    from(sourceSets*.allSource) {
	        into 'src'
	    }
	//添加版本文件
	    from(rootDir) {
	        include versionFile.name
	    }
	}
	task backupReleaseDistribution(type: Copy) {
	//引用createDistribution的输出
	    from createDistribution.outputs.files
	    into "$buildDir/backup"
	}
	task release(dependsOn: backupReleaseDistribution) << {
	    logger.quiet 'Releasing the project...'
	}


