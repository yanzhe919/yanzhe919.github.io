
http://www.zhihu.com/question/34474517?sort=created
http://www.yxbao.com/xw/94001.html
http://bbs.ithome.com/thread-659472-2-1.html


http://btkitty.red/
http://www.btkuaisou.com/
http://www.bt177.net/

http://www.btspreads.com/


idm 防火墙拦截验证 为了治疗不用破解补丁的强迫症们、你懂的
http://tieba.baidu.com/p/3878377959

IDM 6.25 Build22 最新破解版
http://www.ccav1.com/idm.html


CAS 单点登录
http://www.mossle.com/docs/springsecurity2/html/cas.html
http://denger.iteye.com/blog/809170
http://hugoren.iteye.com/blog/2200663
http://haohaoxuexi.iteye.com/blog/2137767
https://wiki.jasig.org/display/casum/ticket+expiration+policy

http://www.voidcn.com/blog/baidu_18607183/article/p-6125930.html
http://blog.csdn.net/tch918/article/details/22276627

CAS研究（四）-登出/logout
http://blog.csdn.net/kongls08/article/details/9223213

aptitude install --without-recommends lxde
apt-get --no-install-recommends install xorg lxde-core tightvncserver
apt-get install xorg lxde-core tightvncserver

apt-get -y purge xorg lxde-core tightvncserver
apt-get remove xorg lxde-core tightvncserver

apt-get autoremove && apt-get clean

wget http://ftp.mozilla.org/pub/firefox/releases/32.0/linux-i686/en-US/firefox-32.0.tar.bz2


service tightvncserver restart

tightvncserver -kill :1
tightvncserver

su root -c "/usr/bin/tightvncserver :1 -geometry 1024x768"
su root -c "/usr/bin/tightvncserver :1"

apt-get install iceweasel

vi /etc/rc.local







1、神箭手云爬虫：https://www.oschina.net/p/crawler-samples
特定：傻瓜化，抓取在平台上面，有的收钱，微信、微博都有现成代码

2、WebCollector
1）自定义遍历策略，可完成更为复杂的遍历业务，例如分页、AJAX
2）可以为每个URL设置附加信息(MetaData)，利用附加信息可以完成很多复杂业务，例如深度获取、锚文本获取、引用页面获取、POST参数传递、增量更新等。
3）使用插件机制，WebCollector内置两套插件。
4）内置一套基于内存的插件（RamCrawler)，不依赖文件系统或数据库，适合一次性爬取，例如实时爬取搜索引擎。
5）内置一套基于Berkeley DB（BreadthCrawler)的插件：适合处理长期和大量级的任务，并具有断点爬取功能，不会因为宕机、关闭导致数据丢失。
6）集成selenium，可以对javascript生成信息进行抽取
7）可轻松自定义http请求，并内置多代理随机切换功能。 可通过定义http请求实现模拟登录。
8）使用slf4j作为日志门面，可对接多种日志

特定：可以设置代理那些，

3、webmagic
特定:偏向于垂直抓取，可能比较好用，有教程，不过还不是很完善，在建设中，它包含了下载、调度、持久化、处理页面等模块。每一个模块你都可以自己去实现，也可以选择它已经帮你实现好的方案。这就有了很强的定制性。

4、基于Nutch&Solr定向采集解析和索引搜索的整合
特定：基于Nutch，偏向于搜索引擎，在建设，具体还要看情况

5、Heritrix
特定：使用的人比较多，功能齐全，文档完整，网上的资料也多。有自己的web管理控制台，包含了一个HTTP 服务器。操作者可以通过选择Crawler命令来操作控制台，没有用过，不知道


检查switch分支中是否包含break
javac -Xlint:fallthrough

查看支持的全部扩展选项
javac -X


大部分时候，如果循环体只包含一条语句，那么就可以省略循环体的花括号；但如果循环体只包含一条局部变量定义语句，那依然不可以省略循环体的花括号。


Hprose无侵入式设计，不需要单独定义类型，不需要单独编写服务，已有代码可以直接发布为服务。具有丰富的数据类型和完美的跨语言类型映射，支持自引用，互引用和循环引用数据。支持众多传输方式，如 HTTP、TCP、Websocket 等。客户端具有更灵活的调用方式，支持同步调用，异步调用，动态参数，可变参数，引用参数传递，多结果返回（Golang）等语言特征，Hprose 2.0 甚至支持推送。具有良好的可扩展性，可以通过过滤器和中间件实现加密、压缩、缓存、代理等各种功能性扩展。兼容的无差别跨语言调用支持更多的常用语言和平台支持浏览器端的跨域调用没有中间语言，无需学习成本性能卓越，使用简单


aria-hidden="true"
前端基础-BootStrap-其他
aria开头的属性都是给视力障碍人士使用的哈

运用Bootstrap的栅格系统，可以做出像table那样定义多少行，多少列效果，但是又比table灵活。
运用Bootstrap的栅格系统，首选需要准备一个class=container的div
紧接着需要一个class=row的 div，表示行
再挨着的div，就是列了。

Bootstrap的栅格系统会默认把一行，分成12列。

当同一行的栅格总数超过12的时候，就会自动换行

<div class="container">
    <div class="row">
        <div class="col-xs-6 ">一半</div>
        <div class="col-xs-6 ">一半</div>
    </div>
</div>

<div class="container">
    <div class="row">
        <div class="col-xs-8 ">8格</div>
        <div class="col-xs-6 ">6格</div>
    </div>
</div>


使用命令

netstat -ano|findstr "80"


查看 端口号包含"80"的占用情况

使用命令:

tasklist|findstr "1828"


1828根据上一步找到的对应的pid

最后使用

taskkill /f /t /im java.exe


结束java.exe

结束成功会提示：
成功： 已终止 。。。

JAVA问题定位大杂汇之java 虚拟机内存占用超出 -Xmx设置
Linux提宫了查看进程内存映射的命令pmap(Pmap 提供了进程的内存映射，pmap命令用于显示一个或多个进程的内存状态。其报告进程的地址空间和内存状态信息。）
解决办法就是：export MALLOC_ARENA_MAX=1

Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字

Tomcat启动的时候会报一个Exception loading sessions from persistent storage异常，但是又不影响正常的业务。

omcat启动的时候会报一个Exception loading sessions from persistent storage异常

该问题的原因是tomcat的session持久化机制引起的，tomcat这个功能本身的用意在于重启tomcat后保存之前的session，Tomcat会把session持久化在%TOMCAT%/work/Catalina/localhost/session.ser 这个文件里。 但是因为tomcat非正常关闭，所以这个文件没有正确地结束(无EOF标记)

解决办法治标： 只需要删除 session.ser文件即可。

解决办法治本：关闭tomcat的持久化功能，就能一劳永逸的解决这个问题。具体为修改conf下的server.xml文件。在项目的context间加入一句代码

<Manager className="org.apache.catalina.session.PersistentManager" saveOnRestart="false"/>


重启tomcat以后再也不会报这个错误了。
代码比较
<Context path="/" docBase="D:\\project\\j2ee\\web" debug="0" reloadable="false" >
    <Manager className="org.apache.catalina.session.PersistentManager" saveOnRestart="false"/>
</Context>


<b>
<strong>
都可以用来实现粗体的效果

区别：
b是bold的缩写，仅仅表示该文本是粗体的，并不暗示这段文字的重要性
strong虽然也是粗体，但是更多的是强调语义上的加重，提醒用户该文本的重要性。 在SEO（搜素引擎优化）的时候，也更加容易帮助用户找到重点的内容
推荐使用strong


<i>和<em>都可以表示斜体效果
区别：
i是italic的缩写，仅仅表示该文本是斜体的，并不暗示这段文字的重要性

em 是 Emphasized的缩写，虽然也是斜体，但是更多的是强调语义上的加重，提醒用户该文本的重要性。 常常用于引入新的术语的时候使用。

有时候，需要在网页上显示代码，比如java代码

就需要用到pre

<pre>
public class HelloWorld {

    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}

</pre>

<del>即删除标签
delete的缩写
<s>使用s标签实现的删除效果，但是不建议使用，因为很多浏览器不支持s标签</s>

<ins>即下划线标签
<u>使用u标签实现的下划线效果，但是不建议使用</u>


如果图片不存在，默认会显示一个缺失图片，这是不友好的
所以可以加上alt属性。
当图片存在的时候，alt是不会显示的
当图片不存在的时候，alt就会出现

ojdbc.jar包位于以下目录
cd $ORACLE_HOME/jdbc/lib

快照


编译

运行
类加载器
字节码校验
解释  及时编译JIT
运行执行

JVM

jdk jarsigner.exe  签名

javac.exe  实际调用-> tools.jar -> javac/Main.class
bin        下大多数-> tools.jar

ERP：企业资源计划（ Enterprise Resource Planning ），针对物资资源管理（物流）、人力资源管理（人流）、财务资源管理（财流）、信息资源管理（信息流）集成一体化的企业管理软件

CRM：客户关系管理（Customer Relationship Management）是指用计算机自动化分析销售、市场营销、客户服务以及应用支持等流程的软件系统

BPM：业务流程管理（Business Process Management），即，是一套达成企业各种业务环节整合的全面管理模式。

OA：办公自动化（Office Automation）是将现代化办公和计算机网络功能结合起来的一种新型的办公方式。


Tomcat  role 分类
manager-gui：允许访问管理页面和状态信息页面
manager-status：允许访问状态信息页面
manager-script：允许访问文本接口和状态信息页面
manager-jmx：允许访问Java管理扩展代理和状态信息页面


set path=D:/Program Files/Java/jre7/bin
java  -cp "lib/*;"  -Xms256m -Xmx4000m org.junit.runner.JUnitCore com.test.MethodTest
pause

禁用cookie后，可用URL重写，response.encodeURL("URL"); 添加jsessionid=cookie中保存的sessionid
Cookie 要保存中文，应该使用escape(string)进行编码，当然读取一个经过编码的cookie时，还必须要经过unescape(string)解码

jsessionid
http://  index.jsp;jsessionid=xxxxx(32位)

cookie
为了保证cookie安全  cookie.getMaxAge() = -1   path 也获取不到
domain 支持cookie跨域
cookie.setDomain(".yzhe.ml");

Age = 0(文件和缓存),-1（只删除文件）
删除cookie: 指定key, domain, path 必须与想要删掉的cookie一模一样, 然后将expires的值设为一个过期值,即可删除.


http://eux.baidu.com/blog/2017/06/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84cookie


给当前页面中提供base地址，后续href中，可只写a.html
<base href="http://localhost:8080/myweb/">

psexec.exe 可以执行远程bat调用

代理：必须要根据给定的接口，在内存中创建实现这个接口的子类，$Proxy()
动态代理
Object proxyObject = Proxy.newProxyInstance(ConnUtils.class.getClassLoader(), new Class[]{被代理的类的接口数组.class},
                        new InvocationHandler() {  //执行句柄
                            @Override
                            public Object invoke(Object proxy 代理, Method method 方法反射, Object[] args) throws Throwable {

Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类。使用CGLIB即使被代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：
使用CGLIB需要导入以下两个jar文件：
	asm.jar – CGLIB的底层实现。
	cglib.jar – CGLIB的核心jar包。

CGLIB的核心类：
	net.sf.cglib.proxy.Enhancer – 主要的增强类
net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现
net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：
		Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。

包装
不需要接口，但声明一个类，变成包装类的子类，同时拥有一个被包装类的成员
A extends B{
	private B b;

}

如果官方提供了包装类适配器，则应该优先使用包装类
		没					则可以使用动态代理

反射很慢
现代JVM也不是非常慢了，它能够对反射代码进行缓存以及通过方法计数器同样实现JIT优化，所以反射不一定慢。


标准数据库连接池
javax.sql.DataSource

老版win只能识别60层目录

STAX
XML流解析
XMLStreamReader
几个关键点：
XMLStreamReader.hasNext() –判断是否还有下一个节点，如元素或是文本。
Int next = XMLStreamReader.next() – 返回一个整数，确定是何种元素。
XMLStreamReader.getLocalName() – 返回元素的节点名称。
XMLStreamReader.getText() – 返回文本。
XMLStreamReader.getAttributeValue(nameSpace,attName) – 返回属性值。

JAXB2在底层是用StAX(JSR 173)来处理XML文档。

JDK6提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给HttpHandler实现类的回调方法。

HttpServer server = HttpServer.create(new InetSocketAddress(9999),0);
		//启动以后，访问：http://localhost:9999/hello即可以访问
		server.createContext("/hello",new HttpHandler() {
		});

server.start();


jdk1.6内置对JavaScript的支持
ScriptEngineManager factory = new ScriptEngineManager();  
脚本编译的过程如下：首先将 engine 转换为 Compilable 接口，然后调用 Compilable 接口的 compile 方法得到一个 CompiledScript 的实例，这个实例就代表一个编译过的脚本，如此用 CompiledScript 的 eval 方法即为调用编译好的脚本了。在我的 Think Pad 上，这段代码编译后的调用大约比直接调用 engine.eval 要快 3-4 倍。随着脚本复杂性的提升，性能的提升会更加明显。  脚本上下文与绑定 真正将脚本语言与 Java 联系起来的不是 ScriptEngine，而是 ScriptContext，它作为 Java 与 ScriptEngine 之间的桥梁而存在。一个 ScriptEngine 会有一个相应的 ScriptContext，它维护了一个 Map，这个 Map 中的每个元素都是脚本语言对象与 Java 对象之间的映射。同时这个 Map 在我们的 API 中又被称为 Bindings。一个 Bindings 就是一个限定了 key 必须为 String 类型的 Map —— Map<String, Object>。所以一个 ScriptContext 也会有对应的一个 Bindings，它可以通过 getBindings 和 setBindings 方法来获取和更改。一个 Bindings 包括了它的 ScriptContext 中的所有脚本变量，那么如何获取脚本变量的值呢？当然，从 Bindings 中 get 是一个办法，同时 ScriptContext 也提供了 getAttribute 方法，在只希望获得某一特定脚本变量值的时候它显然是十分有效的。相应地 setAttribute 和 removeAttribute 可以增加、修改或者删除一个特定变量。在 ScriptContext 中存储的所有变量也有自己的作用域，它们可以是 ENGINE_SCOPE 或者是 GLOBAL_SCOPE，前者表示这个 ScriptEngine 独有的变量，后者则是所有 ScriptEngine 共有的变量。例如我们执行 engine.put(key, value) 方法之后，这时便会增加一个 ENGINE_SCOPE 的变量，如果要定义一个 GLOBAL_SCOPE 变量，可以通过 setAttribute(key, value, ScriptContext.GLOBAL_SCOPE) 来完成。

mysql查询默认是不区分大小写的 如：
select  * from  table_name where  a like  'a%' 
要让mysql查询区分大小写，可以：
select  * from  table_name where  binary  a like  'a%'  
也可以在建表时，加以标识 
create table table_name(
     a varchar(20) binary
}


ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本。
ThreadLocal的接口方法：
void set(Object value)：设置当前线程的线程局部变量的值。
public Object get()：该方法返回当前线程所对应的线程局部变量。
public void remove()：将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。
需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，
所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。
protected Object initialValue()：返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。
这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，
并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。
在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal<T>。
ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本




1．强引用
本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
2．软引用（SoftReference）
如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
3．弱引用（WeakReference）
如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
4．虚引用（PhantomReference）
"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
为弱引用使用较多：





mysql
Show variables like ‘character%’; //只显示编码信息

在命令行，设置编码格式：
Shell/> set character_set_client=utf8;

/*显示所有系统变量的设置*/
SHOW VARIABLES;

/*显示所有以character开头的环境设置*/
SHOW VARIABLES LIKE 'character%';

/*功能同上*/
SHOW VARIABLES WHERE VARIABLE_Name LIKE 'character%';

/*显示当前数据库的编码格式*/
SHOW VARIABLES WHERE VARIABLE_NAME= 'character_set_database';

/*使用全局变量查询，功能同上*/
SELECT @@character_set_database;


/*设置自增量从1开始。默认就是从1开始*/
SET AUTO_INCREMENT_increment=1;

/*设置自增量每次增加2*/
SET AUTO_INCREMENT_offset=2;


JDBC4.0自动加载驱动器类
	从JDK1.6开始，Oracle就将修改了添加了新的加载JDBC驱动的方式。即JDBC4.0。在启动项目或是服务时，会判断当前classspath中的所的jar包，并检查META-INF目录下，是否包含services文件夹，如果包含，就会将里面的配置加载成相应的服务。


保证永远从ServletCofing、FilterConfig的获取ServletContext对象


JSTL将Long转成时间类型：
声明时间对象
<jsp:useBean id="tm" class="java.util.Date"></jsp:useBean>
//设置一个Long类型的时间
<c:set target="${tm}" property="time" value="${pageContext.request.session.creationTime}"></c:set>
//格式化显示
<fmt:formatDate value="${tm}" pattern="yyyy-MM-dd HH:mm:ss"/>



//生成ajax对象
function Ajax(){
	this.getHttp=function(){//生成ajax对象
		if(window.XMLHttpRequest){
			return new XMLHttpRequest();
		}else{
			return new ActiveXObject("Microsoft.XMLHttp");
		}
	};
	var http = this.getHttp();//获取XHR对象
	/**
	 * post请求，接收三个参数为url,param,success,failure
	 */
	this.post = function(url,param,func,failure){
		http.open("POST",url,true);
		http.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		http.onreadystatechange=function(){
			if(http.readyState==4){
				if(http.status==200){
					var txt = http.responseText;
					//调用用户的成功方法
					func(txt);
				}else{
					//如果存在失败方法则，如果失败，则调用用户的失败方法
					if(failure){
						failure(http.status,http);
					}
				}
			}
		};
		if(param){
			http.send(param);
		}else{
			http.send();
		}
	};
}
调用测试：
var ajax = new Ajax();
var url = path+"buy/BuyServlet";
ajax.post(url,"cmd=addOrDel&id="+obj.bookId+"&num=1",function(data){
	var amt=data;
	//以下是其他计算
	tr.cells[2].innerHTML=amt;
	tr.cells[3].innerHTML=(amt*parseFloat(tr.cells[1].innerHTML)).toFixed(2);
	calcute();
});


String.prototype.trim=function(){
  		var pattern = /^\s*/;//匹配开始的所有空格
  		var str = this.replace(pattern,"");
  		pattern = /\s*$/;
  		str = str.replace(pattern, "");
  		return str;
  	 };

jQuery中获取tagName
	本人使用jQuery1.7。在此版本中，并没有提供获取tagName的方法，即$(“#someid ”).attr(“tagName ”) ;返回的值为null。
只要能在运行时将jQuery对象，转成dom对象，即可以使用tagName如下：
$(this).get(0).tagName;
为此，不如为jQuery开发一个获取tagName的插件方法：
//为是jQuery编写一个最简单的插件，可以获取tagName
$.fn.tagName=function(){
	return this.get(0).tagName;
};

然后在代码的任意位置即可以调用：
somejQueryObj.click(function(){
		var tr = $(this).parent().parent();
		alert(tr.tagName());//此处调用自己的插件
});



Struts2的NoParameters接口
只要是继承以上接口中任意一个接口的Action，都不会去执行params拦截器中的获取参数的方法.

java泛型在运行期是没有的

List<String> list;

1. 另外赋值一个不带泛型的参数变量
List list2 = list;
list2.add(909);

2. 另外定义一个方法，参数不带泛型
public void add(List list,Object oo)

3. 反射
list.getClass.getMethod("add",Object.class).invoke(list,909);

一般使用的泛型<T>
Type 指的Class的接口Type

配置只对部分和.jsp压缩，其他的不压缩，
            还应配置对.js，.css压缩
     但决不能配置对所有请求都压缩，因为如果用户请求的是下载，那不但不能压缩，反而会让
     服务器因内存益处而崩溃。

对输出的数据进行压缩。或是对全站进行压缩。
		ByteArrayoutputsteam
		GzipoutputStream – 实现数据压缩
		设置三个头：
		resp.setContentType("text/html;charset=UTf-8");
		resp.setContentLength(dest.length);
		resp.setHeader("Content-Encoding","gzip");



1、使用HttpSessionListener记录在线人数。
2、使用HttpSessionAttributeListener记录登录人数。

HttpSessionBindingListener
HttpSessionActivationListener


管理登录(在线用户)：
第一步：书写一个HttpSession的监听，并维护一个LinkedHashMap，其中保存着所有用户的Session.
第二步：让上面的类，同时实现ServletContextListener接口，并将LinkedHashMap添加到ServletContext对像中。
第三步：实现一个页面，显示所有SessionID。
第四步：在页面上添加踢出按扭，通过SessionID在Map中查询指定的Session，然后执行它的invalidate方法，清除它。从而实现踢出用户的功能。
第五步：改进，应该通过HttpSessionAttributeListener监听器，只踢出登录成功的用户。对于游客不用关心。


服务使用断点下载时，响应的信息是206。
1:如何通知服务器只给我3以后数据。
   req.setHeader("range","bytes=0-"); 从第0字节以后的所有字节
   range=”bytes=3-”

2：我如何知道自己已经下载的3K数据。
   读取文件大小。
   file.length();

3：如果从当前已经下载的文件后面开始追加数据。
  FileRandomAccess 随机访问文件对象
  seek(long);
  skip(long);

如果定义了一个注解之后，没有说明这个注解可以注解的位置，则这个注解就可以注解在所有位置上。
是否存在某个注解。
boolean boo2 = m.isAnnotationPresent(MyTest.class);
/**
	 * 对于一人注解类来说。
	 * value属性是官方建议取的名称
	 * 且value也是默认属性
	 * 以下定义的属性，因为没有默认值 ，所以用户
	 * 在使用时必须给显式的给值
	 */
	public String value();
	/**
	 * 定义一个拥有默认值的属性
	 */
	public String name() default "NoName";



可以看出在处理动态资源时NIO的优势并不明显甚至还不如IO，其主要原因是动态资源，是IO和cpu密集型操作，导致很多请求都阻塞在CPU和IO上，所以socket IO只能干等着，发挥不出NIO的优势

再看处理静态时NIO的表现，虽然不稳定但性能的提升还是很明显的，所以NIO常常用来处理请求多并且处理起来比较简单的应用中，如memcached

NIO只是优化了网络IO的读写，如果系统的瓶颈不在这里，比如每次读取的字节说都是500b，那么BIO和NIO在性能上没有区别。NIO模式是最大化压榨CPU，把时间片都更好利用起来。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源如内存，有关线程资源可参照这篇文章《一台java服务器可以跑多少个线程》。因此，使用的线程越少越好。而I/O复用模型正是利用少量的线程来管理大量的连接。在对于维护大量长连接的应用里面更适合用基于I/O复用模型NIO，比如web qq这样的应用。所以我们要清楚系统的瓶颈是I/O还是CPU的计算。



答案显然不是的，在不考虑系统本身限制的情况下，主要跟JVM一下几点有关：-Xms  初始堆大小 (在实际生产中，一般把-Xms和-Xmx设置成一样的。)
-Xmx  最大堆大小-Xss  每个线程栈大小
结论1：当给JVM的堆内存分配的越大，系统可创建的线程数量就越少（可以通过上面测试程序，不断的改变-Xmx，-Xms的值，观看最后异常时的线程数量）。这个如何理解呢？很简单，因为线程占用的是系统空间，所以当JVM的堆内存越大，系统本身的内存就越少，自然可生成的线程数量就越少。结论2：当-Xss的的值越小，可生成的线程数量就越多。(一样可以通过上面测试，保持-Xmx，-Xms不变，改变-Xss的值，jdk5以下默认好像是256K，以上默认为1M，具体记不太清楚了)。这个理解也很简单，线程可用空间保持不变，每个线程占用的栈内存大小变小，自然可生成的线程数量就越多。那么是不是不断加大可用内存，线程数量也会不断增长呢？这个当然不是，上面我特意加粗了不考虑系统本省限制的情况，所以说线程数量还与系统限制有关。主要跟一下几个参数有关(Linux下的)：/proc/sys/kernel/pid_max 增大，线程数量增大，pid_max有最高值，超过之后不再改变，而且32，64位也不一样
/proc/sys/kernel/thread-max 系统可以生成最大线程数量
max_user_process（ulimit -u）centos系统上才有，没有具体研究/proc/sys/vm/max_map_count 增大，数量增多总结：线程最大数量由JVM的堆(-Xmx,-Xms)大小、Thread的栈(-Xss)内存大小、系统最大可创建的线程数的限制参数三个方面影响。不考虑系统限制，可以通过这个公式估算：线程数量 = (机器本身可用内存 - JVM分配的堆内存) / Xss的值。


大部分情况下，使用 md5(md5(password) + salt) 方式加密基本上已经可以了：

salt

客户端拿到 Salt1 和 Salt2 之后，可以计算出两个加盐哈希：

SaltHash1 = bcrypt(SHA512(password), uid + salt1, 10)
SaltHash2 = SHA512(SaltHash1 + uid + salt2)

使用 SaltHash2 做为 AES 密钥，加密包括 uid，time，SaltHash1，RandKey 等内容传输给服务端：

Ticket = AES(SaltHash2, uid + time + SaltHash1 + RandKey)
AES(SharedKey, Ticket)



其中，最关键的是 salt 从哪里来？ salt 该怎么设置才能安全。有几个重要的点：

不要使用固定不变的 salt。
每个用户的 salt 都需要不同。
salt 要保持一定的长度。
salt 必须由服务端使用安全的随机函数生成。
客户端运算需要的 salt 需要从服务端动态获取。
客户端加盐 hash 的结果并不是最终服务端存盘的结果。

各语言安全的随机函数：

Platform	CSPRNG
PHP	mcrypt_create_iv, openssl_random_pseudo_bytes
Java	java.security.SecureRandom
Dot NET (C#, VB)	System.Security.Cryptography.RNGCryptoServiceProvider
Ruby	SecureRandom
Python	os.urandom
Perl	Math::Random::Secure
C/C++	(Windows API) CryptGenRandom
Any language on GNU/Linux or Unix	Read from /dev/random or /dev/urandom



因此，在比较 hash 时，使用时间恒定的比较函数，可以让攻击者摸不着头脑。比如下面这段代码：

private static boolean slowEquals(byte[] a, byte[] b)
{
    int diff = a.length ^ b.length;
    for(int i = 0; i < a.length && i < b.length; i++)
        diff |= a[i] ^ b[i];
    return diff == 0;
}
异或（^）操作可以用来判断两个字符是否相等，比如：

0 XOR 0 = 0    1 XOR 1 = 0
0 XOR 1 = 1    1 XOR 0 = 1
上面的函数枚举每个字符进行异或判断，然后将所有的结果取或运算，得到最终的结果，比较的时间是恒定的。

即使攻击者不能解密传输的内容，但仍可以使用重放攻击尝试身份验证或用于欺骗系统。重放攻击是指攻击者将数据包截取后，向目标主机重新发送一遍数据包。

防御重放攻击的方法主要有：

使用时间戳。数据包在一定时间范围内才是有效的。
使用递增的序号。收到重复的数据包时可以轻易的发现。
使用提问应答方式。收到数据包时可以判断出来是否应答过。


JDK以哪一个类加载器读取A类的字节码，则A类就是被哪一个类加载器加载 的。
	一个同名的类，是否可以相互转换，要看是否是在同个类加载器中。[]

oracle: 空值在最后

 select  *
 from emp
 order by comm desc
 nulls last


select length('北京') 字符数, lengthb('北京') 字节数
from dual

--lpad 左填充  rpad 右填充

select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;
select to_char(systimestamp,'yyyy-mm-dd hh24:mi:ss*ff') from dual;
时间戳

select last_day(sysdate) from dual;
--MONTHS_BETWEEN 计算工龄

SQL> --114月后
SQL> select add_months(sysdate,114) from dual;

SQL> --从今天开始算（2012.10.22星期一）,下一个星期一
SQL> select next_day(sysdate,'星期一') from dual;
NEXT_DAY(SYSDA
--------------
29-10月-12

SQL> --对日期进行四舍五入
SQL> select round(sysdate,'month') 一,round(sysdate,'year') 二 from dual;
一             二
-------------- --------------
01-11月-12     01-1月 -13

SQL> --查询员工的薪水： 货币符号，两位小数，千位符
SQL> select sal, to_char(sal,'L9,999.99') from emp;

SQL> --通用函数
SQL> --nvl2(a,b,c) 当a=null时，返回c，否则返回b

SQL> --nullif(a,b) 当a=b时，返回null，否则返回a
SQL> select nullif('abc','abc') from dual;


SQL> --COALESCE 从左至右找到第一个不为null的值
SQL> select comm,sal,COALESCE(comm,sal) from emp;

SQL> --平均奖金
SQL> select sum(comm)/count(*) 一, sum(comm)/count(comm) 二, avg(comm) 三 from emp;

        一         二         三
---------- ---------- ----------
157.142857        550        550

SQL> --空值 4. 组函数会自动滤空
SQL> select count(*),count(comm) from emp;

  COUNT(*) COUNT(COMM)
---------- -----------
        14           4

SQL> select count(*),count(nvl(comm,0)) from emp;

  COUNT(*) COUNT(NVL(COMM,0))
---------- ------------------
        14                 14

SQL> --可以在组函数中嵌套滤空函数，来屏蔽组函数的滤空功能

SQL> --SQL优化  3. 尽量使用where
SQL>               例外：如果条件中含义组函数，只能使用having

group by rollup(a,b)
=
	group by a,b
	+
	group by a
	+
	group by null

SQL> --SQLPLUS支持报表功能
--    按照部门号分段，相同部门号只显示一次    ，不同部门号间空格2行
SQL> break on deptno skip 2
--    取消设置
SQL> break on null

SQL> /*
SQL> 外连接解决的问题：当条件不成立时，任然希望在结果中包含不成立的记录
SQL> 左外连接: where d.deptno=e.deptno 当不成立时，等号左边代表的表的信息任然被包含
SQL>          写法: where d.deptno=e.deptno(+)
SQL> 右外连接: where d.deptno=e.deptno 当不成立时，等号右边代表的表的信息任然被包含
SQL>          写法：where d.deptno(+)=e.deptno
SQL> */


SQL> --自连接：利用表的别名，将同一张表视为多张表
SQL> --层次查询
SQL> --自连接不太适合操作大表
SQL>
SQL>
SQL>
SQL> --层次查询:  对同一张表的前后两次操作，进行连接    前empno号=后mgr  起始条件是start with 伪列level 层次查询中自动添加 order by level
SQL> select level,empno,ename,mgr
  2  from emp
  3  connect by prior empno=mgr
  4  start with mgr is null
  5  order by 1;


SQL> --SQL优化： 如果子查询和多表查询都可以，理论上尽量使用多表查询

SQL> --any 和集合的任意一个值比较
SQL> --查询工资比30号部门任意一个员工高的员工信息

SQL> --all 和集合的所有值比较

SQL> --打开sql执行时间
SQL> set timing on
SQL> set timing off


IN (null)       可以  ，
NOT IN (null)   不可以，查询不出数据  a != null 永远为假

NOT IN  等于 <> ALL

union     并集
INTERSECT 交集
minus	  差集

SQL> --隐式插入null值、显式插入空值

SQL> --地址符 &
--开启控制台输入

SQL> --一次插入（拷贝）一批数据
SQL> create table emp20 as select * from emp where 1=2;

SQL> --一次性将emp中所有20号部门的员工插入到emp20
SQL> insert into emp20
  2  select * from emp where deptno=20;

SQL> truncate table emp20;

表被截断。
SQL> drop table testdelete purge;

SQL> delete和truncate table的区别
SQL> 1. delete是DML，truncate是DDL (DML可以rollback，DDL不可以)
SQL> 2. delete逐条删除；truncate先摧毁，再重建
SQL> 3. delet会产生碎片；truncate不会
SQL> 4. delete不会释放空间；truncate会


SQL> /*
SQL> Oracle中的事务
SQL> 1. 事务的起始标志: DML语句
SQL> 2. 事务的结束标志: 提交: 显式提交 commit
SQL>                          隐式提交  DDL 语句,正常退出 exit
SQL>                   回滚: 显式  rollback
SQL>                         隐式 非正常退出,掉电,宕机
SQL> */
SQL> --保存点
SQL> create table testsavepoint
  2  (tid number,tname varchar2(20));
SQL> set feedback on


SQL> --定义保存点
SQL> savepoint a;

SQL> rollback to savepoint a;

回退已完成。

SQL> --rowid 行地址


SQL> alter table test1 modify tname varchar2(40);

表已更改。

SQL> alter table test1 drop column photo;

表已更改。

SQL> alter table test1 rename column tname to username;

表已更改。

SQL> drop table TESTDELETE;

表已删除。
SQL> --Oracle的回收站
SQL> --查看回收站
SQL> show recyclebin

SQL> --清空回收站
SQL> purge recyclebin
  2  ;

回收站已清空。

SQL> --彻底删除表
SQL> drop table test1 purge;

表已删除。

  1  create table myperson(
  2   pid varchar2(18) constraint myperson_PK primary key,
  3   pname varchar2(4) constraint myperson_Name not null,
  4   gender varchar2(4) constraint myperson_Gender check (gender in ('男','女')),
  5   email varchar2(30) constraint myperson_Email UNIQUE,
  6   deptno number constraint myperson_FK references dept(deptno) ON DELETE CASCADE
  7* )


SQL> --序列sequence
SQL> create sequence myseq;

SQL> /*
SQL> 序列不连续：
SQL> 1. 内存，长度20
SQL> 2. 序列是一个公有对象
SQL> 3. rollback序列不连续：
SQL> */

SQL> --为hr.EMPLOYEES起别名
SQL> create SYNONYM  hremp for hr.EMPLOYEES;
同义词已创建。

oracle分布式
SQL> --创建数据库链路
create database link l2 connect to scott identified by tiger using 'remoteorcl';

SQL> --在分布式数据库中执行查询
SQL> select ename,dname
  2  from dept, emp@L2
  3  where emp.deptno=dept.deptno;
from dept, emp@L2

SQL> create SYNONYM   remoteemp for emp@L2;

同义词已创建。

svnadmin create 仓库地址
svnserve -d -r 仓库地址


IDEA request

GET /rpc/obtainTicket.action?buildDate=20171128&buildNumber=2017.3.2+Build+IU-173.4127.27&clientVersion=4&hostName=yz&machineId=3e8714d1-3a15-4720-ac5a-32fd7f2c9aec&productCode=49c202d4-ac56-452b-bb84-735056242fb3&productFamilyId=49c202d4-ac56-452b-bb84-735056242fb3&salt=1515542214542&secure=false&userName=Administrator&version=2017300&versionNumber=2017300 HTTP/1.1
Accept-Encoding: gzip
User-Agent: Java/1.8.0_152-release
Host: 127.0.0.1:8484
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Connection: keep-alive

IDEA response

HTTP/1.1 200
Content-Type: text/html;charset=UTF-8
Content-Length: 405
Date: Tue, 09 Jan 2018 23:57:06 GMT

<!-- 47f996e9f7b12bfaa383614de03bffddfc8a1f04b0015dff674abc48e47e116e8c7127f1a38fb62ddc569836c6199192c4f1c4aec7814fd3c01664b6ea1f6534 -->
<ObtainTicketResponse><message></message><prolongationPeriod>607875500</prolongationPeriod><responseCode>OK</responseCode><salt>1515542214542</salt><ticketId>1</ticketId><ticketProperties>licensee=Administrator	licenseType=0	</ticketProperties></ObtainTicketResponse>


HTTP/1.1 200
Content-Type: text/html;charset=UTF-8
Content-Length: 405
Date: Wed, 10 Jan 2018 00:29:30 GMT

<!-- 197aa4016600e26b25e28bf7e5ab857ceb387a131573ed26c4a95fd0c6d5f03223f5a5f0b82ca82f21d714dd19f14c8dcbceb07370e4d76367875e8cf4b6078b -->
<ObtainTicketResponse><message></message><prolongationPeriod>607875500</prolongationPeriod><responseCode>OK</responseCode><salt>1515544156691</salt><ticketId>1</ticketId><ticketProperties>licensee=Administrator	licenseType=0	</ticketProperties></ObtainTicketResponse>



GET /rpc/prolongTicket.action?buildNumber=2017.3.2+Build+IU-173.4127.27&clientVersion=4&hostName=yz&machineId=3e8714d1-3a15-4720-ac5a-32fd7f2c9aec&productCode=49c202d4-ac56-452b-bb84-735056242fb3&productFamilyId=49c202d4-ac56-452b-bb84-735056242fb3&salt=1515545971788&secure=false&ticketId=1&userName=Administrator HTTP/1.1
Accept-Encoding: gzip
User-Agent: Java/1.8.0_152-release
Host: 127.0.0.1:8484
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Connection: keep-alive

HTTP/1.1 404
Content-Length: 0
Date: Wed, 10 Jan 2018 00:59:47 GMT


GET /rpc/releaseTicket.action?buildNumber=2017.3.2+Build+IU-173.4127.27&clientVersion=4&hostName=yz&machineId=3e8714d1-3a15-4720-ac5a-32fd7f2c9aec&productCode=49c202d4-ac56-452b-bb84-735056242fb3&productFamilyId=49c202d4-ac56-452b-bb84-735056242fb3&salt=1515545988233&secure=false&ticketId=1&userName=Administrator HTTP/1.1
Accept-Encoding: gzip
User-Agent: Java/1.8.0_152-release
Host: 127.0.0.1:8484
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Connection: keep-alive

HTTP/1.1 404
Content-Length: 0
Date: Wed, 10 Jan 2018 00:59:50 GMT



GET /rpc/obtainTicket.action?buildDate=20171128&buildNumber=2017.3.2+Build+IU-173.4127.27&clientVersion=4&hostName=yz&machineId=3e8714d1-3a15-4720-ac5a-32fd7f2c9aec&productCode=49c202d4-ac56-452b-bb84-735056242fb3&productFamilyId=49c202d4-ac56-452b-bb84-735056242fb3&salt=1515546515572&secure=false&userName=Administrator&version=2017300&versionNumber=2017300 HTTP/1.1
Accept-Encoding: gzip
User-Agent: Java/1.8.0_152-release
Host: 127.0.0.1:8484
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Connection: keep-alive

HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 405
Server: Jetty(8.1.21.v20160908)

<!-- 7c91b5667f365295a1dd5e60f1eecafe2279f0129c37ae7e45b8474c4a506e92ca472675f0eac0cbb8528ef1d83ea8d9839c4c4750443e8c03af6feac77ab81e -->
<ObtainTicketResponse><message></message><prolongationPeriod>607875500</prolongationPeriod><responseCode>OK</responseCode><salt>1515546515572</salt><ticketId>1</ticketId><ticketProperties>licensee=Administrator	licenseType=0	</ticketProperties></ObtainTicketResponse>


application-prod.properties
java -jar springboot.jar --spring.profiles.active=prod
