> * 快捷键
    清屏 Ctrl + L
    Tab键进行补全，aix ,ESC键后 \
    
> * 查看当前时间
    date
    
> * 创建文件或更新文件时间
    touch(选项)(参数)
        -a：或--time=atime或--time=access或--time=use 只更改存取时间；

> * 查看当前用户
    whoami
    
> * 查看命令
    whatis [命令]
    
> * 统计命令
    wc [选项] [文件名]
        -c 统计字节数
        -w 统计单词数，空格区分
        -l 统计行数

    wc 
    回车后输入内容
    ctrl + d 结束命令
    显示
        行数   单词数  子节数
        
> * 查看文件目录信息

ls [选项] [文件或目录]:
    -a 显示所有文件，包括隐藏文件
        .开头的隐藏文件
    -l 显示详细信息
        * 1. 权限
        -rw-r--r--
            文件类型，首位 
                (-文件 d目录 l 软链接文件 ),   ls -l /dev/    块设备文件，字符设备文件，套接字文件和管道文件
            所属组，用户与文件的关系
                u所有者，g所属组，o其他人
            r 读  w 写  x 执行    
        
        centos6后
        .    ACL权限
        
        * 2. 引用计数，代表文件被调用过几次，只在硬链接中使用
        1
        
        * 3. 所有者
        root
        
        * 4. 所属组
        root
        
        * 5. 字节,加-h后显示k,m,g
        
        * 6. 最后一次修改时间
        
        * 7. 文件名
            
        
    -d 查看目录属性
        ls -ld /etc/
        
    -h 人性化显示文件大小
        显示出k,m,g
    -i 显示inode
        文件ID NODE号
    
    -r     逆序排列。
    -t     按时间信息排序。
    -b, --escape
              把文件名中不可输出的字符用反斜杠加字符编号(就象在 C 语言里一样)的形式列出。

    ls -alrtb
    
    ll    ->  ls -l 别名
> * 目录处理命令
    * 创建目录，make directories
    mkdir -p [目录名]    
    -p 递归创建
    
    * 切换目录，change directory
    cd [目录名]
    cd ~ 进入当前用户的Home目录
    cd 
    cd - 进入上次所在目录
    cd .. 进入上级目录
    cd . 进入当前目录
    
    相对路径，绝对路径
    
    * 显示当前所在目录完整路径，print working directory
    pwd
    
    * 删除空目录，remove empty directories
    rmdir [目录名]
    
    * 删除文件或目录，remove
    rm [选项] [文件或目录]
        -r  删除目录
        -f  force，强制删除，默认选择Yes

    （    
    现在版本的Linux，不会完全删除本身    
    rm -rf /
    ）
    
    * 复制，copy
    cp [选项] [原文件或目录] [目标文件或目录]
        -r 复制目录
        -p 连带文件属性复制
        -d 若源文件是链接文件，则复制链接属性
        -a 完全COPY，相当与 -rpd
        
        cp 文件到目录,保持原名，到文件，即复制加改名
           默认新复制的文件，时间为cp命令执行时间

    * 剪切，改名，move
    mv [原文件或目录] [目标目录]
        
    
    * 常见目录
      /根目录
      /bin 命令保存目录(普通用户就可以读取的命令)
           根目录下的bin和sbin       
           usr目录下的bin和sbin
           都是保存系统命令的
           sbin 只有root 用户执行，bin任何用户都可以执行
      /boot 启动目录，启动相关文件
      /dev 设备文件保存目录
      /etc 配置文件保存目录
      /home 普通用户的家目录
      /lib 系统库保存目录
      /mnt 系统挂载目录,USB
      /media 挂载光盘目录
      /root 超级用户的家目录
      /tmp 临时目录
      /sbin 命令保存目录(超级用户才能使用的目录)
      /proc 直接写入内存的
      /sys  ，proc，sys内存的挂载点
      /usr 系统软件资源目录
        /usr/bin/系统命令(普通用户)
        /usr/sbin/系统命令 (超级用户)
      /var 系统相关文档的内容
      
> * 链接命令,link,
    ln -s [原文件] [目标文件]
    生成链接文件
        -s 生成软链接
    
    * 硬链接特征：
        * 1. 拥有相同的i节点和存储block块，可以看做是同一个文件
        * 2. 可通过i节点识别
        * 3. 不能跨分区
        * 4. 不能针对目录使用
        
        i node节点号，时间，存储位置
    
        ls -i 可以查看i node节点号
        ls -i 原 目标
    
    * 软链接特征：
        * 1. 类似Windows快捷方式
        * 2. 软链接拥有自己的I节点和Block块，但是数据块中只保存原文件的文件名和I节点号，并没有实际的文件数据
        * 3. lrwxrwxrwx    l 软链接
                 软链接文件权限都为rwxrwxrwx    
        * 4. 修改任意文件，另一个都改变，硬链接也是
        * 5. 删除原文件，软链接不能使用，硬链接可以
      原文件一定要写绝对路径  
    
> * 文件搜索
    * 文件搜索命令locate
    
           * 在后台数据库中按文件名搜索，搜索速度更快。 速度比find快
           * /var/lib/mlocate      · locate命令所搜索的后台数据库
                      slocate
                      locatedb
           * updatedb             更新数据库，默认每天更新
            
           * /etc/updatedb.conf 配置文件，whereis which也会遵守这个配置规则
             PRUNE_BIND_MOUNTS = "yes"
              ·  开启搜索限制，YES所有筛选规则都生效，NO 规则不生效
             PRUNEFS = 
              ·  搜索时，不搜索的文件系统
             PRUNENAMES = 
              ·  搜索时，不搜索的文件类型
             PRUNEPATHS = 
              ·  搜索时，不搜索的路径
             
    * 命令搜索命令whereis与which
            找不到shell内置命令，如cd
            * whereis 命令名
               ·  只能搜索系统命令，但是不能搜索自定义命令
              -b ，只查找可执行文件，不查找帮助文件
              -m ，只查找帮助文件
            * which 命令名
              查找对应命令，还会显示命令别名
      
       $PATH,系统搜索命令的路径
            以:分割
      
    * 文件搜索命令find
    
        find [搜索范围] [搜索文件]
        
        find / -name install.log
         · 避免大范围搜索，会非常耗费系统资源
         · find是在系统当中搜索符合条件的文件名。如果需要匹配，使用通配符匹配，通配符是完全匹配
        
        `*` 匹配任意字符
        `?` 匹配任意一个字符
        `[]` 匹配[]内任意一个字符
        
        -iname
            不区分大小写
        -user root
            按照所有者搜索
            find /root -user root
        -nouser
            查找没有所有者的文件
            find /root -nouser
            内核文件，外来文件
        -mtime
            查找10天前修改的文件
            find /var/log/ -mtime +10
            
            -10 10天内修改文件
             10 10天当天修改的文件
            +10 10天前修改的文件
                还支持按分钟
            
            atime 文件访问时间
            ctime 改变文件属性
            mtime 修改文件内容
        -size 
            查找文件大小为25k的文件
            find . -size 25k
            
            -25k 小于25k的文件
             25k 等于25k的文件
            +25k 大于25k的文件
            
            默认数据块
            k  
            M
       -inum     
            find . -inum 262422
            查找i节点是262422的文件
       
       find /etc -size +20k -a -size -50k
        · 查找/etc/目录下，大于20KB并且小于50KB的文件
       -a and 逻辑与，两个条件都满足
       -o or  逻辑或，两个条件满足一个即可
       
       find /etc -size +20k -a -size -50k -exec ls -lh {} \;
        · 查找/etc/目录下，大于20KB并且小于50KB的文件，并且显示详细信息
        · -exec/-ok 命令 {} \; 对搜索结果执行操作
      
      ......
    
    * 字符串搜索命令
        grep [选项] 字符串 文件名
         · 在文件中搜索匹配符合条件的字符串，如果需要匹配，使用正则表达式进行匹配，正则表达式时包含匹配
        -i 忽略大小写
        -v 取反，排除指定字符串

> * 帮助命令
    * 帮助命令 man
        man 命令
         · 获取指定命令的帮助
        
        man ls
         · 查看ls的帮助
        
        下表显示了手册的 章节 号及其包含的手册页类型。

            * 1   可执行程序或 shell 命令
            * 2   系统调用(内核提供的函数)
            * 3   库调用(程序库中的函数)
            * 4   特殊文件(通常位于 /dev)
            * 5   文件格式和规范，如 /etc/passwd
            * 6   游戏
            * 7   杂项(包括宏包和规范，如 man(7)，groff(7))
            * 8   系统管理命令(通常只针对 root 用户)
            * 9   内核例程 [非标准

         man -f 命令
            相当于whatis 命令
         eg:
            man -f passwd
            
            man 1 passwd
            man 5 passwd
            
            man 4 null
            man 8 ifconfig
            
    * apropos passwd
        在帮助文档内，找到含有关键字的帮助文档

    * 命令 --help
      获取命令的选项帮助
      eg:
      ls --help
      
    * help shell内部命令
      · 获取shell内部命令的帮助
      
      whereis cd
      · 确定是否是shell内部命令
      help cd
      · 获取内部命令帮助
      
    * 详细帮助命令 info
      - 回车  进入子帮助页面(带有*号标记)
      - u :  进入上层页面
      - n :  进入下一个帮助小节
      - p :  进入上一个帮助小节
      - q :  退出

> * 压缩与解压缩
    
    .rar 比 .zip 压缩比率，压缩速度更好，更先进
    常用压缩格式： .zip  .gz .bz2  .tar.gz  .tar.bz2    
    默认，软件包压缩包以红色显示
    
    * .zip
        zip 压缩文件名 源文件
        · 压缩文件
        
        zip -r 压缩文件名 源目录
        · 压缩目录
    
        unzip 压缩文件
        · 解压缩.zip文件
        
    * .gz
        gzip 源文件
        · 压缩为.gz格式的压缩文件，源文件会消失
        
        gzip -c 源文件 > 压缩文件
        · 压缩为.gz格式，源文件保留
        eg: gzip -c cangls > cangls.gz
        
        gzip -r 目录
        · 压缩目录下所有的子文件，但是不能压缩目录，不会打包成为一个压缩包
        
        gzip -d 压缩文件
        · 解压缩文件
        
        gunzip 压缩文件
        · 解压缩文件
        
    * .bz2，bzip2命令不能压缩目录
        bzip2 源文件
        · 压缩为.bz2格式的压缩文件，源文件会消失
        
        bzip2 -k 源文件
        · 压缩为.bz2格式的压缩文件，源文件会保留
        
        bzip2 -d 压缩文件
        · 解压缩文件，-k 保留压缩文件
        
        bunzip2  压缩文件
        · 解压缩文件，-k 保留压缩文件
        
    * .tar.gz
        tar -cvf 打包文件名 源文件
            * -c 打包
            * -v 显示过程
            * -f 指定打包后的文件名
        
        tar -xvf 打包文件名
        
            * -x 解打包
        
        其实.tar.gz格式是先打包为.tar格式，再压缩为.gz格式
        tar -zcvf 压缩包名.tar.gz 源文件...
            * -z 压缩为.tar.gz格式
            
            tar -cvf jp.tar jp
            gzip jp.tar 
            生成jp.tar.gz

        tar -zxvf 压缩包名.tar.gz
            * -zx 解压缩.tar.gz格式
        
        tar -jcvf 压缩包名.tar.bz2 源文件
            * -j 压缩为.tar.bz2格式
            
            tar -cvf jp.tar jp
            bzip2 jp.tar
            生成jp.tar.bz2

        tar -jxvf 压缩包名.tar.bz2
            * -jx 解压缩.tar.bz2格式
        
        -t只查看不解压
        tar -ztvf test.bar.gz
        
> * 关机和重启
    * shutdown [选项] 时间
        -c 取消前一个关机命令
        -h 关机，服务器避免关机
        -r 重启
        
      一般用到重启
      shutdown -r 05:30 &  
      &表示后台运行，不占用当前终端
        
    * 其他关机命令
        * halt
        * poweroff
        * init 0
        
    * 其他重启命令
        * reboot
        * init 6
    * init
        
        * 0 关机
        * 1 单用户
        * 2 不完全多用户，不含NFS服务
        * 3 完全多用户
        * 4 未分配
        * 5 图形界面
        * 6 重启

        使用runlevel查看当前运行
        前一个级别 现在的运行级别  N NULL        
        N 3
        
        cat /etc/inittab
            * 修改系统默认运行级别
              id:3:initdefault:
            
        Linux 一般 大写 X 代表图形界面    
        
    * 退出登录
        logout
        
> * 挂载命令
    * mount
      · 查询系统中已经挂载的设备
      
    * mount -a
      · 依据配置文件/etc/fstab的内容，自动挂载
      
    * mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点(已存在的空白目录)
        -t 文件系统: 加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660(光盘)等文件系统
        -o 特殊选项：可以指定挂载的额外选项
            
        mount -o remount,noexec /home/
        会提示.sh权限不足,root
        mount -o remount,exec /home/      
      
        /home/分区默认挂载好了，可以省略设备文件名
      
        vi hello.sh
        #!/bin/bash

        echo "hello world"

        chmod 755 hello.sh

        默认rw读写权限
        
    * 挂载光盘
        
        mkdir /mnt/cdrom/
        · 建立挂载点，空目录
        
        mount -t iso9660 /dev/sr0 /mnt/cdrom/
        (mount -t iso9660 /dev/cdrom /mnt/cdrom/) 需要系统完全启动，该软链接才会生效
        mount /dev/sr0 /mnt/cdrom/
        · 挂载光盘
    * 挂载U盘
        fdisk -l
        · 查看系统中已识别的硬盘，U盘设备文件名
        
        sd__
        
        mount -t vfat /dev/sdb1 /mnt/usb/
        
        ##Linux默认是不支持NTFS文件系统的，需要安装ntfs-3g等##
        
> * 卸载命令
    * umount 设备文件名或挂载点
        umount /mnt/cdrom
        · 卸载光盘
        
        
> * 查看登录用户信息命令
    * w 用户名，查询当前登录用户信息
        命令输出:
        * USER ：登录的用户名
        * TTY ： 登录终端
        * FROM ： 从哪个IP地址登录
        * LOGIN@ : 登录时间
        * IDLE ： 用户闲置时间
        * JCPU : 指的是和该终端连接的所有进程占用的时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间;
        * PCPU ： 是指当前进程所占用的时间
        * WHAT ： 当前正在运行的命令
        
    * who 用户名，查询当前登录用户信息
        命令输出：
        * 用户名
        * 登录终端
        * 登录时间(登录来源IP地址)
        
    * last，查询当前登录和过去登录的用户信息 
        · last命令默认是读取/var/log/wtmp文件数据
        命令输出
        * 用户名
        * 登录终端
        * 登录IP
        * 登录时间
        * 退出时间(在线时间)
    
        查看是否有人入侵
        
    * lastlog ，查看所有用户的最后一次登录时间
        · lastlog命令默认是读取/var/log/lastlog文件内容
        命令输出
        * 用户名
        * 登录终端
        * 登录IP
        * 最后一次登录时间
    
> * echo 输出命令
    echo [选项] [输出内容]
        -e :支持反斜线控制的字符转换
            \a  输出警告音
            \b  退格键，也就是向左删除键
            \n  换行符
            \r  回车键
            \t  制表符，也就是Tab键
            \v  垂直制表符
            \0nnn 按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数
            \xhh  按照十六进制ASCII码表输出字符。其中hh是两位十六禁止数
            
            \e 输出颜色
               \e[1;31m          \e[0m 
               [1; 开启颜色         [0m 取消颜色
               · 30m = 黑色, 31m = 红色, 32m = 绿色, 33m = 黄色
               · 34m = 蓝色, 35m = 样红, 36m = 青色, 37m = 白色
               
               

> * shell基础
    ## shell概述
    * shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。
    * shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。
    
    * Bourne Shell : 从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。
      最早的功能较简单，不支持查看历史命令，基本不用了，占用系统资源最少
      C Shell      : C She#!/bin/bash

        echo "hello world"ll主要在BSD版的Unix系统中使用，其语法和C语言类似而得名
      
      两种语法彼此不兼容。
      Bourne包括：sh、ksh、Bash、psh、zsh
      C     包括：csh、tcsh
      
      Bash 为当前Linux标准sh，AIX为ksh
      
      查看当前shell
      echo $SHELL
      
      支持的Shell
      cat /etc/shells
      
    ## 脚本执行方式
      vi hello.sh
      #!/bin/bash

      echo "hello world"  
    
      * 1. 赋予执行权限，直接运行
      chmod 755 hello.sh
      ./hello.sh
      
      * 2. 通过Bash调用执行脚本
      bash hello.sh
      
    ## Bash的基本功能
      ### 命令别名和快捷键
           alias
           · 查看系统中所有的命令别名
           
           alias 别名 = '原命令'
           · 设定命令别名
           
           vi ～/.bashrc           
           · 写入环境变量配置文件，别名永久生效
           
           unalias 别名
           · 删除别名

           命令生效顺序
           * 1. 执行用绝对路径或相对路径执行的命令
           * 2. 执行别名
           * 3. 执行Bash的内部命令
           * 4. 执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
           
           常用快捷键
           * ctrl + c  强制终止当前命令
           * ctrl + l  清屏
           * ctrl + a  光标移动到命令行首
           * ctrl + e  光标移动到命令行尾
           * ctrl + u  从光标所在位置删除到行首
           * ctrl + z  把命令放入后台，一般不要使用
           * ctrl + r  在历史命令中搜索
           
           AIX中ctrl + u  ,l ,c
           
      ### 历史命令
           history [选项] [历史命令保存文件]
                
               * -c : 清空历史命令，正确退出后文件也将清空。非必要，最好不要清空 
               * -w : 把缓存中的历史命令强制写入历史命令保存文件~/.bash_history
                                                        文件中为上次正确登录时操作的命令
               历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改
               HISTSIZE = 1000
               
               Linux历史命令的调用
               * 使用上、下箭头调用以前的历史命令，AIX中为ESC后K J
               * 使用"!n"重复执行第n条历史命令
               * 使用"!!"重复执行上一条命令
               * 使用"!字符" 重复执行最后一条以该字符串开头的命令
               
               
      ### 命令和文件目录补全
           Tab键补全，AIX 中ESC后 \
           
           
      ### 重定向
           
           * 标准输入输出
           
           | 设备   |   设备文件名  |    文件描述符 | 类型 |
           | 键盘   | /dev/stdin  |     0       |  标准输入   |
           | 显示器 | /dev/sdtout  |     1       |  标准输出   |
           | 显示器 | /dev/sdterr  |     2       | 标准错误输出  |
           
           * 输出重定向
           
           | 类型               |   符号            |    作用                 |
           | 标准输出重定向      | 命令   > 文件      |  以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。 |
           | -- --             | 命令  >> 文件     |   以追加的方式，把命令的正确输出输出到指定的文件或设备当中  |
           | 标准错误输出重定向   | 错误命令 2> 文件  |   以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。 |
           | -- --             | 错误命令 2>> 文件 |    以追加的方式，把命令的错误输出输出到指定的文件或设备当中  |
           | 正确输出和错误输出同时保存 | 命令 > 文件 2>&1 | 以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中。 |
           | -- --             | 命令 >> 文件 2>&1     |  以追加的方式，把正确输出和错误输出都保存在同一个文件当中。 |     AIX使用
           | -- --             | 命令 &> 文件      | 以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中。 |
           | -- --             | 命令 &>> 文件      |  以追加的方式，把正确输出和错误输出都保存在同一个文件当中。 |
           | -- --             | 命令 1>> 文件1 2>> 文件2  |  把正确的输出追加到文件1中，把错误的输出追加到文件2中。 |
           
           
           window 也通用
           
           ls &> /dev/null
           · 不要输出结果，不显示，不保存
           
           * 输入重定向
             wc test.log
             wc < test.log 
             
             wc << EOF             
             输入内容
             再次输入EOF时，结束输入重定向
           
      ### 多命令顺序执行
        
           | 多命令执行符 | 格式             | 作用                                   |
           |     ;      | 命令1; 命令2      | 多个命令顺序执行，命令之间没有任何逻辑联系   | 
           |    `&&`    | `令令1&&命令2`    | 逻辑与。当命令1正确执行，则命令2才会执行。当命令1执行不正确，则命令2不会执行 |
           |    `||`    | `命令1|| 命令2`   | 逻辑或。当命令1执行不正确，则命令2才会执行。当命令1执行正确，则命令2不会执行 |
           
           
           date ; tar -zcvf etc/tar.gz /etc ; date
           
           ls && echo yes || echo no
              正确执行输出yes ，错误执行输出no
              
              
      ### 管道符
           命令1 | 命令2
           · 命令1的正确输出作为命令2的造作对象
           
           ls -l | more 
           
           netstat -an | grep "ESTABLISHED" | wc -l
           连接当前服务器的人数
           
      ### 通配符
           
           | 通配符     | 作用                                |
           | ?         | 匹配一个任意字符                      |
           | *         | 匹配0个或任意多个任意字符，也就是可以匹配任何内容    |
           | []        | 匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或是a，或是b，或是c  | 
           | [-]       | 匹配中括号中任意一个字符。- 代表一个范围。例如：[a-z]代表匹配一个小写字母。    |
           | [^]       | 逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符。 | 
           
           正则表达式
           
      ### Bash中的其他特殊符号
      
           | 符号       |  作用                                            |
           | ''        | 单引号。在单引号中所有的特殊符号，如"$"和"`"(反引号)都没有特殊含义。 |
           | ""        | 双引号。在双引号中特殊符号都没有特殊含义，但是"$"、"`"、"\"是例外，拥有"调用变量的值"、"引用命令"、"转义字符"的特殊含义。 |
           | ``        | 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。        |
           | $()       | 和反引号作用一样，用来引用系统命令。推荐使用                                |
           | #         | 在Shell脚本中，以#开头的行代表注释。              |
           | $         | 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。  | 
           | \         | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出"$"符号，而不当做是变量引用。  |
           
           
           
           
           
